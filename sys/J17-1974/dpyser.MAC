COMMENT    VALID 00125 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00014 00002	SUBTTL III DISPLAY PACKAGE - D. POOLE - NOV 1968
C00016 00003	 BYTE POINTERS INTO BITS THAT SAY SIZE SET BY USER OR UUO
C00018 00004	COMMENT   THE FOLLOWING IS SYSTEM START TIME INITIALIZING CODE.
C00021 00005	 THIS ROUTINE MAKES UP A PROGRAM HEADER AND LINE EDITOR BUFFER.
C00026 00006	 MORE INITIALIZE CODE FOR A NEW PROGRAM-LINED-BUFFER THING
C00028 00007	 NOW SET UP THE POINTERS IN THE TABLES TO GET THE DP STARTED
C00031 00008	GETTING NEW DATA DISC CHANNEL. FIRST DESELECT AVAILABLE MSG,
C00033 00009	 ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO
C00036 00010		PUSHJ P,DPYKFS		GIVE ALL THE CORE BACK
C00039 00011	 WE GET HERE TO PLANT ANOTHER CLOCK REQUEST TO COME BACK
C00041 00012	 HERE ARE THE INTERRUPT ROUTINES FOR RUNNING THE DP.
C00044 00013	HERE WE HAVE AND ERROR - - PRINT A MESSAGE AND CHECK THE SYSTEM!
C00047 00014	 DP INTERRUPT CODE - RESTART PROGRAM, LOOP AROUND OF NEXT DPY, STOP DP, SET AVAILABLE MESSAGE
C00049 00015	PPINIT		PAGE PRINTER STUFF
C00052 00016		SETZM PPDD(DAT)		 ASSUME III UNTIL PROVEN OTHERWISE
C00055 00017	 FREE STORAGE HANDLER FOR PAGE PRINTER
C00057 00018	BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.
C00062 00019	TYO, DPYTYO.
C00067 00020	 WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
C00071 00021	PR1ECR:	JUMPGE DAT,PR1EC1	 IS THIS A DD?
C00075 00022	BEGIN EXTBUF	MAKE MORE ROOM IN THE DISPLAY BUFFER.
C00079 00023	 WE GET HERE UPON GLITCHING ON A DATA DISC DISPLAY
C00082 00024	 THESE ARE UTILITY ROUTINES USED BY THE PAGE PRINTER
C00085 00025	 HANDY ROUTINE TO GET POINTER TO TEXT FROM LINE NUMBER IN AC3
C00086 00026	 WE GET HERE IF THE POINTERS DON'T AGREE
C00087 00027	 ROUTINE TO CONVERT THE POSITION VECTOR INTO A DATA DISK
C00088 00028	FBLK:	PUSH P,AC1		FREE SOME BLOCKS FROM P.P.
C00091 00029	PPOUT:  WE GET HERE WHEN IT IS TIME TO OUTPUT PART OF A PIECE OF PAPER TO THE DISK.
C00093 00030	A SIMPLE MESSAGE PRINTER. JSA ITEM,ERRP WITH
C00094 00031	HERE ARE UUO LEVEL ROUTINES FOR MANIPULATING THE PAGE PRINTER.
C00097 00032	MORE PP ROUTINES.
C00101 00033	PPSEL <N>  MAKES P. OF P. <N> THE CURRENT ONE AND TURNS IT ON.
C00104 00034	 ROUTINE TO WAIT FOR TYPEOUT TO FINISH
C00105 00035	PPYPOS Y MAKES THE CURRENT P OF P START AT Y COORD. Y.
C00108 00036	 WE GET HERE WHEN THE APPEARANCE OF THE PAGE HAS CHANGED ENOUGH
C00110 00037	 ROUTINE TO ERASE PARTS OF DATA DISK SCREEN
C00112 00038	 HERE IS A ROUTINE TO MOVE THE LINE POINTER TABLE AROUND
C00114 00039	PPXSIZ <N>B26 ! <M>  SETS CURRENT P OF P TO HAVE N GLITCHES OF M LINES.
C00117 00040	CLKSER	THIS IS DPYSER'S OWN PRIVATE CLOCK QUEUER.
C00120 00041	 THIS ROUTINE QUEUES UP ANOTHER WHO LINE REQUEST.
C00123 00042	 ROUTINE TO FREE AN ENTIRE LIST OF BLOCKS, LINKED UP THROUGH LINK
C00125 00043	UUO LEVEL UTILITY ROUTINES AND DISPATCHERS.
C00128 00044	MORE GENERAL UUO ROUTINES.
C00129 00045	 ROUTINE TO RESET A DISPLAY. CLEARS PAGE PRINTER AND PIECES OF GLASS.
C00132 00046	 CALLED FROM <ESC>N IN LINE EDITOR BY A CLOCK REQUEST
C00134 00047	 CALLED FROM <ESC>L IN LINE EDITOR. SETS LINES/GLITCH
C00136 00048	 SET PAGE PRINTER HOLD COUNTS. GIVE LINE COUNT IN BITS 18-26 AND
C00138 00049	 THIS ROUTINE GIVES THE USER A NICE LITTLE TABLE OF DATA ABOUT HIS
C00142 00050	 PPINFO CONT - RUN DOWN LIST OF PP CTRL BLOCKS
C00144 00051	 THIS IS THE ROUTINE FOR A UUO WHICH SETS YOUR LINE EDITOR'S VERTICAL
C00146 00052	FREEL FREES A LIST OF BLOCKS POINTED TO BY AC1, AND UPDATES
C00147 00053	UPG IS THE DEMOCRATIC UUO WHICH ALLOWS ALL MEN,
C00150 00054		MOVN TAC1,UCHN		LENGTH OF USERS CODE.
C00153 00055	MORE OF UPG.
C00155 00056	 RST WITH NO PARAM BITS ON IS A NOOP -- ALLOW ANY ARGUMENT
C00157 00057	 DATA DISC PROGRAM HANDLER
C00161 00058	 HERE WE ARE, READY TO SET THE CHANNEL ADDRESS OF HIS DATA DISC PROGRAM
C00164 00059	 GET HERE TO LOOK AT A USER'S COMMAND WORD AND SEE IF THERE IS A CHANNEL SELECT
C00166 00060	CHANNEL ADDRESS CHECKING. HE CAN WRITE ON HIS OWN SCREEN,
C00168 00061	PGSET  SETS UP REQUESTED PIECE OF GLASS.
C00170 00062	 THIS IS THE DPY ERROR ROUTINE. IT TYPES OUT THE PC IN TAC1 ON
C00172 00063	^^UPGMVM:PUSHJ P,UPGMV		DO `MOVEM' INTO P OF G: TAKE CARE OF PRELIMINARIES.
C00175 00064	^^PGIOT:
C00178 00065	 THIS UUO GETS INFORMATION FROM THE SYSTEM ABOUT THE USER'S PIECES
C00180 00066	DPYTYP IS CALLED AT CLOCK LEVEL TO TYPE SOME CHRS. FROM A 
C00183 00067	 HERE WE ARE AT CLOCK LEVEL WITH (SUPPOSEDLY) DAT SET TO
C00187 00068	 ROUTINE TO TYPE CTY ERROR MESSAGE ON ILLEGAL LINE NUMBER
C00189 00069	 ROUTINE, CALLED FROM CLOCK CALL WITH LINE NUMBER IN DAT, TO CONTINUE PAGE PRINTER
C00192 00070	 COME HERE FOR DATA DISK TO SEE IF IT IS END OF LINE OR GLITCH TIME.
C00193 00071	SUBTTL DATA DISK SERVICE ROUTINE - JAM, DEC. 1970
C00196 00072	 CLOCK LEVEL QUEING SCHEME. PLANTS TASKS IN QUEUE AND LEAVES.
C00200 00073	 WE GET HERE AT CLOCK LEVEL IN THE MIDDLE OF QUEUEING UP A WHOLE SCREEN REQUEST.
C00203 00074	 WE GET HERE TO QUEUE UP A ONE LINE REQUEST.
C00206 00075	 THIS ROUTINE QUEUES UP AN ERASURE REQUEST FOR THE LINE EDITOR <ESC>C COMMAND
C00209 00076	 HERE LIES A ROUTINE TO QUEUE UP A WHOLE PAGE TRANSFER WHEN NOT GLITCHING
C00212 00077	 HERE IS THE MIGHTY LINE EDITOR AND CURSOR GENERATOR.
C00214 00078	 HERE WE SET UP THE CURSOR POSITION AND START ON THE DECISION TREE
C00217 00079	 WE GET HERE IF THE VERTICAL POSITION OF THE LINE EDITOR HAS NOT CHANGED.
C00220 00080	 LINE EDITOR DECISION TREE. WE GET HERE IF THE LINE EDITOR CURSOR HAS NOT
C00223 00081	 EVERYBODY COMES HERE TO EXIT
C00225 00082	 THIS ROUTINE QUEUES UP A LINE EDITOR TEXT REQUEST
C00227 00083	 THIS ROUTINE ERASES THE OLD SECOND LINE OF THE LINE EDITOR
C00229 00084	 THIS ROUTINE ERASES THE OLD CURSOR
C00231 00085	 THESE ROUTINES QUEUE UP THE VARIOUS COMBINATIONS OF CURSORS THAT MAY ARISE.
C00233 00086	QBLOCK	  HERE IS THE MAGIC SCHEDULING QUEUE ROUTINE
C00236 00087	 HERE WE SEE IF THE TASK IS AN EASY OUTSIDER.
C00239 00088	 HERE WE SCAN THE QUEUE SYSTEM LOOKING FOR A FRAME WITH SOME FREE LINES
C00242 00089	 WE GET HERE IF THE TASK IS ENTIRELY OUT OF BOUNDS
C00244 00090	 WE GET HERE WHEN THERE IS NO QUEUE AT ALL.
C00246 00091	 HERE IS A ROUTINE THAT MOVES ON TO THE NEXT FRAME, IF THERE IS NO NEXT
C00252 00092	 HERE LIES THE INCREDIBLE INTERRUPT-LEVEL ROUTINES!
C00254 00093	 ALL THE I-LEVEL ROUTINES RETURN TO HERE WHEN THEY ARE DONE
C00256 00094	 THIS ROUTINE IS CALLED AT CLOCK LEVEL WITH A LIST OF TASKS THAT
C00257 00095	 THIS ROUTINE TAKES A TASK OUT OF THE QUEUE AND WAKES UP ANYONE IF
C00260 00096	 PAGE PRINTER TRANSFERS
C00264 00097	PPXFR3:	MOVEI AC1,DDCW(DAT)	 PICK UP ADDRESS OF START OF TRANSFER
C00266 00098	 HERE IS THE ERASE CODE.
C00268 00099	 CURSOR TRANSFERS.
C00271 00100	 THIS ROUTINE MAKES UP THE CODE FOR A CURSOR.
C00273 00101	 LINE EDITOR TRANSFERS
C00276 00102	 WE GET HERE WHEN THE TRANSFER IS DONE OR ABORTED.
C00278 00103	 WHOLE SCREEN ERASURE AND AVAILABLE MESSAGE
C00281 00104	 USER DATA DISC PROGRAM . . .
C00284 00105	 ALL TRANSFERS COME BACK TO HERE WHEN THEY ARE DONE OR TIMED OUT
C00286 00106	 DATA DISC NON-EX MEM TYPEOUT, ACCUMULATOR SAVER, AND CLOCK TIMEOUT ROUTINES
C00288 00107	 WE GET HERE IF WE GET AN INTERRUPT FROM THE DATA DISK AND
C00289 00108	DEFINITIONS FOR DATA DISC ALLOCATION
C00291 00109	INITIALIZATION FOR DATA DISC ALLOCATION AND VIDEO SWITCH
C00294 00110	ALL-PURPOSE DD CHANNEL DIDDLING UUO:
C00296 00111	RELEASE CHANNEL C(TAC)
C00298 00112	GET CHAN SPECIFIED BY TAC(31-35) IF FREE
C00300 00113	ROUTINE TO THROW ALL SPIES OFF PRIVATE CHANNEL.
C00303 00114	SET STATUS OF CONSOLE CHANNEL
C00306 00115	ALL-PURPOSE VDS DIDDLING UUO:
C00309 00116	VDMAP2:	HLL TAC,VDDSP(AC1)
C00311 00117	VDSET:	PUSHJ P,VDWCHK
C00313 00118	ROUTINE TO BLESS BITS ABOUT TO BE TURNED ON FOR PRIVACY VIOLATION
C00315 00119	SUBTTL WHO LINE GENERATOR--R. HELLIWELL--6/APR/70
C00318 00120	^WHOSER:MOVE	DAT,TIME
C00323 00121	WHOSIX:	MOVEI	AC2,6			CHARACTER COUNT
C00326 00122	THIS IS THE PART WE ALWAYS UPDATE.
C00331 00123	 THIS ROUTINE SETS UP A NEW WHO TABLE FROM A PIECE OF FREE STORAGE
C00334 00124	WLRET:	MOVE 	AC3,[POINT 7,WTEND+5(AC1),20]
C00339 00125	^WHOSYS:
C00346 ENDMK
C;
                                              SUBTTL III DISPLAY PACKAGE - D. POOLE - NOV 1968
COMMENT 
	THESE ARE THE GLORIOUS, WORLD-SAVING III DISPLAY
ROUTINES.  FOR THEIR FIRST TRICK, THEY WILL IMPERSONATE
W. F. WEIHER, THUS STARTING THE PROGRAM ON A NOTE OF
LIGHT HUMOR.



BEGIN DPYSER

CHR_TEM	;SAME AS CHREC IN SCNSER

;; NOW SOME DISPLAY OPCODES AND MACROS FOR GENERATING DP INSTRS.

DISJMP__20	;DP JMP INSTR. OPCODE.
DISJMS__4	; JMS (STORES TWO WORDS)
DISJSR__24	; STORES ONLY RETURN ADDR.
DISRST__14	;RESTORE.
DISSEL__10	;SELECT.
DISNOP__14	;ACTUALLY RST, BUT A GOOD NOP WITH ALL BITS OFF.

DEFINE LVW(X,Y,TYPE,MODE,BRT,SIZ)	;ASSEMBLES A LONG VECTOR.
  { MVW1 (MODE,TYPE,BRT,SIZ)	;TWIDDLE PARAMS.
	BYTE (11)<X>,<Y>(3)B,S(2)MD,TT(3)3 ~	;ASSEMBLE INSTR.
DEFINE MVW1 (M,T,BRT,SIZ)
 {IFIDN {M~{A~{MD_1;~MD_0	;MODE = `A' FOR ABSOLUTE.
  IFIDN {T~{I~{TT_2;~TT_0	;TYPE = `I' FOR INVISIBLE.
  IFIDN {BRT~{~{B_0;~B_BRT	;BRT = 0 IF OMITTED.
  IFIDN {SIZ~{~{S_0;~S_SIZ	;SAME FOR SIZ.
~
DEFINE ERMS (X) {JSA ITEM,ERRP
POINT 7,[ASCIZ X
]
~
DEFINE CW (C1,B1,C2,B2,C3,B3) {<BYTE (8)<B1>,<B2>,<B3>(3)<C1>,<C2>,<C3>>!4~
GLOBAL DDTAB,JB2SWP	;STUPID FAIL
                                                                                                                                        ; BYTE POINTERS INTO BITS THAT SAY SIZE SET BY USER OR UUO

SIZSBU:	POINT 1,GWORD(DDB),0	; IF 1, SAYS LINES/GLITCH OR GLITCHES/PAGE SET BY USER LAST
POSSBU:	POINT 1,GWORD(DDB),1	; SAYS Y-POS. SET BY USER COMMAND (RATHER THAN UUO)
LHCSBU:	POINT 1,GWORD(DDB),2	; SAME FOR LINE HOLD COUNT
GHCSBU:	POINT 1,GWORD(DDB),3	; SAME FOR GLITCH HOLD COUNT
HLINES:	POINT 9,GWORD(DDB),17	; POINTS TO NUMBER OF LINES BEFORE HOLDING
HGLTCH:	POINT 9,GWORD(DDB),26	; POINTS TO NUMBER OF GLITCHES BEFORE HOLDING
;	POINT 9,GWORD(DDB),35	; CHAR WHICH ACTIVATED LINED

; NORMAL VALUES FOR THE PAGE PRINTER

NGSIII__14		; GLITCHES/PAGE FOR III DISPLAYS
NGSDD__4		; GLITCHES/PAGE FOR DD DISPLAYS
NLSIII__2		; LINES/GLITCH FOR III
NLSDD__11		; LINES/GLITCH FOR DD
YPIII__600		; Y-POSITION FOR III
YPDD__660		; Y-POSITION FOR DD
^NDDSPQ__60		;# SPARE DD QUEUE BLOCKS (TIRED OF BEING SCREWED -REG)

                                                                                                                                                                                                                                                                                                                                                                                                   COMMENT   THE FOLLOWING IS SYSTEM START TIME INITIALIZING CODE.
 	MUCH OF IT IS IN TEMPORARY FORM.


^DWPINI:  
	MOVEI	AC1,2		;INITIALIZE COMMON DD CURSOR BUFFER
	MOVEM	AC1,DDCURS+2	;BY PROPAGATING A ZERO GRAPHICS WORD DOWN IT
	MOVE	AC1,[XWD DDCURS+2,DDCURS+3]
	BLT	AC1,DDCURS+21	;ALL THE WAY (TOO BAD THAT SOME PEOPLE CAN'T COUNT)
	MOVEI TAC,DPYNUM
	MOVEM TAC,DRUNCT	;INIT. PTR. TO NEXT DPY TO RUN.
	HRLOI TAC,377777
	MOVEM TAC,DDCNT
	SETZM FSWTHD		;CLEAR FS WAIT LIST.
	SETZM FSWT2H		;AND THE WAIT LIST WAIT LIST.
	SETZM DDSTART		; CLEAR ALL THE DATA DISK FLAGS
	SETZM DDRUN
	SETZM STRTBL		; ZERO OUT ALL THE IMPORTANT TABLES
	MOVE TAC,[XWD STRTBL,STRTBL+1]
	BLT TAC,LETAB+DPYNUM+DDNUM-1
	SETOM DXFLAG		;START DP ON FIRST CLOCK TICK.
	MOVE TAC,[POINT 36,CLKQUE-1,35]
	MOVEM TAC,CLKQ		;INIT. CLOCK QUEUE PTR.
	MOVE TAC,[IOWD LCPDL,CLKPD]	;..ALSO CLOCK PDL.
	MOVEM TAC,DPYPDL
	MOVSI TAC,770000	; RESTORE AVAILABLE MESSAGES
	HLLM TAC,DPYAVL+1
	HLLM TAC,WHOSEL		; SYSTEM WHO LINE FOR ALL AVAILABLE IIIS
	MOVSI TAC,77		; DESELECT EVERYONE
	HLLM TAC,DPYHLD		; HOLDING MESSAGE TOO
IFN FTOIKB, < CONO KBD,SCNCHN >		;GIVE INTERRUPT CHANNEL TO KEYBOARD SCANNER.
	CONO DDD,10
	PUSHJ P,DDINI
	JRST WHOINI

DWPERR:	PUSHJ P,DISMES
	ASCIZ /CATASTROPHIC ERROR FROM DPYSER
/
DPYATL:	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ; THIS ROUTINE MAKES UP A PROGRAM HEADER AND LINE EDITOR BUFFER.
; IT EXPECTS THE LINE NUMBER IN TAC1. PRESERVES ALL OTHER ACCUMULATORS.
; SKIPS UPON SUCCESS. IF FAILURE, WILL PLANT A CLOCK REQUEST AND
; TRY TO GET ONE LATER.

^DPYMAKE:
	SKIPE LETAB-DPYL0(TAC1)	; DO WE ALREADY HAVE A PROGRAM HEADER?
	JRST CPOPJ1		; YES, GIVE SUCCESS RETURN
	PUSH P,TAC
	PUSH P,DAT
	PUSH P,DDB
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	MOVNI TAC,1
	HLL TAC1,LINTAB(TAC1)
	TLNN TAC1,DDDLIN
	JRST DPYM1
	MOVSI TAC,400100-DDL0(TAC1)
	PUSHJ P,DDAGET	;FIRST MAKE SURE WE HAVE A CHANNEL FOR DD
	JRST DPYXTL	;GO DIRECTLY TO JAIL
	ANDI TAC,-1
DPYM1:	MOVEI AC3,DHFS
	PUSHJ P,SFSGET
	JRST DPYM8
	HRRZ DDB,AC1
	SETZM (AC1)		; FIRST, ZERO THE THING OUT
	HRLZ AC2,AC1
	HRRI AC2,1(AC1)
	MOVE AC3,AC1
	BLT AC2,DPYLEN-1(AC3)
	MOVEI AC2,DISRST!60	; NOW SET UP THE STARTUP WORD TO RESTORE THE POSITION VECTOR
	HRLI AC2,PRGSAV(AC1)	; THAT WAS STORED LAST TIME THE DPY WAS STOPPED
	MOVEM AC2,(AC1)
	HRLI AC2,LEB+1(AC1)	; THE LINE EDITOR DOES THIS TOO
	MOVEM AC2,LEPPV+4(AC1)
	SETZM LEB(AC1)
	HRLI AC2,LEB(AC1)	; SET UP THE LINE EDITOR CALL
	HRRI AC2,DISJMS
	MOVEM AC2,LEJMS(AC1)
	HRRI AC2,DISJMP		; FILL UP THE LINE EDITOR BUFFER WITH RETURN JUMPS
	MOVEM AC2,LEBUF(AC1)
	HRLI AC2,WHOCALL(AC1)	; MAKE RESTART POINT JUMP BACK TO WHO LINE CALL
	MOVEM AC2,RTJMP(AC1)
	HRLI AC2,LEBUF(AC1)	; NOW BLT THE RETURN JUMP ALL OVER THE
	HRRI AC2,LEBUF+1(AC1)	; LINE EDITOR BUFFER.
	BLT AC2,LEHPOS-1(AC1)
	MOVSI AC3,(TAC)
	HRRI AC3,-DPYL0(TAC1)
	MOVEM AC3,PRGNUM(DDB)
	PUSHJ P,PPINIT		;GET PAGE PRINTER SET UP FOR EACH DPY.
	JRST DPYM7
	PUSHJ P,PPSET
	JUMPGE TAC,DPYM2
	MOVNI AC3,-DPYL0(TAC1)
	MOVE AC2,[BYTE (12)0,7777,DISSEL]
	MOVEM AC2,PSELC(DDB)
	MOVSI AC2,400040	; NOW MAKE UP SELECT WORD
	LSH AC2,(AC3)		; PUT A BIT IN THE FIRST TWO 12-BIT FIELDS
	XOR AC2,[77770000]	; COMPLEMENT THE SECOND FIELD
	ORI AC2,DISSEL
	MOVEM AC2,PSELA(DDB)	; AND THIS IS OUR SELECT WORD
	MOVEM AC2,PSELB(DDB)	; AND OUR SPARE SELECT WORD
	AND AC2,[77B5]		; MASK OUT ALL BUT SELECT BIT
	ANDCAM AC2,DPYAVL+1	; DESELECT THIS CONSOLE FROM AVAILABLE MESSAGE
	ANDCAM AC2,WHOSEL	; DESELECT THIS CONSOLE FROM SYSTEM WHOLINE
	LSH AC2,-=12		; PUT BIT IN 'RESET' FIELD
	ORM AC2,DPYAVL+1	; BE SURE TO RESET THIS CONSOLE TOO
	ORM AC2,WHOSEL		; BE SURE TO RESET THIS CONSOLE TOO
	MOVE AC2,[LVW (-5,-14)]	; MAKE A CURSOR FOR THE LINE EDITOR
	MOVEM AC2,LEPPV+1(DDB)
	MOVE AC2,[LVW (12,0)]
	MOVEM AC2,LEPPV+2(DDB)
	MOVE AC2,[LVW (-5,14)]
	MOVEM AC2,LEPPV+3(DDB)
	MOVE AC2,[LVW (0,0,I)]	; NOW A NULL VECTOR FOR THE LEFT MARGIN
	MOVEM AC2,LELMARG(DDB)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ; MORE INITIALIZE CODE FOR A NEW PROGRAM-LINED-BUFFER THING

DPYM3:	MOVEI AC2,LEBUF+BUFL-4(DDB)
	MOVEM AC2,MAXPT(DDB)	; MAKE UP POINTER TO END OF LINE EDITOR BUFFER
	MOVNI AC1,24000/BLKSIZ	; 24000 WORDS MAXIMUM TOTAL PROGRAMS
	MOVEM AC1,BLKTOT(DDB)	;HOW MANY MORE BLOCKS EACH USER GETS.
	HRRZI TAC,-DPYL0(TAC1)
	MOVEI AC1,DISNOP
	MOVEM AC1,WHOCALL(DDB)	;NO WHO LINE YET.
	MOVEM AC1,LEPOS(DDB)	; NORMAL VERTICAL POSITION
	MOVEM AC1,PGCALL(DDB)	;NO PG'S.
	MOVEM AC1,LEPPV(DDB)
	MOVEI AC1,400000
	MOVEM AC1,PRGACT(DDB)	;P OF P 0 ACTIVE.
	MOVEM AC1,USRACT(DDB)
	MOVEI AC1,3		; BUMP NUMBER OF SPARE FREE BLOCKS
	ADDM AC1,DPYFS+SPFSN
	ADDM AC1,SPFSNT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ; NOW SET UP THE POINTERS IN THE TABLES TO GET THE DP STARTED
; AND STOPPED ON THIS PROGRAM

	HRL AC2,DDB		; NOW INITIALIZE ALL THE APPROPRIATE TABLES
	HRRI AC2,DISJMP		; THIS LITTLE JUMP GOES TO DPYTAB
	HRLI AC3,PRGSTP(DDB)
	HRRI AC3,DISJMS		; THIS LITTLE JUMP GOES TO STPTBL
	HRLI AC1,PSELB(DDB)
	HRRI AC1,DISJMP		; AND THIS LITTLE JUMP WENT WEE WEE WEE
	MOVEI DAT,LETAB(TAC)	;Give the header a pointer to
	MOVEM DAT,LETBPT(DDB)	; its LETAB entry.
	MOVEI DAT,PSELA(DDB)
	CONO PI,PIOFF		; ALL THE WAY INTO RSTTBL
	SKIPE LETAB(TAC)	; DID SOMEONE SNEAK IN UNDER US?
	JRST DPYM5
	HRRZM DDB,LETAB(TAC)	; INITIALIZE LINE EDITOR TABLE TOO
	CONO PI,PION
	CAIL TAC,DPYNUM
	JRST DPYXIT		;THAT'S ALL FOR DD
	MOVEM DAT,SELTBL(TAC)
	MOVEM AC3,STPTBL(TAC)	;IN THIS ORDER
	MOVEM AC1,RSTTBL(TAC)	;WE SHOULDN'T NEED
	MOVEM AC2,STRTBL(TAC)	;TO KEEP PI'S OFF
DPYXIT:	AOS -6(P)		;WE HAVE WON
DPYXTL:	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DDB
	POP P,DAT
	POP P,TAC
	POPJ P,

DPYM5:	CONO PI,PION
	CAIL TAC,DPYNUM
	JRST DPYM6
	PUSHJ P,DPYKFS		;III - JUST RET FS
	JRST DPYXIT

DPYM6:	HRRZM DDB,DPRLSF(DDB)	;DD - DEFER FS RET FOR DDWIPE
	MOVSI TAC,100-DDL0(TAC1)
	HLR TAC,PRGNUM(DDB)
	PUSHJ P,DDREL		;BUT GIVE BACK CHNL NOW
	JRST DPYXIT

DPYM7:	PUSHJ P,DPYKF2		;RET HDR
DPYM8:	JUMPL TAC,DPYXTL
	HRLI TAC,100-DDL0(TAC1)
	PUSHJ P,DDREL		;RELEASE DD CHNL
	JRST DPYXTL

^PPSET:	HRRZM  DDB,HEDPTR(AC1)	;MAKE PP0 CONT. BLK. POINT AT HEADER.
	HRLI AC1,DISJMP		;ASSEMBLE JMP TO PP 0.
	MOVSM AC1,PPCALL(DDB)	;HAVE HEADER CALL THE PP.
	HRRZM AC1,CURPP(DDB)	;MAKE P OF P 0 THE CURRENT ONE.
	MOVEI AC3,PPCALL+1(DDB)	;RETURN ADDR. TO HEADER FROM PP.
	HRLM AC3,PPRJMP(AC1)	;PUT IN PP RETURN JMP.
	POPJ P,
                                                                                                                                                                                                 ;GETTING NEW DATA DISC CHANNEL. FIRST DESELECT AVAILABLE MSG,
;THEN ERASE CHANNEL, THEN SELECT CONSOLE TO CHANNEL.

DPYM2:	MOVE AC2,AVLBIT
	HRLI DDB,DDWIPE
	CONO PI,SCNOFF
	ANDCAB AC2,VDMAP-DDL0(TAC1)
	MOVEM AC2,VDTMP(DDB)
	CONO PI,PIOFF
	IDPB DDB,CLKQ
	CONO PI,PION!SCNON
	JRST DPYM3

;HERE AT CLOCK LEVEL (CAN'T CALL QBLOCK FROM CH5)
DDWIPE:	SKIPE DDB,DPRLSF(DAT)
	JRST DPYKFS		;DPYMAKE WAS ABORTED - RET FS NOW
	PUSHJ P,GETQ
	HRRZ AC2,CURPP(DAT)
	ADDI AC2,PPENQ
	MOVEM AC2,QCOUNT(AC1)
	AOS (AC2)	;WILL HOLD UP BOTH DPLED & DPYTYP
	HRLI DAT,DDMAP
	MOVEM DAT,QWAKE(AC1)
	JRST LEERS3

;HERE AFTER ERASE IS FINISHED. NOW THAT CHANNEL IS CLEAN, WE LET HIM SEE IT.
DDMAP:	HLRZ AC1,PRGNUM(DAT)
	HRRZ TAC,PRGNUM(DAT)
	SUBI TAC,DPYNUM
	PUSHJ P,VDSTRB
	IORM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT
	MOVEI DAT,DDL0(TAC)
	JRST DPYTYP		;IN CASE PP XFER WAS FLUSHED
                                                                                                                                                                                                                                                                                                                                                                                                                ; ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO
; FLUSH A DPY BUFFER, IF THAT IS WHAT IS CALLED FOR.

^DPYKIL:CAIL TAC,DPYNUM+DDNUM
	JRST DPYKER
	SKIPE AC1,LETAB(TAC)
	SETZM LECLIN(AC1)	; CLEAR FLAG THAT SAYS CLOCK REQUEST IS IN
	SKIPN TTYTAB+DPYL0(TAC)	; FIRST, IS TTYSER THROUGH WITH IT?
	SKIPG AC1,LETAB(TAC)
	POPJ P,			; NO, LEAVE IT AROUND
	SKIPE LEACT(AC1)	; HAS THE LINE EDITOR BEEN ACTIVE IN THE LAST MINUTE?
	JRST DPYKI9		; YES, WAIT ANOTHER MINUTE
	SKIPN LEENQ2(AC1)	; IF HE'S REFRESHING OR HELPING,
	SKIPE LEENQ(AC1)	; OR IF HIS LINE EDITOR IS IN THE QUEUE
	JRST DPYKI7		; PLANT ANOTHER CLOCK REQUEST TO KEEP US AROUND
	HLRZ AC2,PPCALL(AC1)	; OR IF HE HAS ANY PIECE OF PAPER QUEUED
DPYKI8:	SKIPE PPENQ(AC2)	; ANYTHING IN QUEUE?
	JRST DPYKI7
	HRRZ AC2,LINK(AC2)	; PICK UP POINTER TO NEXT PIECE OF PAPTER CONTROL BLOCK
	JUMPN AC2,DPYKI8	; LOOP BACK IF ANY
	HRRZ DDB,AC1
	CAIL TAC,DPYNUM
	HRLI DDB,400000	;SET DD FLAG
	PUSHJ P,PGCLR		; CLEAR ANY AND ALL PIECES OF GLASS
	CONO PI,PIOFF
	SKIPN TTYTAB+DPYL0(TAC)	; ONE LAST CHECK!
	SKIPG LETAB(TAC)
	JRST DPYKI3
	SETZM LETAB(TAC)
	JUMPL DDB,DPYKL1
	SETZM RSTTBL(TAC)
	SETZM STPTBL(TAC)
	SETZM STRTBL(TAC)
DPYKL1:	CONO PI,PION
	HRRZ AC2,DDB
	SKIPA J,JOBNM1
DPYKML:	SETZM DPYMAP+1(J)		;CLEAR GUY MAPPED TO US
	CAIE AC2,@DPYMAP(J)
	SOJG J,.-1
	SOJGE J,DPYKML
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 	PUSHJ P,DPYKFS		;GIVE ALL THE CORE BACK
	JUMPGE DDB,DPYK11	;JUST DIDDLE SELECT FOR III
DPYK10:	MOVSI TAC,100-DPYNUM(TAC)
	HLR TAC,PRGNUM(DDB)
	PUSHJ P,DDREL
	MOVEI AC1,(TAC)
	LDB TAC,[220600,,TAC]
	PUSHJ P,VDBIT
	ANDCAB AC3,VDMAP(TAC)
	JUMPN AC3,VDOUT		;FORGET AVAIL MSG IF SOMETHING ELSE ON SCREEN
	MOVE AC3,AVLBIT
	IORM AC3,VDMAP(TAC)
	JRST VDOUT

DPYK11:	MOVNS TAC
	MOVSI AC1,400000	; PUT A BIT IN THE CONSOLE SELECT POSITION
	LSH AC1,-=12(TAC)	; PUT IT IN THE RESET PART FIRST
	ANDCAM AC1,DPYAVL+1	; DON'T RESET US
	ANDCAM AC1,WHOSEL	; DON'T RESET US FOR WHOLINE EITHER
	LSH AC1,=12		; PUT IT IN THE SELECT POSITION
	ORM AC1,DPYAVL+1	; SELECT THIS CONSOLE
	ORM AC1,WHOSEL		; SELECT THIS CONSOLE FOR SYS WHO LINE
	POPJ P,			; BYE NOW.

DPYKI3:	CONO PI,PION
	POPJ P,

DPYKFS:	MOVNI AC2,3
	MOVEI AC3,DPYFS
	PUSHJ P,SFSREL		;GIVE BACK SPARE TEXT BLOCKS
	HLRZ DAT,PPCALL(DDB)
	JUMPE DAT,DPYKF2	;NO PAGE PRINTER
DPYKF1:	MOVE AC1,FBLKPT(DAT)
	PUSHJ P,FREEL		;RELEASE TEXT BLOCKS
	HRRZ AC1,PTB(DAT)
	JUMPE AC1,.+2
	PUSHJ P,FSGIVE		;& LINE POINTER TABLE
	MOVE AC1,DAT
	HRRZ DAT,LINK(DAT)	;GET POINTER TO NEXT P. OF P.
	PUSHJ P,UGIVFS		;BECAUSE THIS ONE'S GOING AWAY
	JUMPN DAT,DPYKF1	;KEEP GOING IF MORE
DPYKF2:	MOVEI AC1,(DDB)
	JRST UGIVFS		;NOW RETURN HEADER
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ; WE GET HERE TO PLANT ANOTHER CLOCK REQUEST TO COME BACK
; LATER TO TRY AND KILL THE DAMN THING.

DPYKI9:	SETZM LEACT(AC1)	; CLEAR THE ACTIVE FLAG
	SKIPA AC3,DPYKRQ
DPYKI7:	MOVE AC3,[XWD DPYKILL,1]
	SETO AC2,		; SET FLAG SAYING THERE IS A CLOCK REQUEST IN
	EXCH AC2,LECLIN(AC1)
	JUMPL AC2,CPOPJ		; IF THERE ALREADY IS A CLOCK REQUEST IN, DON'T BOTHER TO SET ANOTHER
	LSH TAC,=12		; SHIFT LINE NUMBER OVER TO DATA POSITION
	ADD TAC,AC3		; HAVE US COME BACK HERE IN 1 TICK
	CONO PI,PIOFF
	IDPB TAC,CLOCK(PID)
	CONO PI,PION
	POPJ P,

; THIS ROUTINE PRINTS AN ERROR MESSAGE WHEN THE GIVEN
; LINE NUMBER IS ILLEGAL.

DPYKER:	PUSH P,TAC		; SAVE THE ILL NUMBER
	PUSHJ P,DISERR		; GIVE OUR ERROR MESSAGE
	[ASCIZ /ILLEGAL LINE NUMBER AT DPYKILL - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,TAC
	POPJ P,

^DPYKRQ:	DPYKIL,,=15*=60	;TIME TO WAIT BEFORE KILLING CONSOLE
                                                                                                                                                                                                                                                                                                                                                                                                   ; HERE ARE THE INTERRUPT ROUTINES FOR RUNNING THE DP.



^DPYINT:	BEGIN DPYINT

DP__430		;DEVICE NO. OF DISPLAY PROCESSOR.
DPYCHL_<FOR @$ QQ_DPYCHN,DPYCHN {CH$QQ~>	;PI CHANNEL 3 IS WHERE IT'S AT.
DPCONB__40	;THE `CONTINUE' BIT FOR THE  DP.
DPNULL__0
DPNXM__2000	; THE NON-EX MEM BIT
DPINT__4000	; INTERRUPT REQUEST
DPSTOP__200	; SET NOT RUNNING
DPCHK__400	; ERROR CHECK FLAG

	CONSO DP,400000		;IS IT REALLY STOPPED ?
	JEN @DPYCHL		;NO. 
	EXCH TAC,DRUNCT		;GET NO. OF DPY WHICH HAS BEEN ON.
	SKIPN STPTBL(TAC)	; STOP HIM HERE ONLY IF HE HAS A STOP TABLE
	JRST NOSTOP
	DATAO DP,STPTBL(TAC)	;STOP DP AT RIGHT PRGM HEADER.
	MOVEM TAC1,@SELTBL(TAC)
	CONI DP,TAC1		;SAVE CURRENT SELECTION FOR NEXT TIME
	HRRI TAC1,DISSEL
	EXCH TAC1,@SELTBL(TAC)
NOSTOP:	CONSZ DP,DPNXM!DPCHK	; HIT A NON-EX MEM OR ERROR CHECK?
	JRST DPERR		; YES, PROCESS IT
L6:	SOJL TAC,L1		;NEXT PRGM TO RUN. (6 PRGMS ALWAYS ARE RUNNING)
L5:	CONSO DP,400000		;MAKE SURE HE FINISHED STOPPING
	JRST L5
	SKIPE RSTTBL(TAC)	;DOES HE WANT TO START FROM THE FRONT ?
	JRST L2			;YES.
	SKIPN STRTBL(TAC)	; IS THERE A PROGRAM THERE?
	JRST L7
	DATAO DP,STRTBL(TAC)	;NO.  START HIM AT NORMAL PLACE.
L3:	EXCH TAC,DRUNCT		;PUT THINGS BACK.
	ROT 44
	CONO DP,DPCONB+DPYCHN+740000+1000	;START DP AND CLEAR MASKS.
	JEN @DPYCHL		;RETURN TO WHOMEVER.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;HERE WE HAVE AND ERROR - - PRINT A MESSAGE AND CHECK THE SYSTEM!

DPERR:	EXCH P,APRPDL+P1PID	; GET A STACK
	PUSHACS			; GET US SOME AC'S
	MOVEI PID,P1PID
	MOVEM TAC,SAVTAC		;SAVE DP #
	CONI DP,DPCNI		;GET SOME BITS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/DP ERROR.
CONI BITS = /]
	DISARG LOC,DPCNI
	[ASCIZ/
DPY# = /]
	DISARG LOC,SAVTAC
	-1
	MOVE AC3,SAVTAC
	SKIPN AC3,STPTBL(AC3)
	JRST NOADDR
	HLRZS AC3
	HLRZ AC3,(AC3)		;GET MA
	PUSHJ P,DISERR
	[ASCIZ/    MA = /]
	DISARG LOC,AC3
	[ASCIZ/
/]
	-1
	CAILE AC3,1
	CAMLE AC3,RMEMSIZ	;IS IT LEGAL?
	JRST ADDRCK
	PUSHJ P,DISERR
	[ASCIZ\MA-2/   \]
	DISARG OCT,-2(AC3)
	[ASCIZ\
MA-1/   \]
	DISARG OCT,-1(AC3)
	[ASCIZ\
MA/     \]
	DISARG OCT,(AC3)
	-1
	JRST NOADDR
ADDRCK:	PUSHJ P,DISMES
	ASCIZ/NON-EX ADDRESS/
NOADDR:	PUSHJ P,DISMES
	ASCIZ/


/
	PUSHJ P,SYSFIX		;CHECK SYSTEM FOR CLOBBERING
	JFCL			;OK
	JFCL			;NOT OK
	SKIPN DEBMOD		;DOES HE WANT TO LOOK AT IT?
	JRST NODPLK		;NO
	SETOM DISFLAG
	PUSHJ P,DISFLUSH	;FORCE OUT THE REST
	PUSHJ P,DDTCALL		;AND CALL DDT
NODPLK:
	MOVEI TAC,DPYNUM-1	;RESTART ALL DISPLAYS
L8:	SKIPN DDB,LETAB(TAC)
	JRST L9			; IF NONE THERE, LOOP
	HRLI DDB,PSELB(DDB)	; ARRANGE TO RESTART AT TOP AGAIN
	HRRI DDB,DISJMP
	MOVEM DDB,RSTTBL(TAC)
L9:	SOJGE TAC,L8		; GET THEM ALL!
	POPACS			; GET BACK AC'S
	EXCH P,APRPDL+P1PID	; AND WHATEVER WAS IN P
	JRST L6			; AND DO NEXT GUY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ; DP INTERRUPT CODE - RESTART PROGRAM, LOOP AROUND OF NEXT DPY, STOP DP, SET AVAILABLE MESSAGE

L2:	DATAO DP,RSTTBL(TAC)	;START GUY AT BEGINNING OF HIS PRGM.
	SETZM RSTTBL(TAC)	;...THIS TIME ONLY.
	JRST L3

L1:	SKIPE DPYHOL		; HAS THE HOLDING MESSAGE GONE OUT YET?
	JRST L1A		; YES, CONTINUE WITH OUR BUSINESS
	SETOM DPYHOL
	DATAO DP,[XWD DPYHLD,DISJMP]
	JRST L3

L1A:	SETZM DPYHOL
	MOVEI TAC,DPYNUM-1	;WE'VE RUN `EM ALL.
	SETZM DPYARN		; NOTE THAT THEY HAVE ALL BEEN RUN
	AOSE DSFLAG		;HAS CLOCK TICKED ?
	AOJA TAC,L4		;NO. IT'S NOT YET TIME TO START OVER.
	JRST L5

L4:	CONO DP,DPNULL		;SHUT DOWN THE DP.
	EXCH TAC,DRUNCT
	JEN @DPYCHL

L7:	SKIPE DPYARN		; HAS THE 'CONSOLE AVAILABLE' MESSAGE GONE OUT YET?
	JRST L6			; YES
	SETOM DPYARN		; NO, IT WILL.
	DATAO DP,[XWD DPYAVL,DISJMP]
	JRST L3			; GO START UP DP AND LEAVE

BEND
                                                                                                                                                                                                                                                                                                                                                                                                                                    ;PPINIT		PAGE PRINTER STUFF

COMMENT  	THIS IS THE ABODE OF THE FEARSOME PAGE PRINTER.
	IT ALLOWS EACH LUCKY USER (IF HE IS OBEDIENT) TO HAVE
	UP TO 16 PIECES OF PAPER (OR REASONABLE FACSIMILE
	THEREOF), ON ANY OF WHICH HE CAN TYPE AND DRAW IN
	DIVERSE WAYS, AND WHICH CAN BE ROLLED BACKWARD AND
	FORWARD AND DISPLAYED SEPARATELY OR IN ARBITRARY
	COMBINATION WITH OTHER DISPLAYS.
		EACH PIECE OF PAPER CONSISTS OF A LINKED
	SET OF BLKS FROM FREE STORAGE AND ONE CONTROL BLOCK,
	ALSO FROM FREE STORAGE. THE CONTROL BLOCK IS LINKED
	TO THE PROGRAM HEADER AND TO THE CONTROL BLOCKS FOR ANY
	OTHER PIECES OF PAPER BELONGING TO THE SAME PROGRAM.


OUTNUM__1	;THIS MANY BLOCKS AT ONCE GET PUT ON DISK.
LINELN__=88	;NO. OF CHARS. PER LINE.
DDLINELN__=84	; SAME AS ABOVE FOR DATA DISK
CBLKBT__1;	;MAGIC CODE BITS FOR THE (HO, HO) RELOCATING GARBAGE COLLECTOR.
TBLKBT__4
FBLKBT__2

^PPINIT:	   		;INITIALIZE A PAGE PRINTER WITH PIECE OF PAPER 0.
	PUSHJ P,PPFSGET		;GET A BLOCK OF FREE STORAGE.
	POPJ P,			; NO FREE STORAGE, GIVE ERROR RETURN
	HRR AC3,AC2		;MAKE BLT POINTER.
	HRRZ DAT,AC2
	HRLI AC3,PPMODL
	BLT AC3,BLKSIZ-1(AC2)	;INIT. THE CONTROL BLK. BY COPYING THE PROTOTYPE INTO IT.
	PUSHJ P,PPFSGET		;GET A BLOCK FOR FIRST PART OF PRGM.
	JRST PPI1		; NO FREE STORAGE, RELEASE PREVIOUS BLOCKS AND GIVE ERROR RETURN
	MOVEM AC2,CBLKPT(DAT)	;MAKE IT CURRENT BLOCK...
	MOVEM AC2,FBLKPT(DAT)	;.. AND FIRST BLOCK IN CORE...
	MOVEM AC2,TBLKPT(DAT)	;... AND TOP BLK BEING DISPLAYED.
	HRRM AC2,PPTR1(DAT)	;MAKE BYTE POINTER FOR TYPING POINT
	SOS PPTR1(DAT)		;ONE BEFORE BOTTOM OF BLOCK.
	HRLM AC2,TPJMP(DAT)	;FIX UP JMP TO PRGM IN CONT. BLK.
	HRLI AC3,TPJMP+1(DAT)	;RETURN ADDR. FROM PRGM. TO CONT. BLK.
	HRRI AC3,DISJMP
	MOVEM AC3,(AC2)		;PUT RETURN JMP IN FIRST WORD OF PRGM.
	HRLZM DAT,LINK(AC2)	;BACKWARD LINK OF PRGM. POINTS TO CONT. BL.K.
	SETZM LINK(DAT)		;ONLY ONE CONT. BLOCK.
  	SETZM PPDD(DAT)		; ASSUME III UNTIL PROVEN OTHERWISE
	MOVEI AC3,LPFS		; GET SOME FREE STORAGE FOR THE
	PUSHJ P,SFSGET		; LINE POINTER TABLE
	JRST PPI3
	MOVEM AC1,PTB(DAT)	; SAVE ADDRESS OF BEGINNING OF BLOCK
	ADDI AC1,=20		; BUMP ADDRESS TO VISIBLE SCREEN PART
	HRRM AC1,PTRB(DAT)
	MOVE AC2,PPTR1(DAT)	; INITIALIZE FIRST WORD OF POINTER TABLE
	ADD AC1,VPOS(DAT)	; GET ADDRESS OF FIRST POINTER TO BE USED
	MOVEM AC2,(AC1)		; TO POINT TO FIRST OF TEXT
	MOVEM AC2,1(AC1)	; SAME FOR DD
	JUMPL TAC,PPFXT		;DONE FOR III
	SETOM PPDD(DAT)
	MOVEI AC1,11		; SET NUMBER OF LINES IN A GLITCH TO 8
	MOVEM AC1,DEL(DAT)
	MOVEM AC1,DELCNT(DAT)
	MOVEI AC1,4		; AND NUMBER OF GLITCHES TO 4, SUCH THAT WE GET
	MOVEM AC1,PGSIZ(DAT)	; 32 LINES TO A SCREEN AND DON'T DO A WHOLE PAGE REFRESH TOO OFTEN
	MOVEM AC1,VPOS(DAT)
	MOVEM AC1,LLW(DAT)
	MOVEM AC1,GLW(DAT)
	SETZM DDSAV(DAT)	; CLEAR EXTRA SAVED WORDS
	MOVE AC1,[CW 1,46,2,0,3,2]
	DPB TAC,[POINT 8,AC1,15]
	MOVEM AC1,DDCW(DAT)
	MOVEI AC2,DDLINELN	; SET OUR OWN LINE LENGTH
	MOVEM AC2,LNLNGT(DAT)
	MOVNM AC2,DPHPOS(DAT)	; INITIALIZE THE HORIZONTAL POSITION COUNTER
	MOVE AC1,[LVW -777,YPDD,I,A,2,2]
	MOVEM AC1,PPOSV(DAT)
	SETZM TPJMP+1(DAT)
	SETZM TPJMP+2(DAT)
	MOVE AC1,[CW 3,2,4,0,5,0]
	MOVEM AC1,TPJMP+4(DAT)
PPFXT:	MOVE AC1,DAT
	JRST CPOPJ1

; WE GET HERE MOSTLY IF A REQUEST FOR FREE STORAGE FOR THE PAGE PRINTER FAILS

PPI3:	HRRZ AC1,CBLKPT(DAT)	; RETURN FIRST PIECE OF TEXT
	PUSHJ P,FSGIVE
PPI1:	HRRZ AC1,DAT		; AND RELEASE CONTROL BLOCK ITSELF
	JRST FSGIVE		; TAKE ERROR RETURN FROM PPINIT
                                                                                                                                                                                                                                                                                                                                                          ; FREE STORAGE HANDLER FOR PAGE PRINTER

PPFSGE:	MOVE AC2,AC1
	MOVEI AC3,PPFS
	AOS (P)
	PUSHJ P,SFSGET
	SOS (P)
	EXCH AC2,AC1
	POPJ P,

;;UGETFS IS FOR GETTING FREE STG. AT UUO LEVEL.

CGETFS:	AOSA BLKTOT(DDB)
UGFS2:	PUSHJ P,CLKWAT		;WAIT FOR SOME FS TO APPEAR.
^UGETFS:			;;GET A BLOCK OF FREE STG. FROM JAM.
	MOVEI AC3,DPYFS
	PUSHJ P,SFSGET
	SKIPE AC1,SPWUUF(PID)	;WE ARE AT CLOCK LEVEL AND THERE'S NO FREE STG.
	POPJ P,
	SKIPN AC1,INTACT(PID)	; OR AT USER INTERRUPT LEVEL
	JRST UGFS2		;OOPS, NONE THERE, AND WE ARE NOT IN SPACEWAR MODE.
	POPJ P,

; ROUTINE TO RELEASE FREE STORAGE BLOCKS

CGIVFS:	SOS BLKTOT(DDB)		;DECR. COUNT OF USED BLOCKS...
^UGIVFS:
	CONO PI,PIOFF
	MOVE AC2,FSWT2H	;FREE THE BLOCK IN AC1.
	HRRZM AC1,FSWT2H
	HRRM AC2,LINK(AC1)
	CONO PI,PION
	AOS FSW2C
	POPJ P,

;GET A DD Q BLOCK
GETQ:	PUSH P,AC3
	MOVE AC3,[SETZ DDFS]	;NO SKIP
	PUSHJ P,SFSGET
	POP P,AC3
	POPJ P,

UGETF2:	PUSHJ P,CLKWAT
UGETF1:	PUSHJ P,FSGET
	SKIPE AC1,SPWUUF(PID)	;TOO BAD WE HAVE TO DUPLICATE ALL THIS SHIT
	POPJ P,
	SKIPN AC1,INTACT(PID)
	JRST UGETF2
	POPJ P,
                                                                                                                                                                               ;BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.

DEFINE X (A,B) {A__.-PPMODL
		B
		~
PPMODL:  

X PPOSV,{LVW  -777,YPIII,I,A,2,2~	;POS VECTOR
X TPJMP, DISJMP		;JMP TO FIRST BLOCK OF PAGE BEING DISPLAYED.
	LVW (7,-17,I)	;NOW DRAW THE CURSOR.
	LVW -5,-10
X ^DDCW,<LVW 12,0>
	LVW -5,10
	LVW (-7,7,I)
X PPRJMP, DISJMP	;JMP BACK TO HEADER OR ON TO NEXT CONT. BLK.

X HEDPTR, 0		;POINTER BACK TO PRGM HEADER.
X OUTCNT,OUTNUM		;BLOCKS REMAINING BEFORE DISK OUTPUT.
X PPNO,0		;NONO. OF THIS P. OF P.
X ^DPHPOS,-LINELN	;CHARS. LEFT BEFORE END OF THIS LINE.
X CNT1,0		;CHARS. REMAINING  BEFORE EXTENSION NEEDED.
X PPTR1,{POINT 7,0,35~	;CURRENT POINTER FOR PRINTING ON THIS PIECE OF PAPER.
X SPTR1,0		; SAVED POINTER FOR ZEROING OUT SPACE BEFORE CR
X WCNT,-INITWC		;FREE WORDS LEFT IN CURRENT BLOCK.
X CBLKPT,0		;BOTTOM OF CURRENT BLOCK.
X TBLKPT,0		;FIRST BLOCK CURRENTLY DISPLAYED (AT TOP OF SCREEN)
X FBLKPT,0		;FIRST BLOCK STILL IN CORE.
X DEL,2			; NO. OF LINES IN A GLITCH.
X DELCNT,2		;LINES REMAINING IN CURRENT GLITCH.
X GLCNT,1		;CURRENT SIZE OF PAGE IN GLITCHES.
X PGSIZ,14		;NOMINAL SIZE OF PAGE IN GLITCHES.
X PTBEG,0		; INCREMENT INTO LINE POINTER TABLE
X DDSPT,0		;POINTS TO SAVED WORD FROM FIRST REFRESHED LINE (DD)
X DDSAV,0		;SAVED WORD FROM FIRST REFRESHED LINE (DD)
	0
X (^VPOS,3)		;LINE NUMBER OF CURRENT LINE
X LLW,3			; LAST LINE WRITTEN
X PTRB,<XWD AC3,0>	;POINTS TO TABLE OF BYTE POINTERS TO THE FIRST OF EACH LINE (DD)
X PTB,0			; ACTUAL TABLE ADDRESS
X VP,0			; VERTICAL POSITION ARGUEMENT TO QDD
X SC,0			; ARGUEMENT TO QDD FOR COUNT FIELD ADDRESS
X DPYCHR,0		; FLAG SAYING AT LEAST ONE CHARACTER HAS BEEN TYPED
X LSTCHR,12		; LAST CHARACTER DEPOSITED INTO BUFFER
X GLW,3			; GREATEST LINE WRITTEN, FOR ERASING WHEN WE GLITCH
X PPDD,0		; DATA DISK FLAG
X GLTCH,0		; FLAG THAT SAYS THE PAGE PRINTER HAS GLITCHED
X PPINV,0		; FLAG INDICATING PAGE PRINTER POINTERS ARE BEING MODIFIED
X PPENQ,0		; NUMBER OF TASKS THIS PAGE PRINTER HAS IN THE DD QUEUE
X PPNQT,0		; COUNT DOWN FOR NON-PAGE PRINTER REQUESTS
X PPVIRG,-1		; INDICATES VIRGIN PAGE PRINTER
X ^LNLNGT,LINELN	;LINELENGTH FOR THIS GUY.


; ALL DISPLAY PROGRAM SPACE IS TAKEN FROM A FREE
;  STORAGE AREA CONSISTING OF FIXED SIZE BLOCKS.  THE
; FOLLOWING PARAMETERS RELATE TO THOSE BLOCKS.

BLKSIZ__<<LNLNGT+5+1>!<TRIVIAL-1>>-1	;BLOCK SIZE. THIS IS ARBITRARY, BUT 36
^BLKSIZ__BLKSIZ
LINK __ BLKSIZ-1	;LINKS IN LAST WD OF BLK: XWD BACK,FORWARD
BLKBTS __ LINK-1	;MAGIC TYPE BITS FOR BLK GO HERE.
GCINFO __ BLKBTS-1	;INFO FOR THE (HYPOTHETICAL) GARBAGE COLLECTOR
FSBSIZ__BLKSIZ-2	;BLKSIZ FOR OUTSIDE WORLD.
^FSLINK__LINK
CNT__GCINFO-2		;MAX. NO. OF `GLITCHES' PER PAGE.
INITWC__GCINFO-2	;THIS MANY WORDS/BLOCK AVAILABLE FOR PROGRAM.
                                                                                                                                                                                                                                                                                                                                                                                                                                         ;TYO, DPYTYO.

;TYO: CHARACTER IN CHR, DAT POINTS TO P.OF P. CONTROL BLOCK.

;???PRINT IS CALLED WITH A BYTE PTR. IN TAC AND A
;POSITIVE CHAR. COUNT IN TAC1 AND DAT POINTING TO CONTROL BLOCK.


^^DPYTYO:
	MOVE DAT,CURPP(DDB)	; PICK UP POINTER TO PAGE PRINTER CONTROL BLOCK
	HLL DAT,DDB		; PUT IN DD BIT
	JRST TYO

TYOTAC: ILDB CHR,TAC		;PRINT NEXT CHR IN STRING POINTED TO BY TAC.
TYO:	MOVE	AC1,LSTCHR(DAT)	; PICK UP LAST CHARACTER TYPED
	CAIN	AC1,177		;IF A DELETE ON DATA DISC
	JUMPL	DAT,DELNOW	;ON DD, <DELETE><CHR> IS A SINGLE NORMAL GRAPHIC.
	JUMPE	CHR,CPOPJ	;DON'T PRINT NULLS.
	JUMPGE	AC1,TYO0	;JUMP UNLESS THE LAST THING WE DID WAS INVENT CRLF.
	CAIN	CHR,15		;A CR AFTER WE INVENTED A CRLF?
	POPJ	P,		;YES. SUPPRESS IT.
	MOVEI	AC1,12		;MAKE IT LOOK LIKE THE LAST CHARACTER WAS LF.
	MOVEM	AC1,LSTCHR(DAT)	;SET IT.
	CAIN	CHR,12		;CHARACTER IS LF?
	POPJ	P,		;YES. SUPPRESS THAT TOO.
				;NOW IT LOOKS LIKE NORMAL CHARACTER, LSTCHR SET.

TYO0:	SETOM DPYCHR(DAT)	; NOTE THAT ANOTHER CHARACTER HAS BEEN TYPED
	CAIN CHR,15		; IS IT A CR ?
	JRST PR1ECR		; YES, GO SERVICE IT
	CAIE AC1,12		; WAS LAST CHARACTER A LF?
	JRST TYO1		; NO
	JUMPG DAT,TYO1		; IF III, WE CAN SKIP ALL THIS BULLSHIT

;ON DD. FIRST CHARACTER AFTER LF.
	MOVE AC1,DPHPOS(DAT)	; WELL, ARE WE AT THE BEGINNING OF THE LINE?
	ADD AC1,LNLNGT(DAT)
	JUMPE AC1,TYO4		; YES, THERE MUST HAVE BEEN A CR FIRST.
	PUSH P,CHR		; SAVE OUR CHARACTER
	PUSH P,AC1		; SAVE THE COUNT (I.E., COLUMN NUMBER.)
	MOVEI CHR,15		; TYPE A CR FIRST
	DPB CHR,SPTR1(DAT)	; REPLACE LF WITH CR
	MOVEI CHR,12		; PUT OUR LF BACK
	SOS VPOS(DAT)
	PUSHJ P,PUTCH1
	PUSHJ P,EOLSET		; STORE THE POSITION OF OUR NEW LF
	MOVEI CHR,40		; THEN PAD OUT THE LINE
;TYPE A BUNCH OF SPACES TO SIMUALTE A BARE LINE FEED.
TYO5:	PUSHJ	P,PUTCH1	;SEND A SPACE.
	SOSLE	(P)		;DECREMENT THE SPACE COUNT.
	JRST	TYO5		;LOOP SPACING.
	SUB	P,[1,,1]	;ADJUST STCK TO REMOVE SPACE COUNT.
	POP	P,CHR		;RESTORE CHARACTER. FALL INTO TYO1

TYO1:	CAIN CHR,12		; OR A  LINE FEED ?
	JRST PR1EOL		;YES.
	JUMPGE DAT,TYO2		; IF III, JUST PUT THE CHARACTER IN THE BUFFER
	MOVE AC1,DPHPOS(DAT)	; ARE WE AT THE LEFT MARGIN?
	ADD AC1,LNLNGT(DAT)
	JUMPN AC1,TYO2		; NO
	MOVE AC1,LSTCHR(DAT)	; YES, WAS LAST CHARACTER A LF?
	CAIN AC1,12
	JRST TYO2
	PUSH P,CHR		; NO, PUT ONE IN!
	MOVEI CHR,12
	PUSHJ P,PUTCH1
	PUSHJ P,EOLSET		; STORE LINE POINTER
	SOSG DELCNT(DAT)	; TIME TO GLITCH YET?
	PUSHJ P,PREOGL		; YES, DO IT.
	POP P,CHR
TYO2:	CAIN CHR,11		; TAB?
	PUSHJ P,PR1TAB		; YES, GO EXPAND IT.
	PUSHJ P,PUTCH1		; PUT CHARACTER INTO BUFFER
TYO7:	MOVEM CHR,LSTCHR(DAT)	; SAVE LAST CHARACTER
	CAIN	CHR,177		;IS THIS A DELETE?
	JUMPL	DAT,.+3		;YES. FOR DD AVOID CHANGING THE H.POSITION.
	AOSL DPHPOS(DAT)	;UPDATE HORIZONTAL POS.
	JRST PRCR		;OVER END OF LINE..  INSERT CR LF.
	MOVE AC1,[CW 0,0,3,2,3,2]
	SKIPGE DAT		; IF WE ARE A DD
	MOVEM AC1,TPJMP+1(DAT)	; AND THE LINE DOESN'T END WITH CRLF, PUT IN AN EXECUTE
	POPJ P,
                                                                                                                                                                                                                   ; WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
TYO4:	CAIE CHR,12		; IS THIS CHARACTER A LF?
	JRST TYO2		; NO, JUST DUMP THE CHARACTER IN THE BUFFER
	PUSHJ P,PR1EC2		; YES, PUT IN A SPACE, CR, AND A LF
	MOVEI CHR,12		; PICK UP A LF
	JRST PR1EOL

;PRINT SINGLE CHAR. FROM CHR., WITH NO SPEC. CHAR. CHECKING.
PUTCH1:	SOSG CNT1(DAT)
	PUSHJ P,EXTBUF		;GO EXTEND BUFFER.
	IDPB CHR,PPTR1(DAT)
	POPJ P,

;DD. LAST CHARACTER WAS A DELETE. THIS CHARACTER WILL MAKE AN ORDINARY GRAPHIC.
DELNOW:	PUSHJ P,PUTCH1		;PUT CHARACTER IN BUFFER
	IORI CHR,200		;MAKE IT SPECIAL SO WE WON'T COMPARE EQUAL TO IT
	JRST TYO7


;WE GET HERE TO PRINT SPACES FOR A TAB
PR1TAB: PUSHJ P,PUTCH1		;HANDLE A TAB. FIRST PRINT THE TAB.
	MOVEI CHR," "		;NOW OUTPOOT RIGHT NO. OF SPACES.
	SETCM AC1,DPHPOS(DAT)	;GET CURRENT POS. ON LINE..
	SUB AC1,LNLNGT(DAT)	; MAKE TABS START IN COLLUMN 8
	ANDI AC1,7		;GET NO. OF SPACES TO NEXT MULTIPLE OF 8 BOUNDARY.
	ADDM AC1,DPHPOS(DAT)	;UPDATE HIM.
PR1TB1:	PUSH P,AC1		; SAVE OUR COUNT
	PUSHJ P,PUTCH1		;NOW EMIT A SPACE.
	POP P,AC1
	SOJGE AC1,PR1TB1	;..AND SOME MORE, IF APPROPRIATE.
	MOVEI CHR,11		;WE WILL FINISH OFF WITH ANOTHER TAB..
	POPJ P,

;STICK A CRLF IN TO BREAK UP LONG LINES
PRCR:	MOVEI CHR,15		;PRINT A CR.
	PUSHJ P,PUTCH1
	MOVEI CHR,12		;NOW INVENT A LINE FEED.
	PUSHJ P,SETLL		; RESET DPHPOS
	PUSHJ	P,PR1EOL	;GO DO THE END-OF-LINE BIT
	SETOM	LSTCHR(DAT)	;FLAG THAT WE INVENTED CRLF HERE.
				;(DPYTYP WILL WAIT FOR LINE BEFORE SENDING MORE)
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          PR1ECR:	JUMPGE DAT,PR1EC1	; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; IF SO, THE LINE WILL BE ACTIVATED, SO KILL THE EXECUTE
	MOVEI AC1,12		; WAS THE LAST CHARACTER A LF
	CAME AC1,LSTCHR(DAT)
	JRST PR1EC1
	MOVN AC3,DPHPOS(DAT)	; PICK UP THE HORIZONTAL POSITION
	CAMN AC3,LNLNGT(DAT)	; ARE WE AT THE BEGINNING OF THE LINE?
	JRST PR1EC2		; YES, NO NEED FOR ANY MORE CR'S
	SOS VPOS(DAT)
	DPB CHR,SPTR1(DAT)	; PUT THE CR IN OVER THE LF
	PUSHJ P,SETLL		; RESET DPHPOS
	MOVEI CHR,12
	PUSHJ P,PUTCH1		; STICK THE LF IN
	MOVEM CHR,LSTCHR(DAT)	; SAVE IT
	JRST EOLSET		; DO THE END-OF-LINE BIT

PR1EC1:	MOVN AC3,DPHPOS(DAT)	; NOW (SIGH) SEE IF WE ARE AT THE LEFT MARGIN!
	CAMN AC3,LNLNGT(DAT)
	POPJ P,			; IF SO, FLUSH THIS CR
	PUSHJ P,SETLL		; RESET DPHPOS
PR1EC3:	PUSHJ P,PUTCH1		; YES, DUMP ONE OF THEM
	MOVEM CHR,LSTCHR(DAT)
	POPJ P,

; WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
PR1EC2:	MOVEI CHR,40		; PRINT A SPACE SO THE LINE WILL GET ERASED
	PUSHJ P,PUTCH1
	MOVEI CHR,15
	JRST PR1EC3

; HERE ON LF
PR1EOL:	SKIPGE DAT		; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; YES, NO NEED FOR AN EXECUTE AT THE END OF THE BUFFER.
PR1EO1:	MOVEM CHR,LSTCHR(DAT)	; SAVE THIS CHARACTER
	PUSHJ P,PUTCH1		;HERE AT END OF LINE. PRINT LINE FEED.
	PUSHJ P,EOLSET		; YES, SET VERTICAL POSITION AND SAVE BYTE PTR
	SOSLE DELCNT(DAT)	;ARE WE AT THE TOP OF A GLITCH ?
	POPJ P,			;NO. GO BACK.
PREOGL:	MOVE AC3,DEL(DAT)	;GET NO. OF LINES PER GLITCH..
	MOVEM AC3,DELCNT(DAT)	;.. AND INIT. THE COUNT.
	AOS AC1,GLCNT(DAT)	;UPDATE SIZE OF PAGE.
	CAMG AC1,PGSIZ(DAT)	;IS IT TOO BIG ?
	POPJ P,			; NOT YET.
	JRST GLITCH		; YES, MOVE IT UP SOME

;INITIALIZE LENGTH OF THE LINE AT CR.
SETLL:	MOVN AC1,LNLNGT(DAT)	;GET -LINELENGTH.
	MOVEM AC1,DPHPOS(DAT)	;RESET HORIZONTAL POS.
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        BEGIN EXTBUF	;MAKE MORE ROOM IN THE DISPLAY BUFFER.

^EXTBUF: EXCH AC1,PPTR1(DAT)	;GET BYTE POINTER.
L2:	MOVN AC2,WCNT(DAT)	;HOW MANY WORDS LEFT IN THIS BLOCK ?
	JUMPE AC2,GBLK		;IF NONE, GET A NEW BLOCK.
	CAILE AC2,10		;IF FEWER THAN 8, USE THAT  NO.
	MOVEI AC2,10		;..ELSE USE 8 WORDS.
	ADDM AC2,WCNT(DAT)	;DECREMENT THE COUNT.
	MOVE AC3,AC2
	ASH AC3,2		;MULTIPLY BY 5 RAPIDLY.
	ADD AC3,AC2
	MOVEM AC3,CNT1(DAT)	;THAT'S THE NEW CHAR. COUNT, FOLKS.
	MOVE AC3,1(AC1)		;PICK UP THE JMP AT CURRENT END OF BUFFER..
	ADDI AC1,1(AC2)		;GET NEW POS. FOR IT...
	MOVEM AC3,(AC1)		;.. AND PUT IT THERE.
	MOVEI AC3,1		;MANUFACTURE A NULL CHAR. WORD...
L1:	SUBI AC1,1		;AND FILL THE NEWLY AVAILABLE AREA OF THE
	MOVEM AC3,(AC1)		;BUFFER WITH IT.
	SOJG AC2,L1
	SUBI AC1,1
	TLZ	AC1,760000		;BUG FIX REG RPH 24 JUL 72
	EXCH AC1,PPTR1(DAT)	;RESTORE THINGS TO THEIR RIGHTFUL PLACES.
	POPJ P,

GBLK:  ;;GET ANOTHER BLOCK FROM FREE STORAGE FOR PRGM.
	AOSLE BLKTOT(DDB)	;INC. HIS COUNT OF BLOCKS USED.
	PUSHJ P,FBLK		;OOPS, TOO MANY. FREE SOME.
	PUSHJ P,GETFS		;GET ANOTHER BLOCK FROM FREE STORAGE.
	HRR AC1,AC2		;MAKE THE BYTE PTR. POINT THERE.
	EXCH AC2,CBLKPT(DAT)	;UPDATE CURRENT BLK. PTR (AND GET OLD ONE).
	MOVEI AC3,CBLKBT	;GC BIT FOR `CURRENT PP BLOCK'...
	ANDCAM AC3,BLKBTS(AC2)	;..TURN IT OFF IN OLD BLOCK.
	MOVEM AC3,BLKBTS(AC1)	;.. AND PLACE IN NEW ONE.
	MOVE AC3,GCINFO(AC2)	;GIVE NEW BLK. SAME GC CODE AS
	MOVEM AC3,GCINFO(AC1)	; OLD ONE.
	MOVNI AC3,INITWC	;SET UP NO. OF FREE WORDS IN NEW BLOCK.
	MOVEM AC3,WCNT(DAT)
	MOVE AC3,INITWC(AC2)	;PICK UP RETURN JMP FROM END OF OLD BLK..
	MOVEM AC3,(AC1)		;.. AND PUT IN FIRST WORD OF NEW ONE.
	HRRM AC1,LINK(AC2)	;MAKE FORWARD LINK OF OLD ONE POINT AT NEW ONE.
	HRLM AC1,INITWC(AC2)	;MAKE JMP AT END OF OLD ONE POINT AT NEW ONE.
	HRLZM AC2,LINK(AC1)	;BACKWARD LINK OF NEW ONE TO OLD ONE...
	SOJA AC1,L2		;JIGGLE NEW BYTE PTR. A BIT AND PROCEDE.

BEND EXTBUF.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ; WE GET HERE UPON GLITCHING ON A DATA DISC DISPLAY
; IN THIS CASE, WE SEE IF THERE ARE ANY BLOCKS ABOVE THE
; CURRENT SCREEN. IF SO, WE CAN FREE THEM UP.

GLITCH:	SOS GLHCNT(DDB)		; BUMP COUNT OF GLITCHES TO GO UNTIL HOLD
	MOVN AC3,DEL(DAT)	; MOVE POINTERS DOWN BY THIS AMOUNT
	SETOM GLTCH(DAT)	; MARK THE FACT THAT WE HAVE GLITCHED
	SETOM PPINV(DAT)	; NOTE THAT POINTERS ARE BEING CHANGED
	ADDM AC3,VPOS(DAT)	; UPDATE VERTICAL POSITION BY NUMBER OF LINES IN GLITCH
	PUSHJ P,PTMOVE		; MAGIC CIRCULAR ROUTINE
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
GLTCH3:	PUSHJ P,POSLIN		; PICK UP LINE NUMBER OF TOP OF PAGE
	CAMLE AC3,VPOS(DAT)	; IS THERE ANYTHING ON THE SCREEN AT ALL?
	MOVE AC3,VPOS(DAT)	; NOT YET, USE LAST POSITION WRITTEN IN
	PUSHJ P,GLNADR		; GET ADDRESS OF TEXT
	HRRZ AC1,TBLKPT(DAT)	; PICK UP THE POINTER TO THE CURRENT FIRST PAGE
	HRRZI AC3,BLKSIZ-1(AC1)	; GET ADDRESS OF END OF THAT BLOCK
	CAIL AC2,(AC1)		; NOW, ARE WE INSIDE THAT FIRST BLOCK?
	CAILE AC2,(AC3)
	JRST GLTCH4		; NO, FREE UP SOME BLOCKS
	ADDI AC2,1		; MAKE POINTER TO TOP OF PAGE
	HRLM AC2,TPJMP(DAT)	; POINT JUMP TO THERE
PR1EL4:	SOS AC1,GLCNT(DAT)	;IS IT SMALL ENOUGH NOW ?
ADJSIZ: CAMLE AC1,PGSIZ(DAT)
	JRST GLITCH		;NO. GLITCH IT SOME MORE.
	POPJ P,

CNTWRP: MOVEI AC3,CNT		;WRAP A POINTER AROUND THE GLITCH TABLE.
	MOVEM AC3,@-2(AC2)
	JRST (AC2)

GLTCH4:	PUSHJ P,PR1FRE		; GO FREE UP AT LEAST ONE
	JRST GLTCH3		; SEE IF WE CAN DO SOME MORE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ; THESE ARE UTILITY ROUTINES USED BY THE PAGE PRINTER
; THIS FIRST ROUTINE IS CALLED AT THE END OF THE LINE THAT
; GOES OFF THE SCREEN ON DATA DISK. WE REPACK THE WORD
; SUCH THAT THE POINTER POINTS TO THE NEXT WORD. THIS WAY
; THE I-LEVEL ROUTINES CAN REPLACE THE ENTIRE WORD WITH
; A JUMP INTO THE PAGE PRINTER CONTROL BLOCK TO KEEP IT
; FROM READING MORE TEXT WHICH WOULD BE OFF THE SCREEN.

EOLSET:	MOVE AC1,PPTR1(DAT)	; PICK UP POINTER TO LF
	MOVEM AC1,SPTR1(DAT)	; SAVE IT
	SKIPGE DAT
	SETZM TPJMP+1(DAT)	; SINCE TEXT ENDS WITH A CRLF, NO EXECUTE IS NEEDED
	LDB AC1,[POINT 6,PPTR1(DAT),5]
	SUBI AC1,1		; ARE THERE ANY SPACES LEFT IN THE WORD?
	IDIVI AC1,7		; THIS GETS NUMBER OF CHARACTERS LEFT IN AC1
	JUMPE AC1,EOLSE3	; IF NONE LEFT, GO ON.
	PUSH P,AC1		; PUT IN THAT MANY NULLS
	SETZ CHR,
EOLSE2:	PUSHJ P,PUTCH1		; FILL OUT WORD WITH NULLS.
	SOSLE (P)		; ENOUGH?
	JRST EOLSE2		; NO, GO DO ANOTHER ONE.
	SUB P,[XWD 1,1]
EOLSE3:	MOVE AC3,VPOS(DAT)	; WE ARE NOW ON THE NEXT LINE. BUMP VERTICAL POSITION COUNTER.
	ADDI AC3,1		; DON'T BUMP IN CORE UNTIL WE HAVE POINTER PLANTED
	CAMLE AC3,GLW(DAT)	; IS THIS FURTHER DOWN THAN THE PRESENT MAXIMUM LINE WRITTEN?
	MOVEM AC3,GLW(DAT)	; YES, BUMP NUMBER OF MAXIMUM LINE WRITTEN
	PUSHJ P,GLNADR		; PICK UP POINTER INTO LINE TABLE
	MOVE AC2,PPTR1(DAT)	; NOW PICK UP THE POINTER
	MOVEM AC2,@PTRB(DAT)	; PUT IT INTO LINE POINTER TABLE INDEXED BY LINE NUMBER
	AOS VPOS(DAT)		; NOW UPDATE VERTICAL POSITION
	MOVEI CHR,12		; FAKE UP SOMETHING FOR ERRP (AGGG!)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                        ; HANDY ROUTINE TO GET POINTER TO TEXT FROM LINE NUMBER IN AC3
; RETURNS POINTER IN AC1.

GLNADR:	ADD AC3,PTBEG(DAT)	; ADD IN INCREMENT
GLNAD2:	CAMGE AC3,[-=20]	; UNDERFLOW?
	JRST GLNAD1		; YES, BOOST IT
GLNAD4:	CAIL AC3,=60		; OVERFLOW?
	JRST GLNAD3		; YES, BRING IT BACK INTO RANGE
	HRRZ AC2,PTRB(DAT)	; PICK UP POINTER
	SUBI AC2,=20
	CAME AC2,PTB(DAT)	; IS IT WHAT IT IS SUPPOSED TO BE?
	JRST GLNAD5		; NO, ERROR
GLNAD6:	HRRZ AC2,@PTRB(DAT)	; PICK UP POINTER
	POPJ P,

GLNAD1:	ADDI AC3,=80
	JRST GLNAD2

GLNAD3:	SUBI AC3,=80
	JRST GLNAD4
                                                                              ; WE GET HERE IF THE POINTERS DON'T AGREE

GLNAD5:	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ SOMEBODY CLOBBERED PTRB!!  - ]
	DISARG	OCT,<PTRB(DAT)>
	[ASCIZ 
]
	-1
	POPACS
	HRRZ AC2,PTB(DAT)	; PICK UP THE (HOPEFULLY) CORRECT POINTER
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST GLNAD7
	ADDI AC2,=20
	HRLI AC2,AC3		; SET TO INDEX BY AC3
	MOVEM AC2,PTRB(DAT)
	JRST GLNAD6

GLNAD7:	HRRZ AC2,PTRB(DAT)
	SUBI AC2,=20
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST HELPX
	HRRZM AC2,PTB(DAT)
	JRST GLNAD6

HELPX:	PUSHJ P,DISERR
	[ASCIZ HELP! - CAN'T FIX IT
]
	-1
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD
                ; ROUTINE TO CONVERT THE POSITION VECTOR INTO A DATA DISK
; LINE NUMBER. GOES FROM 1 TO 40.

POSLIN:	LDB AC3,[POINT 11,PPOSV(DAT),21]
	TRNE AC3,1=10		; EXTEND SIGN BIT
	OR AC3,[-1=10]		; BY ORING IN BITS
	SKIPN PPDD(DAT)		; IS THIS A DATA DISC DISPLAY?
	JRST POSLI1		; NO, USE SEPARATE ROUTINE
POSLI2:	IMULI AC3,=20
	ASH AC3,-=9		; THIS GIVES A NUMBER FROM -=19 TO =20
	MOVNS AC3		; FOR DD, ASCENDING LINE NUMBERS GO DOWN THE SCREEN
	ADDI AC3,=20		; WE NOW HAVE A NUMBER FROM 1 TO =40 IN AC3
	POPJ P,

POSLI1:	IMULI AC3,=12		; III ONLY HAS 24 LINES ON THE SCREEN
	ASH AC3,-=9
	MOVNS AC3
	ADDI AC3,=12
	POPJ P,
        FBLK:	PUSH P,AC1		;FREE SOME BLOCKS FROM P.P.
FB1:	MOVE AC1,GLCNT(DAT)
	SKIPLE BLKTOT(DDB)	;DID WE FREE ENOUGH BLOCKS ?
	CAIG AC1,1		;LESS THAN 1 GLITCH ON SCREEN ?
	JRST POPAJ		;YES. RESTORE AC1 AND RETURN.
	PUSHJ P,GLITCH		;MOVE PAPER ONE GLITCH.
	JRST FB1

PR1FRE: MOVE AC2,TBLKPT(DAT)	;WE HAVE FINISHED WITH ANOTHER BLOCK. GET PTR. TO IT.
	MOVEI AC1,TBLKBT	;CODE BIT FOR GC MEANING `TOP BLK OF PAGE'
	ANDCAM AC1,BLKBTS(AC2)	;TURN IT OFF IN OLD TOP BLK.
	HRRZ AC2,LINK(AC2)	;GET FORWARD PTR. (TO NEW TOP BLK.)
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST PR1ERR		; GROSS ERROR!
PR1ER2:	MOVEM AC2,TBLKPT(DAT)
	IORM AC1,BLKBTS(AC2)
	SOSG OUTCNT(DAT)	;HAVE WE ENOUGH UNUSED BLOCKS FOR A DISK OUTPUT ?
	PUSHJ P,PPOUT		;YES. GET RID OF THEM.
	POPJ P,

PR1ER3:	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/FIND A WIZARD OR RELOAD
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCALL
	POPACS
	HALT	AUTOLOAD

PR1ERR:	HRRZ	AC3,PRGNUM(DDB)
	PUSHACS
	PUSH	P,AC3
	PUSH	P,AC2
	PUSHJ	P,DISMES
	ASCIZ	/BAD POINTER AT PR1FRE: /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/,  TTY = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	MOVEI	AC1,=20*=40/INITWC
	MOVE	AC3,CBLKPT(DAT)
PR1ER1:	MOVEI	AC2,(AC3)
	HLRZ	AC3,LINK(AC3)
	CAML	AC3,MEMSIZ
	CAML	AC3,RMEMSIZ
	JRST	PR1ER3
	CAME	AC3,TBLKPT(DAT)
	SOJG	AC1,PR1ER1
	JUMPLE	AC1,PR1ER3
	MOVE	AC3,TBLKPT(DAT)
	HRLM	AC2,LINK(AC3)
	MOVEI	AC1,TBLKBT
	JRST	PR1ER2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                PPOUT:  ;WE GET HERE WHEN IT IS TIME TO OUTPUT PART OF A PIECE OF PAPER TO THE DISK.
	MOVEI AC3,OUTNUM	;NO. OF BLOCKS TO PUT OUT.
	MOVEM AC3,OUTCNT(DAT)	;RESET IT.
	MOVE AC1,FBLKPT(DAT)	;POINTER TO  FIRST BLK IN CORE.
	SKIPA AC2,AC1
	HRRZ AC2,LINK(AC2)	;GO TO NEXT BLOCK.
	SOJG AC3,.-1		;GO TO LAST BLOCK TO BE OUTPUT.
;;SINCE CROCKISH R. SAUNDERS HAS NO DISK CODE YET, WE JUST RETURN THE BLOCKS TO FREE STORAGE.
	HRRZ AC3,LINK(AC2)	;NEXT BLK.
	HRRZM AC3,FBLKPT(DAT)	;MAKE FBLKPT POINT TO NEW FIRST BLOCK IN CORE.
	HRLM DAT,LINK(AC3)	;MAINTAIN REV LINK
	SETZM LINK(AC2)		;ZERO LINK IN LAST BLOCK TO BE FREED.
^SETRST:PUSHJ P,FREEL		;FREE THE BLOCKS.
^^WHORST:
	SKIPN III(DDB)		;IS IT AN III?
	POPJ P,			;NO.
PPRST:	HRRZ AC3,PRGNUM(DDB)	;GET PROGRAM NUMBER
	MOVEI AC2,PSELB(DDB)	;YES. INVENT A RESTARTING JMP FOR IT AND
	HRLI AC2,DISJMP		; PLACE IN RSTTBL SO PRGM WILL GET STARTED AT
	MOVSM AC2,RSTTBL(AC3)	;AT ITS BEGINNING NEXT TIME.
	POPJ P,
                                                                                                                                                                                                                                                                                                                          ;A SIMPLE MESSAGE PRINTER. JSA ITEM,ERRP WITH
;BYTE PTR. TO TEXT FOLOWING THE JSA .

^ERRP2:	HLRZ DAT,PPCALL(DDB)	;GET P OF P 0.
	HLL DAT,DDB		; COPY OVER THE DD FLAG IF ANY
	PUSHACS			; SAVE ALL OUR ARGUEMENTS
	MOVE J,JOB(PID)
	PUSHJ P,PPCLR		; RESET THE PAGE PRINTER
	MOVE J,-17+J(P)
	MOVE TAC,(ITEM)		;GET BYTE POINTER TO MESSAGE.
ERRP3:	CONO PI,SCNOFF		;TURN OFF RPH
	PUSHJ P,TYOTAC		;TYPE A CHAR.
	CONO PI,SCNON		;TURN ON RPH
	JUMPN CHR,ERRP3		;LOOP UNTIL FIRST NULL CHAR.
	POPACS
	JRA ITEM,1(ITEM)
                                                                                                                       ;;HERE ARE UUO LEVEL ROUTINES FOR MANIPULATING THE PAGE PRINTER.

;;THESE ROUTINES ARE ENTERED WITH STANDARD UUO LEVEL
;; SETUP OF AC'S UUO AND ITEM, WITH
;; DDB (DEVDAT) POINTING TO DPY PROGRAM HEADER.


;;PPFIND FINDS PIECE OF PAPER INDICATED BY (UUO); CREATES IT IF NECESSARY.
;; RETURNS WITH DAT POINTING TO P. OF P. CONTROL BLOCK.

PPFND1: HLL DAT,DDB		; PICK UP DD FLAG BIT
	HLRZ AC2,PPCALL(DDB)	;GET PTR. TO FIRST P. OF P.
	HRRZ TAC,UUO		;NO. OF PIECE WE ARE LOOKING FOR.
	CAIL TAC,20		;BETTER NOT BE TOO HIGH.
	JRST PPFER		;LOSE, LOSE.
PFL2:	HRRM AC2,DAT		;LOOK AT NEXT P. OF PAPER.
	CAMN TAC,PPNO(DAT)	;IS IT THE ONE WE WANT ?
	POPJ P,			;YES.
	HRRZ AC2,LINK(DAT)	;GET LINK TO NEXT ONE.
	JUMPN AC2,PFL2		;LOOP IF THERE IS A NEXT ONE.
	POPJ P,

PPFND:	PUSHJ P,PPFND1		;FIND INDICATED P OF P.
	JUMPN AC2,CPOPJ		;RETURN IF IT EXISTS.
	PUSH P,DAT		; SAVE POINTER TO LAST PROGRAM HEADER
	PUSH P,TAC		; SAVE NUMBER OF DESIRED PIECE OF PAPER
	HLRE TAC,PRGNUM(DDB)	; PICK UP DPY NUMBER FOR PPINIT
	PUSHJ P,PPINIT		;IT DOESN'T. MAKE A NEW PIECE APPEAR.
	JSP UUO,DWPERR		; NOT THERE, GHASTLY ERROR
	POP P,PPNO(AC1)		;MAKE IT HAVE RIGHT NO.
	POP P,DAT		; GET BACK POINTER TO LAST PIECE OF PAPER
	HRRM AC1,LINK(DAT)	;LINK IT TO OTHER PIECES.
	HRLZM DAT,LINK(AC1)	;PUT IN ITS BACKWARD LINK.
	HRRZM DDB,HEDPTR(AC1)	;GIVE IT PTR. TO PRGM. HEAD.
	MOVE AC3,PPRJMP(DAT)	;GET LINKING (I. E. RETURN) JMP FROM LAST P OF P...
	MOVEM AC3,PPRJMP(AC1)	;GIVE IT TO NEW PIECE...
	HRLM AC1,PPRJMP(DAT)	;.. AND MAKE LAST PIECE CALL NEW ONE.
	MOVEM AC1,DAT
	HLL DAT,DDB		; PUT IN TYPE BITS
	POPJ P,

PPFER:	;PRINT H. S. MESSAGE.
	ERMS {ILLEGAL PIECE OF PAPER~
	JRST UUOERR		;NOW GIVE STANDARD JUNK AND STOP JOB.
                                                                                                                                                                                       ;;MORE PP ROUTINES.


PPSEL1: PUSHJ P,PPFND		;LOCATE P. OF P. INDICATED BY UUO.
	HRRZM DAT,CURPP(DDB)	;MAKE IT THE CURRENT ONE.
	MOVEI UUO,400000	;PREPARE TO ACTIVATE IT,
	MOVN TAC,PPNO(DAT)	; BY GENERATING PARAM. FOR
	LSH UUO,(TAC)		;CALL ON PPACT.
	POPJ P,

PPREL:	TRNN UUO,-1		;FLUSH PP WHOSE NUMBER IS IN UUO (RIGHT)
	POPJ P,			;BUT NOT IF IT'S PP ZERO
	PUSHJ P,PPFND1		;FIND P OF P
	JUMPE AC2,CPOPJ		;SAVE SOME TIME IF THERE IS NONE
	PUSH P,DDB
	PUSHJ P,PPWAIT		; WAIT FOR ANY TYPEOUT TO FINISH BEFORE FLUSHING PAGE
	POP P,DDB
	PUSHJ P,PPFND1		;NOW SEE IF P OF P IS STILL THERE
	JUMPE AC2,CPOPJ		;RETURN IF NOT.
	MOVE AC1,LINK(DAT)	;SIGH.  GET FWD AND BWD LINKS FROM CTRL. BLK.
	TRNE AC1,-1		;UNLESS CTRL. BLK IS LAST ONE,
	HLLM AC1,LINK(AC1)	;..UPDATE BWD LINK OF NEXT ONE.
	MOVSS AC1
	HLRM AC1,LINK(AC1)	;NOW FWD LINK OF PREVIOUS ONE (AREN'T LINKED LISTS FUN ?)
	MOVE AC3,PPRJMP(DAT)	;TAKE LINKING JMP FROM THIS BLK...
	MOVEM AC3,PPRJMP(AC1)	;..AND GIVE IT TO PREVIOUS ONE.
	JUMPG DAT,PPREL3	; DON'T ERASE IF III, WILL BE DONE AUTOMATICALLY
	PUSHJ P,POSLIN		; GET FIRST LINE NUMBER OF PAGE
	PUSH P,AC3
	PUSH P,GLW(DAT)		; ERASE ALL THE WAY TO THE LAST LINE
	SOS (P)
	PUSHJ P,PPERS
	SUB P,[XWD 2,2]		; NORMALIZE THE STACK
PPREL3:	MOVEM	DDB,LINK(DAT)	;SINCE WE ARE LINKED OUT, WE CAN USE THIS TO
				;SAVE DDB IN CASE OF A CLOCK CALL LATER
PPREL4:	MOVE	DDB,LINK(DAT)	;MAKE SURE DDB IS SET UP
	SKIPN	PPENQ(DAT)	;ANYTHING HAPPENING HERE?
	SKIPE	PPNQT(DAT)
	JRST	CLKREL		;YES, DON'T RELEASE IT UNTIL IT IS DONE
	MOVE	AC1,DAT		;NOW FREE THE CTRL BLK.
	PUSHJ	P,CGIVFS
	MOVE	AC1,FBLKPT(DAT)	;ALSO FREE THE PROGRAM BLOCKS.
	PUSHJ	P,FREEL
	HRRZ	AC1,PTB(DAT)	;GIVE BACK TABLE OF END OF LINE POINTERS
	PUSHJ	P,FSGIVE
PPREL2:	HRRZ AC1,DAT
	CAME AC1,CURPP(DDB)	;HAVE WE JUST DELETED SELECTED P OF P ?
				;USED TO BE CAMN DCS/RPH
	POPJ P,
	MOVEI UUO,0		;YES. SELECT PP 0.
	JRST PPSELN

CLKREL:	HRLI	DAT,PPREL4
	JRST	DPYTIM
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;;PPSEL <N>  MAKES P. OF P. <N> THE CURRENT ONE AND TURNS IT ON.

PPSEL:	PUSHJ P,PPWAIT		; WAIT FOR TYPEOUT TO FINISH
	PUSHJ P,PRGFND
	POPJ P,			; NO DPY HERE, JUST IGNORE
PPSELN:	PUSHJ P,PPSEL1		;FIND IT, SELECT IT AND FALL INTO PPACT.

;;PPACT X TURNS P OF P'S ON AND OFF ACCORDING TO BITS IN X;
;;  BIT N+18 CORRESPONDS TO P. OF P. N.

PPACT:	MOVEI AC1,DISJMP	;JMP OPCODE FOR DPY.
	MOVEI AC2,DISNOP
	HLRZ AC3,PPCALL(DDB)	;GET FIRST P OF P.
PACTL1:	MOVE TAC,UUO		;MAKE COPY OF THE X BITS.
	ROT TAC,@PPNO(AC3)	;GET BIT FOR THIS P OF P INTO 18.
	HRRM AC2,TPJMP(AC3)	;ASSUME BIT IS OFF.
	TRNE TAC,400000		;IS IT ?
	HRRM AC1,TPJMP(AC3)	;NO. ACTIVATE THE P OF P.
	MOVE TAC1,PRGACT(DDB)	; PICK UP CURRENT ACTIVATION BITS
	ROT TAC1,@PPNO(AC3)	; PUT BIT FOR THIS DISPLAY IN B18
	XOR TAC1,TAC		; ARE THEY DIFFERENT?
	TRNE TAC1,400000
	JRST PACTL2		; YES, MARK IT AS VIRGIN IF APPEARING, ERASE IF DISSAPEARING
PACTL3:	HRRZ AC3,LINK(AC3)	;GET NEXT P OF P HEADER.
	JUMPN AC3,PACTL1	;LOOP IF THERE IS ONE.
	HRRM UUO,PRGACT(DDB)	;ALL DONE. RECORD NEW STATE OF ACTIVATION.
	POPJ P,

PACTL2:	TRNN TAC,400000		; NOW, ARE WE APPEARING OR DISSAPEARING?
	JRST PACTL4		; DISSAPEARING, GO ERASE SCREEN
	SETOM PPVIRG(AC3)	; APPEARING, NOTE A VIRGIN SCREEN
	JRST PACTL3

PACTL4:	SKIPE PPVIRG(AC3)	; IS THERE ANYTHING THERE?
	JRST PACTL3		; NO, NOTHING TO ERASE
	PUSH P,DAT		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE DAT,AC3		; MAKE US THE ONE
	PUSHJ P,POSLIN		; GET BOUNDS OF PAGE IN LINE NUMBERS
	PUSH P,AC3		; THAT IS FIRST LINE
	PUSH P,GLW(DAT)		; CURRENT LINE IS LAST LINE
	SOS (P)
	PUSHJ P,PPERS		; CAUSE ERASURE TO HAPPEN
	SUB P,[XWD 2,2]
	MOVE AC3,DAT		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS BACK
	POP P,DAT
	MOVEI AC1,DISJMP
	MOVEI AC2,DISNOP
	JRST PACTL3
                                                                                                                         ; ROUTINE TO WAIT FOR TYPEOUT TO FINISH

PPWAIT:	CONSZ PI,77400		; CAN'T DO THIS AT INTERRUPT LEVEL
	POPJ P,
	MOVE ITEM,JOB
	MOVE DDB,JBTLIN(ITEM)	;FIND GUY'S TTY.
	CAME DDB,[-1]		; IS HE DETATCHED?
	SKIPN DDB,TTYTAB(DDB)	; GET TTY DDB, DOES HE EXIST?
	POPJ P,			; HMM. WELL, BE THAT WAY!
	MOVE TAC,DEVIOS(DDB)
	TLNN TAC,TOIP
	POPJ P,
	PUSHJ P,DDTWAT		; WAIT FOR THE TYPEOUT TO TERMINATE
	MOVE ITEM,JOB(PID)
	POPJ P,
                                                                                                                                                                                                               ;;PPYPOS Y MAKES THE CURRENT P OF P START AT Y COORD. Y.

PPYPOS: SETZ AC1,
	DPB AC1,POSSBU		; NOTE Y-POSITION SE BY UUO
	PUSHJ P,POSLIN		; GET LINE NUMBER OF CURRENT LINE
	PUSH P,AC3		; AND PUSH IT
	PUSH P,GLW(DAT)		; SAVE BOTTOM OF PAGE
PPYPO1:	SETOM PPINV(DAT)	; NOTE POINTERS ARE BEING CHANGED
	DPB UUO,[POINT 11,PPOSV(DAT),21]	;PUT NEW Y COORD. INTO POSITION VECTOR
	PUSHJ P,POSLIN		; NOW PICK UP POSITION COLUMN
	MOVE AC1,AC3
	MOVE AC2,AC3
	MOVN AC3,-1(P)
	ADD AC3,AC1		; UPDATE VERTICLE POSITION
	JUMPE AC3,PPYPO3	; IF NO DIFFERENCE, WE DON'T HAVE TO MOVE LINE POINTER TABLE
	MOVEM AC2,LLW(DAT)	; MAKE SURE WE START AT THE LOGICAL TOP OF PAGE
	PUSHJ P,PTMOVE		; MOVE POINTERS
	ADDM AC3,VPOS(DAT)
	SETZM PPINV(DAT)	; NOTE POINTERS ARE VALID NOW
	JUMPGE DAT,PPYPO3	; IF III, LEAVE NOW
	JUMPN AC3,PPYPO2	; IF WE ARE MOVING DOWN, WE HAVE TO ERASE EXPLICITLY
PPYPO4:	SUB P,[XWD 2,2]		; OTHERWISE, WE CAN PRETEND WE ARE GLITCHING AND
REFPAG:	JUMPGE DAT,CPOPJ	; LEAVE IF III
	PUSH P,DAT		; SAVE THE POINTER TO THE PAGE PRINTER CONTROL BLOCK
	HRRZ DAT,HEDPTR(DAT)	; PUT DPY PROGRAM HEADER ADDRESS IN DAT
	PUSHJ P,LERFP		; GET IT DONE AUTOMATICALLY.
	POP P,DAT		; GET BACK OUR PAGE PRINTER CONTROL BLOCK ADD
	POPJ P,

PPYPO3:	SUB P,[XWD 2,2]		; RESTORE THE STACK
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ; WE GET HERE WHEN THE APPEARANCE OF THE PAGE HAS CHANGED ENOUGH
; SO THAT THE PAGE HAS TO BE REFRESHED.

PPYPO2:	ADDM AC3,GLW(DAT)	; UPDATE THE NUMBER OF THE LAST LINE WRITTEN
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	SKIPN PPVIRG(DAT)	; DON'T ERASE A VIRGIN SCREEN!
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	JRST PPYPO4		; NO, DON'T WRITE ON IT
	MOVE AC2,(P)		; PICK UP FINISHING LINE OF TRANSFER
	SUB AC2,-1(P)		; GET LENGTH OF PAGE
	MOVM AC1,AC3		; GET MAGNITUDE OF TRAVEL
	CAML AC1,AC2
	JRST PPYPO5		; IF TRAVEL LARGER THAN PAGE, ERASE ENTIRE PAGE
	SUB AC2,AC1		; OTHERWISE, ERASE ONLY NON-OVERLAPPED PART
	MOVN AC1,AC2
	SKIPG AC3		; IF GOING UP,
	JRST PPYPDN		; THEN ERASE FROM THE MIDDLE DOWN TO THE BOTTOM
	ADDM AC1,(P)
	SOS (P)
PPYPO5:	PUSHJ P,PPERS
	JRST PPYPO4

PPYPDN:	ADDM AC2,-1(P)
	JRST PPYPO5
                                                                                                                                                                                                                                                                                                                                                                                                                                                           ; ROUTINE TO ERASE PARTS OF DATA DISK SCREEN
; CALL WITH STARTING LINE OF ERASURE AT -2(P)
; ENDING LINE AT -1(P)

PPERS:	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	POP P,TAC		; GET BACK THE ADDRESS OF THE FIRST ONE
	MOVE AC2,-2(P)		; PICK UP STARTING LINE OF TRANSFER
	MOVE AC3,-1(P)		; AND ENDING LINE OF TRANSFER
	CAMGE AC3,AC2		; IF THE FINISHING LINE IS ABOVE THE STARTING LINE . . .
	MOVE AC3,AC2		; THEN ONLY ERASE ONE LINE
	HRLM AC2,QLINE(AC1)	; MAKE THIS THE STARTING LINE NUMBER OF THE ERASURE
	HRLM AC2,QLINE(TAC)
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(TAC)
	HRLM DAT,(AC1)		; PUT IN PAGE PRINTER CONTROL BLOCK ADDRESS
	HRLM DAT,(TAC)
	MOVEI AC2,ERASE		; CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(TAC)
	SETZM QFIELD(TAC)	; MAKE THE FIRST TASK GO OUT ON THE FIRST FIELD
	SETOM QFIELD(AC1)	; AND THE SECOND TASK GO OUT ON THE SECOND FIELD
	SETZM QCOUNT(TAC)	; NOTE THAT WE DON'T CARE TO BE AWAKENED
	SETZM QCOUNT(AC1)
	PUSH P,TAC		; SAVE THE ADDRESS OF ONE OF THE BLOCKS
	PUSHJ P,QBLOCK		; QUEUE THE BLOCK
	POP P,AC1		; GET BACK THE ADDRESS OF THE OTHER
	JRST QBLOCK		; QUEUE IT UP TOO
                                                                                                ; HERE IS A ROUTINE TO MOVE THE LINE POINTER TABLE AROUND
; IN A CIRCULAR FASHION, SO AS NOT TO LOSE ANY POINTERS.
; CALL WITH NUMBER OF LINES TO BE MOVED IN AC3. NEGATIVE
; MEANS SCREEN IS MOVING UP, POSITIVE MEANS IT IS MOVING DOWN.
; NUMBER IS ASSUMED TO BE -=79 TO =79

PTMOVE:	PUSH P,AC3		; SAVE COUNT
	MOVNS AC3
	ADD AC3,PTBEG(DAT)	; ADD IN TO CURRENT INCREMENT
PTMOV2:	CAIL AC3,=80		; IS THE INCREMENT OUT OF RANGE?
	JRST PTMOV1		; YES, BRING IT BACK IN
PTMOV4:	SKIPGE AC3		; SAME FOR NEGATIVE
	JRST PTMOV3
	MOVEM AC3,PTBEG(DAT)
	POP P,AC3
	POPJ P,

PTMOV1:	SUBI AC3,=80
	JRST PTMOV2

PTMOV3:	ADDI AC3,=80
	JRST PTMOV4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;;PPXSIZ <N>B26 ! <M>  SETS CURRENT P OF P TO HAVE N GLITCHES OF M LINES.

PPXSIZ: 
	SETZ AC1,
	DPB AC1,SIZSBU		; NOTE THAT PAGE SIZE SET BY UUO
	MOVE AC1,GLCNT(DAT)	; PICK UP NUMBER OF GLITCHES SO FAR ON THIS PAGE
	IMUL AC1,DEL(DAT)	; MULTIPLY BY NUMBER OF LINES IN PER GLITCH
	SUB AC1,DELCNT(DAT)	; ADD IN NUMBER OF LINES SO FAR IN LAST GLITCH
	PUSH P,AC1		; AND SAVE THIS
	LDB AC1,[POINT 9,UUO,26]	;NO. OF GLITCHES REQUESTED.
	LDB AC2,[POINT 9,UUO,35]	;NO. OF LINES/GLITCH.
	IMUL AC2,AC1		;TOTAL SIZE OF REQUESTED PAGE, IN LINES.
	CAIG AC2,1		; MUST END UP 2 OR MORE LINES LONG
	JRST PPX1
	MOVEI AC3,=40		; DATA DISK TAKES 40 LINES
	CAIG AC2,(AC3)		;MORE THAN 25 LINES ?
	CAILE AC1,CNT		;TOO MANY GLITCHES ?
	JRST PPXERR		;YES. LOSE.
PPX2:	MOVEM AC1,PGSIZ(DAT)	;UPDATE GLITCHES/PAGE.
	DPB UUO,[POINT 9,DEL(DAT),35]	;UPDATE GLITCH SIZE.
	POP P,AC1		; GET NUMBER OF LINES ON PAGE
	IDIV AC1,DEL(DAT)	; SEE HOW MANY NEW GLITCHES THAT MAKES
	MOVEM AC1,GLCNT(DAT)	; THIS IS OUR NEW GLITCH COUNT
	AOS GLCNT(DAT)		; MAKE IT GO FROM 1 TO PGSIZ
	SUB AC2,DEL(DAT)	; MAKE INTO NUMBER OF LINES TO GO
	MOVNM AC2,DELCNT(DAT)	; SET NUMBER OF LINES TO GO IN CURRENT GLITCH
	MOVE AC1,GLCNT(DAT)	; PICK UP NUMBER OF GLITCHES ON THIS PAGE
	PUSHJ P,ADJSIZ		;.. AND GO ADJUST TO NEW SIZE.
	JRST REFPAG		; REFRESH NEW PAGE

PPXERR:	CONSZ PI,77400
	JRST POPAJ
	ERMS {ILLEGAL PAGE SIZE SPEC.~
	JRST UUOERR

PPX1:	MOVEI UUO,2		; GIVE HIM A MINIMUM SIZE PAGE
	MOVEI AC1,1
	JRST PPX2
                                                                                                                                                                                                                                                                                                                                                                                                                                      ;;CLKSER	;THIS IS DPYSER'S OWN PRIVATE CLOCK QUEUER.

^DPYCLK:  ;HERE FROM CLKSER EVERY TICK.
	HGMAC(35)
	SKIPE AC1,FSWTHD	;ANYTHING IN THE FREE STG. WAIT LIST ?
	PUSHJ P,FREE		;YES. GO PUT IT ON FREE STG. LIST.
	CONO PI,PIOFF		;...PEOPLE MAY USE FSWT2H AT INT. LEVEL...
	MOVE AC1,FSWT2H		;MOVE THINGS UP FROM THE SECOND-LEVEL WAIT LIST.
	MOVEM AC1,FSWTHD
	SETZM FSWT2H
	CONO PI,PION
	MOVE AC1,FSW2C
	MOVEM AC1,FSWC
	SETZM FSW2C
	HGMAC(36)
	SKIPLE WHOPTR		; IF NEW WHO JUST UPDATED, SEND IT OUT NOW
	PUSHJ P,WHOQUE		; YES, QUEUE UP A REQUEST
	HGMAC(37)
	EXCH P,DPYPDL		;YES. GET OUR OWN PDL.
	SETOM CLKLVL		;FLAG THAT WE ARE AT CLOCK LEVEL.
	AOSN WTFLG		;ARE WE IN A WAIT ?
	POPJ P,			;YES. RETURN TO THE WAITING ROUTINE.
	SKIPN @CLKQ		;ANY REQUESTS IN THE CLK QUEUE ?
	JRST CLKRTN		;NO. SEE HOW LITTLE TIME WE HAVE WASTED !!
	HRRZ TAC,CLKQ		;GET PTR. TO CURRENT END OF QUEUE.
	MOVEM TAC,CLKQTMP	;SAVE IT.
CLKL1:	CONO PI,PIOFF		;NO INTERRUPTS, PLEASE.
	MOVE DAT,@CLKQ		;GET LAST REQUEST FROM QUEUE.
	SOS CLKQ		;MOVE POINTER BACK BY 1.
	EXCH DAT,(TAC)		;PICK UP THE REQUEST WE ARE SERVICING..
	CONO PI,PION		;(DIDN'T SEE A THING, DID YOU ?)
	HLRZ TAC,DAT
	PUSHJ P,(TAC)		;..AND SERVICE IT, ALREADY.
	HGMAC(37)		;IN CASE SERVICE ROUTINE CHANGED HGCODE
	SOS TAC,CLKQTMP		;NOW GET PTR. TO NEXT LOWER ONE..
	CAIL TAC,CLKQUE		;ARE WE AT BOTTOM OF QUEUE ?
	JRST CLKL1		;NO. BACK FOR MORE.
CLKRTN: EXCH P,DPYPDL		;PUT BACK THE RIGHT PDL.
	SETZM CLKLVL		;NO LONGER IN CLOCK LEVEL CODE.
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                         ; THIS ROUTINE QUEUES UP ANOTHER WHO LINE REQUEST.
; ONLY ONE LINE IS QUEUED UP EVERY 12. TIX OR SO.
; CALLED FROM DPYCLK WHEN WHOPTR>0

WHOQUE:	MOVNI	AC3,2
	EXCH	AC3,WHOPTR	;PICK UP NUMBER OF WHO LINE JUST UPDATED
				;SET WHOPTR TO -2 TO AVOID RE-ENTERING HERE.
				;WHOWRT WILL AOS WHOPTR FOR EACH FIELD DONE.
				;WHOPTR=0 ALLOWS WHOSER TO MAKE A NEW WHO LINE
	MOVEI DAT,0
	CAIN	AC3,DDAVLU	; AVLCHN FLAG
	JRST	WHOQ2
	SKIPE	DAT,FRETAB(AC3)	; PICK UP ADDRESS OF WHO DATA
	SKIPN	AC2,LETAB(AC3)	; PICK UP ADDRESS OF DPY PROGRAM HEADER
	JRST	WHOQ1		; LEAVE IF NONE THERE
	MOVE	AC2,CURPP(AC2)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE	AC2,DDCW(AC2)	; PICK UP COMMAND WORD
	SKIPN	DAT,FRETAB(AC3)	; PICK UP ADDRESS OF WHO LINE
	JRST	WHOQ1		; LEAVE IF NONE THERE
	MOVEM	AC2,(DAT)	; PLACE IT IN THE WHO CODE
WHOQ2:	PUSHJ	P,GETQ
	MOVEM	AC3,QHPOS(AC1)	; SAVE THE DPY NUMBER HERE
	HRLI	DAT,WHOWRT
	MOVSM	DAT,(AC1)
	SETZM	QFIELD(AC1)	;ON FIELD ZERO
	MOVE	AC2,[XWD 1,2]	;ON TOP TWO LINES
	CAIN	AC3,DDAVLU
	MOVE	AC2,AVLLN
	MOVEM	AC2,QLINE(AC1)
	SETZM	QCOUNT(AC1)
	PUSH	P,AC3		;SAVE THE DPY NUMBER
	PUSHJ	P,QBLOCK	;QUEUE UP THIS FIELD'S WORTH.
	PUSHJ	P,GETQ
	POP	P,QHPOS(AC1)	;STORE THE DPY NUMBER
	MOVSM	DAT,(AC1)
	SETOM	QFIELD(AC1)	;FIELD 1
	MOVE	AC2,[XWD 1,2]
	CAIN	AC3,DDAVLU
	MOVE	AC2,AVLLN
	MOVEM	AC2,QLINE(AC1)
	SETZM	QCOUNT(AC1)
	JRST	QBLOCK

WHOQ1:	SETZM	WHOPTR		;HERE TO FLUSH THE WHO LINE REQUEST
	POPJ	P,		;WHOPTR MUST BE CLEARED.
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ; ROUTINE TO FREE AN ENTIRE LIST OF BLOCKS, LINKED UP THROUGH LINK
; ENTER WITH TOP OF LIST IN TAC

FREE:	JUMPE AC1,CPOPJ
	CAML AC1,MEMSIZ
	CAML AC1,RMEMSIZ
	POPJ P,
	HRRZ TAC,LINK(AC1)	;GET LINK BEFORE GIVING BACK FREE STORAGE
	PUSHJ P,SFSGIV
	DPYFS
	MOVE AC1,TAC		;LOOP FOR NEXT BLOCK
	JRST FREE

GETFS:	PUSH P,AC1
	PUSHJ P,UGETFS		;GET A BLOCK OF FREE STG. (IN AC2).
	MOVE AC2,AC1
POPAJ:	POP P,AC1
	POPJ P,

CLKWAT:	CONSZ PI,77000
	JRST ARRRGH
	MOVEM 17,SVAC+17
	MOVEI 17,SVAC		;SAVE ALL AC'S.
	BLT 17,SVAC+16
	SETOM WTFLG		;SET WAIT FLAG FOR CLK SERVICE.
	PUSHJ P,CLKRTN		;GO AWAY FOR A TICK.
	MOVSI 17,SVAC		;RESTORE THEM.
	BLT 17,17
	POPJ P,

ARRRGH:	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /AT CLKWAT IN CH5!!!!!
/
	PUSHJ P,DISFLU
	SKIPN DEBMOD
	JRST AUTOLO
	POPACS
	PUSHJ P,DDTCAL
	JRST .-1	;BETTER NOT RETURN WITH POPJ
                                                                                                                                                                                                                                                                                                                                                                                                                   ;;UUO LEVEL UTILITY ROUTINES AND DISPATCHERS.

;;PRGFND  FINDS DPY PRGM FOR JOB IN ITEM.

PRGF2:	MOVE DDB,PTYJOB-PTYL0(DDB)	;GET JOB WHICH OWNS PTY.
	SKIPA DDB,JBTLIN(DDB)		;USE HIS DPY, IF ANY.
PRGF1:	MOVE DDB,JBTLIN(ITEM)		;GET `TTY' LINE NO. FOR JOB., IF ANY.
	TLNE DDB,PTYLIN			;IS GUY CONNECTED TO A PTY ?
	JUMPG DDB,PRGF2			;YES, UNLESS HE IS DETACHED.
	HRRZ AC1,DDB
	AOJE DDB,CPOPJ1			;IF DETACHED (=-1) OR NOT A DPY (BIT 0 OFF), GIVE ERROR RETURN.
	TLNN DDB,DISLIN!DDDLIN		; IS THIS A DPY OF SOME SORT?
	JRST CPOPJ1			; NO, ERROR
	HRRZ DDB,LETAB-DPYL0-1(DDB)	;GET PTR. TO PRGM HEADER.
PRGF3:	HRRZ AC1,PRGNUM(DDB)		; PICK UP DPY NUMBER
	CAIL AC1,DPYNUM			; IS IT A DATA DISK DISPLAY?
	TLO DDB,400000			; YES, MARK IT WITH THE SIGN BIT
	POPJ P,

PRGFND:	SKIPN DDB,DPYMAP(ITEM)	;IS GUY CONNECTED TO SOMEONE ELSE'S DPY ?
	PUSHJ P,PRGF1		;NO. FIND ONE OF HIS OWN.
	JRST CPOPJ1		;SUCCESS RETURN
PRGFER:	CONSO PI,77400		; WHAT LEVEL ARE WE?
	POPJ P,			; IF AT UUO LEVEL, ERROR RETURN
	CONSZ PI,400		; IS IT CH7?
	SKIPN SPWUUF(PID)	; YES, ARE WE IN SPW MODE?
	JRST PRGFE1		; NO TO EITHER, GIVE ERROR MESSAGE
	POPJ P,			; YES, SAME AS UUO LEVEL

PRGFE1:	PUSHJ P,DISERR		; OTHERWISE, ORDER-1 DISASTER
	[ASCIZ ILLEGAL JOB NUMBER AT PRGFND NOT AT UUO LEVEL
]
	-1
	JRST DPYATL

DDFND:	PUSHJ P,PRGFND		; USE PRGFND
	CAIA
	JRST CPOPJ1
	CAIE UCHN,3		; DDFND CALLED ONLY FROM PGIOT WITH UCHN SETUP
	POPJ P,			; ONLY THE DD UUO IS LEGAL
	MOVEI AC3,DPYLEN
	PUSHJ P,UFSGET
	MOVE DDB,AC1
	SETOM DPRLSF(DDB)
	SETOM PRGNUM(DDB)
	SETZM PRGCNT(DDB)	; CAN'T BE ANY OVERLAP IN PROGRESS - RPH 10-5-72
	TLO DDB,400000
	JRST CPOPJ1		; SUCCESS
                                                                                                                                                                                                                                                        ;;MORE GENERAL UUO ROUTINES.

^PPIOT:	PUSHJ P,PRGFND		;FIND APPROPRIATE DPY PRGM.
	POPJ P,			;IGNORE IF NOT DISPLAY
	MOVE DAT,CURPP(DDB)	;GET PTR. TO CURRENT P OF P.
	HLL DAT,DDB		; PUT IN FLAG BIT
	CAIG UCHN,MPPIOT	;DOES FUNCTION EXIST ?
	JRST @PPIOTX(UCHN)	;YES.
	JRST UUOERR

DEFINE UUOS{FOR X IN(PPSEL,PPACT,<DPYPOS,,PPYPOS>,<DPYSIZ,,PPXSIZ>
,PPREL,PPINFO,LEYPOS,PPHLD)~

UUOMAC PPIOTX,PPIOT
MPPIOT__UUOCNT-1
                                                                                                                                                                                                                   ; ROUTINE TO RESET A DISPLAY. CLEARS PAGE PRINTER AND PIECES OF GLASS.

^DPYCLR:JUMPN UCHN,DPYFOO	;NON-ZERO AC FIELD MEANS SELECT OTHER DPY.
^DPYRST:SETZM DPYMAP(ITEM)
	PUSHJ P,PRGF1		;FIND DPY PRGM FOR JOB IN ITEM.
	SKIPA			;FOUND. WE WILL RESET IT TO INITIAL STATE.
	POPJ P,			;NO PRGM.
	PUSHJ P,PGCLR		;FIRST FLUSH ALL PIECES OF GLASS.
^PPCLR:	MOVEI UUO,17		;NOW ALL PIECES OF PAPER EXCEPT 0.

; PPREL SELECTS P OF P 0 (UUO_0) IF IT RELEASES A P OF P
;   WHICH IS CURRENTLY SELECTED, AND NOT 0, SO.....
	PUSH P,UUO		;PPREL MAY CLOBBER UUO.
PPC1:	PUSHJ P,PPREL		;RELEASE P OF P.
	SOSE UUO,(P)		;NEXT
	JRST PPC1		;YES
	SUB P,[XWD 1,1]		;ADJUST STACK
				;ALL THIS TO HELP DCS. 5/27/70
	HLL DAT,DDB		; PUT IN FLAG BIT FOR DD
	PUSH P,DDB		; SAVE PROGRAM HEADER ADDRESS
	PUSHJ P,PPSEL		;SELECT P OF P 0.
PPC2:	MOVE DDB,(P)		; PICK UP PROGRAM HEADER
	SETZ UUO,		; CLEAR LINE EDITOR POSITION
	PUSHJ P,LEYPOS
	SETZ UUO,
	PUSHJ P,PPHLD		; RESET HOLDING STATUS
	MOVEI UUO,YPIII		;MAKE P OF P 0 START AT TOP OF SCREEN
	SKIPGE DDB,(P)		; PICK UP PROGRAM HEADER ADDRESS, SKIP IF NOT DATA DISC
	MOVEI UUO,YPDD		; DATA DISK STARTS ON THE THIRD LINE
	PUSHJ P,PPYPOS
	MOVEI UUO,NGSIII*1000+NLSIII		;MAKE IT RIGHT SIZE.
	POP P,DDB
	JUMPGE DDB,PPXSIZ
	MOVEI UUO,NGSDD*1000+NLSDD
	PUSHJ P,PPXSIZ
	HRRZ TAC,PRGNUM(DDB)
	SUBI TAC,DPYNUM
	PUSHJ P,VDRST1
	JRST VDOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ; CALLED FROM <ESC>N IN LINE EDITOR BY A CLOCK REQUEST

^PPNSET:
	PUSHJ P,SETPHD		; SET UP DDB AND DAT PROPERLY
	PUSH P,[PPNST1]
	PUSH P,DDB
	JRST PPC2

PPNST1:	SETO AC1,		; MARK SIZE AND Y-POSITION SET BY USER
	DPB AC1,SIZSBU
	DPB AC1,POSSBU
	POPJ P,

SETPHD:	HRRZ DDB,DAT		; PUT PROGRAM HEADER ADDRESS IN DDB
	SKIPN III(DDB)		; SEE IF WE ARE A DATA DISK DISPLAY
	TLO DDB,400000		; IF SO, SET DATA DISK FLAG
	MOVE DAT,CURPP(DDB)
	HLL DAT,DDB
	POPJ P,

; CALLED FROM <ESC>G IN LINE EDITOR. SETS NUMBER OF GLITCHES

^PPGSET:
	PUSHJ P,SETPHD
	MOVEI AC3,NGSIII
	SKIPG DAT
	MOVEI AC3,NGSDD
	SKIPN UUO,LEARG(DDB)	; PICK UP NUMBER OF GLITCHES REQUESTED
	MOVE UUO,AC3
	LSH UUO,=9		; PUT IN LH OF RH
	ADD UUO,DEL(DAT)
PPGST1:	PUSHJ P,PPXSIZ		; SET IT
	SETO AC1,
	DPB AC1,SIZSBU		; NOTE SIZE WAS SET BY USER
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ; CALLED FROM <ESC>L IN LINE EDITOR. SETS LINES/GLITCH

^PPLSET:
	PUSHJ P,SETPHD
	MOVEI AC3,NLSIII
	SKIPG DAT
	MOVEI AC3,NLSDD
	MOVE UUO,PGSIZ(DAT)
	LSH UUO,=9
	SKIPN AC2,LEARG(DDB)
	MOVE AC2,AC3
	ADD UUO,AC2
	JRST PPGST1

; CALLED FROM <ESC>Y IN LINE EDITOR. SETS Y POSITION

^PPYSET:
	PUSHJ P,SETPHD
	MOVEI AC3,YPIII
	MOVE UUO,LEARG(DDB)
	JUMPL DDB,PPYDD
	MOVEI AC3,YPIII
	IMUL UUO,[-30]
	ADDI UUO,770+30
PPYS2:	CAIL UUO,1000
	MOVEI UUO,(AC3)		;SET TO NORM ON ZERO (NULL) ARG
	PUSHJ P,PPYPOS
	SETO AC1,
	DPB AC1,POSSBU
	POPJ P,

PPYDD:	MOVEI AC3,YPDD
	LSH UUO,7
	IDIV UUO,[-5]
	ADDI UUO,1000
	JRST PPYS2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ; SET PAGE PRINTER HOLD COUNTS. GIVE LINE COUNT IN BITS 18-26 AND
; GLITCH COUNT IN 27-35. HIGH ORDER BIT OF FIELD ON MEANS DO NOT SET.

PPHLD:	SETZ AC1,
	TRNE UUO,1B18		; DOES HE WANT TO SET LINE COUNT?
	JRST PPHLD1		; NO, SKIP IT
	DPB AC1,LHCSBU		; NOTE SET BY UUO
	LDB AC2,[POINT 8,UUO,26];used to say 25 instead of 26--ME 8-19-73
	DPB AC2,HLINES		; SET INTO PROGRAM HEADER
	SKIPN AC2		; ZERO MEANS DON'T HOLD AT ALL
	SETO AC2,		; WHICH IS SIGNIFIED BY -1
	MOVEM AC2,LHCNT(DDB)	; START IT GOING NOW
PPHLD1:	TRNE UUO,1B27		;used to say 1b26--ME 8-19-73
	JRST PPHLD2		; NOW GO UNHOLD US
	DPB AC1,GHCSBU
	LDB AC2,[POINT 8,UUO,35]
	DPB AC2,HGLTCH
	SKIPN AC2
	SETO AC2,
	MOVEM AC2,GLHCNT(DDB)
PPHLD2:	SETZ AC1,
	EXCH AC1,DPHOLD(DDB)
	JUMPE AC1,CPOPJ
	HRRZ AC1,PRGNUM(DDB)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                               ; THIS ROUTINE GIVES THE USER A NICE LITTLE TABLE OF DATA ABOUT HIS
; PAGE PRINTER. THE TABLE IS =20 WORDS LONG. THE FIRST WORD IS
; XWD <POG ACT BITS>,<PP ACT BITS> WHICH ARE IN PPACT OR PGACT FORMAT.
; THE SECOND WORD IS THE NUMBER OF THE PIECE OF PAPER CURRENTLY SELECTED.
; THE THIRD WORD IS THE LINE EDITOR POSITION IN THE RH, BIT ZERO IS
; THE PAGE COLOR, AND BIT 1 SAYS WHETHER <ESC>C HAS BEEN TYPED SINCE YOU
; LAST GAVE THIS UUO, BIT 2 IS ON IF YOU ARE A DATA DISK DISPLAY.
; THE FOURTH THROUGH THE 19.TH WORDS ARE XWD <Y-POS>,<NG*1000+LPG> WHERE
; NG IS THE NUMBER OF GLITCHES AND LPG IS THE NUMBER OF LINES PER GLITCH.
; THIS IS CLEVERLY ARRANGED SO THAT A PPYPOS UUO WITH THE ARGUEMENT
; IN THE LH OF THIS WORD FOLLOWED BY A PPXSIZ WITH THE ARGUEMENT IN
; THE RH OF THIS WORD COMPLETELY RESTORES THAT PAGE.
; THE 20TH WORD IS A COPY OF GWORD. B0 MEANS PAGE PRINTER SIZE SET LAST
; BY USER COMMAND RATHER THAN BY UUO, B1 FOR Y-POSITION, B2 FOR LINE HOLD COUNT,
; AND B3 FOR GLITCH HOLD COUNT. BITS 9-17 HAVE THE ACTUAL LINE HOLD COUNT
; AND BITS 18-25 HAVE THE ACTUAL GLITCH HOLD COUNT. ZERO IF NOT BEING USED.

^PPSPY:	HRR UUO,TAC		;VERSION OF PPINFO FOR ANOTHER JOB'S DPY
	HLRE ITEM,TAC		;ARG IS JOB#,,OUTPUT BLOCK ADDR
	JUMPL ITEM,PPSPY1	; OR - LINE # IN LH
	JUMPE ITEM,CPOPJ	;NON-SKIP RETURN IF NO JOB OR NO DPY
	CAILE ITEM,JOBN
	POPJ P,
	MOVE AC1,JBTSTS(ITEM)
	TLNN AC1,JNA
	POPJ P,
	PUSHJ P,PRGF1		;DON'T USE PRGFND TO FLANK DPYMAP HACK
PPSPY2:	SKIPA DAT,CURPP(DDB)	;PRGF1 SKIP RETURNS ON FAILURE
	POPJ P,			;NO DISPLAY
	HLL DAT,DDB
	AOS (P)			;OK, SET SKIP RETURN AND DROP THROUGH

PPINFO:	MOVE AC1,PRGACT(DDB)	; PICK UP HIS ACTIVATION BITS
	XCTR	XW,[MOVEM AC1,(UUO)]
	MOVE AC1,PPNO(DAT)	; GET CURRENT PIECE OF PAPER NUMBER
	XCTR	XW,[MOVEM AC1,1(UUO)]
	LDB AC1,[POINT 11,LEPOS(DDB),21]
	TRNE AC1,1=10		; EXTEND SIGN BIT
	ORI AC1,-1=10
	MOVE AC2,DDCW(DAT)	; PUT IN BLACK-WHITE BIT
	TLNE AC2,(1B5)
	TLO AC1,(1B0)
	SETZ AC2,		; PUT IN <ESC>C BIT
	EXCH AC2,LECC(DDB)
	SKIPE AC2
	TLO AC1,(1B1)
	JUMPGE DDB,.+2		;DD OR III?
	TLO AC1,(1B2)		;DD, TURN ON BIT
	XCTR	XW,[MOVEM AC1,2(UUO)]
	ADDI UUO,3
IFE 1,<
	HRL AC1,UUO		; NOW ZERO OUT THE TABLE
	HRRI AC1,1(UUO)
	XCTR XW,[SETZM (UUO)]
	XCTR XRW,[BLT AC1,17(UUO)]
>
IFN 1,<
	MOVEI AC1,17(UUO)
PPINF0:	XCTR XW,[SETZM (AC1)]
	CAIE AC1,(UUO)
	SOJA AC1,PPINF0
>
                                                                                                                                                                                 ; PPINFO CONT - RUN DOWN LIST OF PP CTRL BLOCKS

	HLRZ AC1,PPCALL(DDB)	; PICK UP POINTER TO FIRST PAGE PRINTER CONTROL BLOCK
PPINF1:	LDB AC2,[POINT 11,PPOSV(AC1),21]
	TRNE AC2,110		; SPREAD SIGN BIT ALL DOWN WORD
	OR AC2,[-110]
	LSH AC2,=9		; MOVE IT OVER
	ADD AC2,PGSIZ(AC1)	; PUT IN THE NUMBER OF GLITCHES
	LSH AC2,=9
	ADD AC2,DEL(AC1)	; AND THE NUMBER OF LINES PER GLITCH
	MOVE AC3,PPNO(AC1)	; PICK UP THE PIECE OF PAPER NUMBER
	ADD AC3,UUO
	XCTR	XW,[MOVEM AC2,(AC3)]	; GIVE HIM THE WORD
	HRRZ AC1,LINK(AC1)	; PICK UP LINK TO NEXT PAGE PRINTER CONTROL BLOCK
	JUMPN AC1,PPINF1	; LOOP AROUND IF THERE IS ONE
	MOVE AC1,GWORD(DDB)	; PICK UP GARBAGE DUMP WORD
	XCTR	XW,[MOVEM AC1,=19-3(UUO)]
	POPJ P,

PPSPY1:	MOVMS ITEM		;NEGATIVE ARG TO PPSPY IS LINE #
	MOVE DDB,LINTAB(ITEM)
	TLNN DDB,DISLIN!DDDLIN
	POPJ P,
	HRRZ DDB,LETAB-DPYL0(DDB)
	JUMPE DDB,CPOPJ		;NO DDB
	PUSHJ P,PRGF3		;SETS UP DD BIT IN DDB
	JRST PPSPY2
                                                                                                                                                                                                                                                                                                                                                ; THIS IS THE ROUTINE FOR A UUO WHICH SETS YOUR LINE EDITOR'S VERTICAL
; POSITION. THE EFFECTIVE ADDRESS OF THE UUO IS SAID POSITION IN
; PPYPOS FORMAT. Y-POSITION OF ZERO IS VERBOTTEN AND MEANS RETURN TO
; THE BOTTOM OF THE PAGE PRINTER.

LEYPOS:	MOVE AC1,[BYTE (11)<-777>,0(3)0,0(2)1,2(3)3]
	TRNN UUO,-1		; IS THE POSITION ZERO?
	SKIPA AC1,[DISNOP]	; YES, PUT A NO-OP IN
	DPB UUO,[POINT 11,AC1,21]
	MOVEM AC1,LEPOS(DDB)	; PUT IT IN BEFORE THE LINE EDITOR CALL
	JUMPG DAT,CPOPJ
	SETO AC1,		; QUEUE UP A LINE EDITOR REQUEST TO GET IT REPOSITIONED
	EXCH AC1,LECLK(DDB)
	JUMPN AC1,CPOPJ
	HRR AC1,DDB
	HRLI AC1,DPLED
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;;FREEL FREES A LIST OF BLOCKS POINTED TO BY AC1, AND UPDATES
;; THE USER'S BLKTOT.  

FOOFRL:	HRRZ AC1,UUO
	PUSHJ P,FSGIVE
	HRRZ AC1,TAC1
	JUMPE AC1,CPOPJ
FREEL:	HRRZ AC3,LINK(AC1)	;GET CDR OF LIST.
	PUSHJ P,CGIVFS		;FREE CAR OF LIST.
	MOVEM AC3,AC1
	JUMPN AC1,FREEL		;FREE CDR.
	POPJ P,

DPYFOO:	JSP AC3,FNDJOB		;GET JOB NO. (GETJOB IS IN MAIL).
	EXCH DAT,ITEM		;PRETEND IT'S OURS...
	PUSHJ P,PRGFND		;FIND ASSOCIATED DPY PRGM.
	POPJ P,			;SHOULDN'T LOSE ANY MORE THAN ANYONE ELSE
	MOVEM DDB,DPYMAP(DAT)	;ENTER IN OUR TABLE.
	POPJ P,			;WE WILL NOW USE OTHER GUY'S DPY PRGM.
                                           ;;UPG IS THE DEMOCRATIC UUO WHICH ALLOWS ALL MEN,
;; HOWEVER HUMBLE THEIR STATION (PROVIDED IT IS TY20
;; OR HIGHER) TO RUN THEIR VERY OWN DISPLAY 
;; PROGRAMS.

^UPGIOT:	BEGIN UPG

T2_DSER
PBSZ__CNT	;DPY INSTRS /BLOCK.
SIZE__=17
PGWC__0
PGSA__1
PGNP__2

	PUSHJ P,PGSET		;GET REQUESTED P OF G .
	POPJ P,			;NO SUCH DPY, LEAVE NOW
	JUMPL DDB,DDUPG
	MOVEM ITEM,CURPG(DDB)
	XCTR	XR,[HRLZ TEM,(UUO)]	;STARTING ADDR. OF PRGM.
	XCTR	XR,[MOVM AC3,1(UUO)]	;LENGTH OF PRGM.
	CAIL AC3,NBS*PBSZ	;IS PIECE OF GLASS GOING TO BE TOO BIG ?
	JRST UPGTB
	HRLZM AC3,UCHN		;SAVE WC IN LEFT OF UCHN, MAKE RIGHT HALF 0 FOR NOW.
	MOVEI TAC,PBSZ-1+PGNP(AC3)
	IDIVI TAC,PBSZ		; FIND OUT HOW MANY BLOCKS THIS PROGRAM WILL CONSUME
	MOVEI T2,(TAC)
	SUB TAC,SIZE(ITEM)	;HOW BIG IS THIS PG NOW ?
	ADD TAC,BLKTOT(DDB)	;THIS IS HOW MUCH IT GROWS.
	JUMPG TAC,UPGER1	;IS USER OVER HIS ALLOTMENT ?
	HRREI TAC,-1(T2)	;SAVE IT.
	SETZM SIZE(ITEM)	;...SEE FOLLOWING INSTR.
	MOVEI TAC1,DISNOP	;SEE FOLLOWING INSTR...
	JUMPE AC3,UPREL1	;IF WC IS 0, RELEAS PAGE.
	MOVEI AC3,NBS+2		; NICE BIG PIECE
	PUSHJ P,UGETF1		;GET BLOCK FOR THE RELOCATION TABLE.
	JUMPL AC1,CPOPJ		;IF WE ARE AT SPACEWAR LEVEL AND NO FREE STG., JUST RETURN.
	MOVEM AC1,UUO
	MOVEI TAC1,0
	TLOA UUO,TAC		;MAKE UUO AN INDEXED POINTER TO REL. TBL.
L1:	MOVEM AC1,TAC1		;SAVE LOC. OF THIS BLOCK.
	PUSHJ P,CGETFS		;GET A BLOCK OF FREE STG.
	JUMPL AC1,FOOFRL	;GO AWAY IF SPACEWAR AND NO FREE STG.
	MOVSM AC1,@UUO		;ENTER IN RELOCATION TABLE.
	MOVEM TAC1,LINK(AC1)	;LINK TO PREVIOUS BLOCK.
	SOJGE TAC,L1		;GET REST OF BLOCKS NEEDED.
	MOVEM T2,SIZE(ITEM)	;UPDATE SIZE OF THIS PG.
                                                                                                                                                                                                                                                                                	MOVN TAC1,UCHN		;LENGTH OF USERS CODE.
	HLR TAC1,TEM		;STARTING ADDR.
	HRR UCHN,UUO		;BOTTOM OF RELOCATION TABLE.
	HLRZ T2,(UUO)
	ADD UCHN,[XWD PGNP,0]
	HLRZM UCHN,PGWC(T2)
	HLRZM TEM,PGSA(T2)
	ADD T2,[XWD -PBSZ+PGNP,PGNP]
LOOP:	XCTR	XR,[MOVE (TAC1)]	;PICK UP WORD FROM PRGM.
	TRNN 3			;DOES IT NEED EXAMINING ?
	PUSHJ P,SPECOP		;YES, IT IS A POTENTIALLY DANGEROUS INSTR.
	MOVEM (T2)		;STORE THE INSTR.
	AOBJP TAC1,DONE		;AT END OF PGM. ?
	AOBJN T2,LOOP		;NO. END OF BLOCK ?
	MOVE 1(UCHN)		;YES. GET START OF NEXT ONE.
	HRRI DISJMP		;FORM JMP INSTR. TO IT.
	MOVEM (T2)		;PLACE AT END OF LAST BLOCK.
	ADD [XWD 1,0]		;MAKE JMP GO TO 2ND WORD OF NEW BLOCK..
	MOVEM 1(T2)		;...IN CASE THERE IS A TSS WHICH SKIPS..
	HLR T2,1(UCHN)		;GET START OF CURRENT BLOCK.
	HRLI T2,-PBSZ		;LENGTH OF BLOCK.
	AOJA UCHN,LOOP		;GO FILL NEXT BLOCK.

UPGTB:	ERMS {PIECE OF GLASS TOO BIG.~
	POPJ P,
	
SPECOP:	LDB AC1,[POINT 3,0,33]	;GET OPCODE.
	XCT SPCTBL(AC1)		;DO APPROPRIATE THING.
	POPJ P,			;STORE INSTR.

DONE:	MOVE TAC1,(UUO)		;START OF BLOCK 0 OF PRGM.
	ADD TAC1,[XWD PGNP,DISJMP]
	MOVEM TAC1,1(T2)	;MAKE END OF PGM JMP BACK TO START.
	MOVEM TAC1,2(T2)
	HRRZ AC1,UUO		;NOW RELEASE THE RELOC. TABLE.
	PUSHJ P,FSGIVE
	HRRI TAC1,DISJSR	;JSR TO START OF PGM.
^UPREL1:HLRZ AC1,PGCALL(DDB)
	SUBI AC1,(ITEM)		;GET NEG POG #
	MOVSI AC2,400000
	LSH AC2,(AC1)		;MAKE PGACT BIT
	TRNE TAC1,20
	IORM AC2,PRGACT(DDB)	;IS JSR - MARK ACTIVE
	TRNN TAC1,20
	ANDCAM AC2,PRGACT(DDB)	;IS NOP - MARK INACTIVE
	EXCH TAC1,(ITEM)	;EXCHANGE FOR OLD ONE.
	HLRZS AC1,TAC1		;GET START OF OLD PRGM.
	JUMPE TAC1,CPOPJ	;RETURN IF NO OLD PRGM.
	  ;FREE THE OLD PRGM.,AND FIX PRGM TO RESTART AT TOP.
	SUBI AC1,PGNP
	JRST SETRST		;SETRST IS IN PRINT.
                                                                                                                                                                     ;;MORE OF UPG.

;;SPCTBL IS DISPATCH TABLE FOR HANDLING SPECIAL DPY INSTRS.

SPCTBL:	JRST HLTOP	;HALT
	JRST ILLJMS	;JMS
	JRST SELCHK
	JRST ADRRST	;RST (NO BITS ON -- NOOP) (DCS-5/29/70)
	JRST ADROP	;JMP
	JRST ADROP	;JSR OR SAVE
	JRST SELCHK
	JRST ADROP 	;RST (AGAIN.)

SELCHK:	MOVE TAC,JOB
	MOVE TAC,JBTPRV(TAC)
	TLNE TAC,UPGPRV			;RETURN QUICK IF HE HAS THE PRIV
	POPJ P,				;HE HAS THE PRIVILEGE
	MOVE TAC,[<77770010>DPYNUM]	;DESELECT ANYONE.
	MOVEI AC2,DPYNUM-1		;DPY'S ONLY.
	PUSH P,TAC1
LOOPS:	LSH TAC,-1			;SHIFT MASK.
	SKIPN AC3,TTYTAB+DPYL0(AC2)	;POINTER TO DPY DDB.
	JRST DCHNOK		;SELECT OK!
	MOVE TAC1,DEVMOD(AC3)
	LDB AC3,[POINT 6,1(AC3),5]	;GET # OF JOB THAT HAS THAT DPY.
	TDNE TAC1,[XWD TTYATC,ASSCON!ASSPRG]
	CAMN AC3,JOB(PID)			;THIS ONE?
DCHNOK:	TLO TAC,400000			;SELECT BIT.
	SOJGE AC2,LOOPS
	POP P,TAC1
	MOVSI AC2,400000		;GET A BIT.
	MOVN AC3,PRGNUM(DDB)		;DPY NUMBER THIS PROG.(0 TO DPYNUM-1)
	LSH AC2,(AC3)
	TDO TAC,AC2			;MAKE SURE HE GETS HIS OWN.
	AND TAC
	POPJ P,
                                                                                                                                                                                                                                                            ; RST WITH NO PARAM BITS ON IS A NOOP -- ALLOW ANY ARGUMENT
; TO APPEAR UNCHANGED IN THE LEFT HALF

ADRRST:	TRNN	60		;SIZE OR [X,Y] FIELDS ON?  (DCS-5/29/70)
	 POPJ	 P,		; NO, LEAVE IT ALONE	   (DCS)

;CALL ADROP WITH THE FOLLOWING
;	0	XWD <ADDRESS TO CHECK>,<ANYTHING>
;	TEM	XWD <USER BASE ADDRESS>,<ANYTHING>
;	UCHN	XWD <LENGTH OF USER BUFFER>,<ANYTHING>
;	UUO	XWD TAC,<ADDRESS OF RELOCATION TABLE>
;	TAC1	XWD <ANYTHING>,<ADDRESS TO TYPE OUT ON ERROR>

ADROP:	SUB TEM			;AN ADDRESSABLE INSTR. UNRELOCATE IT.
	CAML UCHN		;ADDRESS TOO HIGH ?
	JRST ILLAD		;YUP.
	ADD 0,[XWD PGNP,0]	; SKIP OVER HEADER WORDS
	HLRE AC1,0		; PICK UP ADDRESS
	IDIVI AC1,PBSZ		; GET # BLOCKS AND DISPLACEMENT INTO LAST BLOCK
	HRL 0,AC2		; USE DISPLACEMENT INTO BLOCK PLUS ADDRESS OF BLOCK
	MOVE TAC,AC1
	ADD @UUO		;ADD IN RIGHT RELOCATION.
	JUMPGE AC1,CPOPJ	;WAS ADDRESS TOO SMALL ?
ILLAD:	PUSHJ P,DPYERR		;ILLEGAL ADDRESS IN DPY INSTR.
	ERMS {ILLEGAL INSTR. ADDRESS.~
ILL1:	MOVEI DISNOP		;REPLACE OFFENDING INSTR. WITH NOP.
	POPJ P,

ILLJMS:	PUSHJ P,DPYERR
	ERMS {JMS NOT LEGAL; USE JSR.~
	JRST ILL1

HLTOP:	MOVE (UUO)		;REPLACE HLT WITH RETURN JMP.
	ADD [XWD PGNP,DISJMP]
	POPJ P,

UPGER1:	ERMS {TOTAL DPY BUFFER SPACE EXCEEDED.~
	POPJ P,
                       ; DATA DISC PROGRAM HANDLER
; SENDS THE PROGRAM DIRECTLY OUT OF LOSER CORE IN EXEC MODE

;EXTENDED FEATURES:
;BIT 0 OF HEADER WD 0 => OVERLAPPED XFER (RETURNS WITHOUT WAITING)
; IN THIS MODE HEADER WD 2  0 => XFER GOING.
; DPYOUT ALWAYS WAITS FOR PREV XFER, SO DPYOUT WITH WC=0 WILL
; WAIT FOR BUFFER TO BE AVAIL.
;BIT 1 OF HEADER WD 0 => DOUBLE FIELD MODE, WHICH DOES XFER
; TWICE - ONCE ON EACH FIELD. HEADER WD 3 SHOULD POINT TO WORD
; OF BUFFER CONTAINING (ONLY) LOW-ORDER LINE ADDRESS SELECT
; AS 3RD COMMAND BYTE. THIS BYTE WILL BE ADJUSTED TO APPROP
; FIELD ON EACH XFER.

DDUPG:	SKIPE DDOFF		; DO WE HAVE A DATA DISC TODAY
	POPJ P,			; NO, SPEAK NO EVIL!
	PUSHJ P,DDWAIT		;WAIT FOR PREV XFER, IF ANY
	XCTR	XR,[SKIPGE AC1,(UUO)]	; PICK UP ADDRESS OF USER BUFFER
	XCTR	XW,[SETZM 2(UUO)]	;INIT XFER IN PROGRESS FLAG IF USED
	XCTR	XR,[SKIPG AC2,1(UUO)]	; PICK UP WORD COUNT OF BUFFER
	POPJ P,			;THAT WAS EASY
	ADDI AC2,-1(AC1)	; MAKE POINTER TO LAST WORD
	XCTR	XR,[SKIPE (AC2)]	;DON'T CLOBBER IF OK (MIGHT BE UPPER)
	XCTR	XW,[SETZM (AC2)]	; PUT A HALT THERE AT THE END OF THE BUFFER
	MOVEI AC3,10		; WE WILL LOOK IN THIS FAR FOR A CHANNEL SELECT
DDCWL:	XCTR	XR,[MOVE AC2,(AC1)]	; PICK UP WORD OF PROGRAM
	LDB TAC,[POINT 3,AC2,35]
	CAIN TAC,4		; IS IT A COMMAND WORD?
	JRST CHKAD		; YES, SEE IF IT HAS A CHANNEL SELECT IN IT
DDCINC:	ADDI AC1,1		; BUMP POINTER INTO USER CORE
	SOJG AC3,DDCWL		; BUMP COUNT OF DEPTH AND LOOP BACK
	HLRE TAC,PRGNUM(DDB)	; NO CHANNEL SELECT, SEE IF WE CAN SEND TO HIS OWN SCREEN
	JUMPGE TAC,DDSCHN
	JRST ILLCHN

DDWAIT:	SKIPN PRGCNT(DDB)
	POPJ P,			;NOTHING GOING ON
	MOVNI AC2,DIOWQ
	MOVEI AC3,400000
	CONO PI,APROFF
	SKIPN PRGCNT(DDB)
	JRST APRONJ		;MUST HAVE JUST FINISHED
	MOVEM AC2,JOBQUE(J)
	IORM AC3,PRGJMP(DDB)	;TELL PI ROUTINES TO WAKE US
	CONO PI,APRON
	SKIPGE JBTLIN(J)
	JRST WSCHED		;AVOID RETESTING IF DETACHED (HEADER WILL GO AWAY)
	PUSHJ P,WSCHED		;WAIT FOR IT
	JRST DDWAIT		;THEN CHECK AGAIN TO BE SURE

APRONJ:	CONO PI,APRON
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ; HERE WE ARE, READY TO SET THE CHANNEL ADDRESS OF HIS DATA DISC PROGRAM

DDSCHN:	MOVE AC1,[CW 1,47,3,1,2,0]
	DPB TAC,[POINT 8,AC1,23]
	MOVEM AC1,PRGCW(DDB)	; PUT IN COMMAND WORD WITH CHANNEL SELECT
	XCTR	XR,[MOVE AC2,(UUO)]
	PUSHJ P,CHKADR
	HRLI AC2,DISJMP
	MOVSM AC2,PRGJMP(DDB)	; PUT IN JUMP TO USER'S PROGRAM
	MOVEI TAC,
	XCTR	XR,[SKIPL (UUO)]	;OVERLAPPED MODE?
	JRST UPGQ0		;NO
	XCTR	XRW,[MOVES 2(UUO)]	;BE SURE WE CAN WRITE HERE
	MOVEI AC2,2(UUO)
	PUSHJ P,CHKADR
	MOVEI TAC,(AC2)		;SAVE ABS ADR FOR PI ROUTINES
UPGQ0:	PUSHJ P,GETQ
	XCTR	XR,[MOVE AC3,(UUO)]
	TLNN AC3,200000		;DOUBLE FIELD MODE?
	JRST UPGQ1		;NO
	XCTR	XR,[HRRZ AC2,3(UUO)]	;ADR OF WORD WITH LINE SELECT
	XCTR	XRW,[MOVES (AC2)]	;CHECK WRT ACCESS HERE
	PUSHJ P,CHKADR
	HRLI TAC,(AC2)		;SAVE THIS ADR
	PUSH P,AC1
	PUSHJ P,GETQ		;WILL NEED 2 Q BLKS
	SETOM QFIELD(AC1)
	PUSHJ P,UPGQ
	POP P,AC1
UPGQ1:	SETZM QFIELD(AC1)
	PUSHJ P,UPGQ
	XCTR	XR,[SKIPL (UUO)]	;OVERLAPPED?
	JRST DDWAIT		;NO - WAIT
	POPJ P,			;YES - RETURN

UPGQ:	HRLM	DDB,(AC1)	;LOAD UP TASK BLOCK WITH PROGRAM HEADER
	MOVEI	AC2,POG		;DISPATCH TO USER PROGRAM SERVICE
	HRRM	AC2,(AC1)
	MOVEI	AC2,PRGCNT(DDB)	;PICK UP ADDRESS OF FAKE COUNT FIELD
	MOVEM	AC2,QCOUNT(AC1)
	MOVEM	TAC,QHPOS(AC1)	;STORE SPEC ADRS
	TRNE	TAC,-1
	AOS	(TAC)		;COUNT XFER GOING (FOR LOSER)
	AOS	PRGCNT(DDB)	;AND FOR US
	MOVEM	J,QWAKE(AC1)
	MOVE	AC2,[XWD 1,50]	; MAKE IT LOOK LIKE IT WILL TAKE ENTIRE SCREEN
	MOVEM	AC2,QLINE(AC1)
	AOS	JBTGLU(J)	;KEEP US AROUND
IFN FTSTAT,<PUSHJ P,GLUSTT>
	JRST	QBLOCK
                                                                                                                                                                                                                                                                                                                                                                               ; GET HERE TO LOOK AT A USER'S COMMAND WORD AND SEE IF THERE IS A CHANNEL SELECT

CHKAD:	LDB TAC,[POINT 3,AC2,26]
	CAIN TAC,2		; IS IT A CHANNEL SELECT?
	JRST CHKAC1		; YES, SEE IF IT IS LEGAL.
	LDB TAC,[POINT 3,AC2,29]
	CAIN TAC,2
	JRST CHKAC2
	LDB TAC,[POINT 3,AC2,32]
	CAIN TAC,2
	JRST CHKAC3
	JRST DDCINC

CHKAC1:	LDB TAC,[POINT 8,AC2,7]
CHKAC4:	PUSHJ P,CHAD
	JRST DDSCHN

CHKAC2:	LDB TAC,[POINT 8,AC2,15]
	JRST CHKAC4

CHKAC3:	LDB TAC,[POINT 8,AC2,23]
	JRST CHKAC4

;CHECK & RELOC USER ADR
CHKADR:	HLRZ AC3,JBTADR(J)
	CAIGE AC3,(AC2)
	JRST CHKADU		;PAST LOWER - TRY UPPER
	ADD AC2,JBTADR(J)
	POPJ P,

CHKADU:	TRZN AC2,400000
	JRST UUOERR		;CAN'T BE UPPER
	TRZE AC3,400000
	SUBI AC2,1(AC3)
	LDB AC3,PSEGN
	JUMPE AC3,UUOERR	;NO UPPER
	HLRZ AC3,JBTADR(AC3)
	CAIGE AC3,(AC2)
	JRST UUOERR		;TOO BIG
	LDB AC3,PSEGN
	ADD AC2,JBTADR(AC3)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                         ;CHANNEL ADDRESS CHECKING. HE CAN WRITE ON HIS OWN SCREEN,
;OR ON ANY CHANNEL HE OWNS, OR ON ANY FREE CHANNEL.

CHAD:	JUMPE TAC,MYCHN		;GIVE HIM HIS OWN FOR 0
	ANDI TAC,37
	MOVEI AC1,(TAC)
	PUSHJ P,DDCHEK
	POPJ P,		;FREE
	JRST .+2
	POPJ P,		;HE OWNS IT
	MOVE AC1,JBTPRV(J)
	MOVE AC2,DDTAB(TAC)
	TLNN AC2,DDANYW		;MAYBE OWNER SAYS IT'S OK
	TLNE AC1,UPGPRV
	POPJ P,		;HE CAN WRITE ANYWHERE WITH THE PRIVILEGE
MYCHN:	HLRE TAC,PRGNUM(DDB)	;GIVE HIM HIS OWN CHANNEL (IF ANY)
	JUMPGE TAC,CPOPJ	;WIN
	SUB P,[1,,1]
ILLCHN:	MOVEI AC1,(DDB)
	SKIPE DPRLSF(DDB)
	PUSHJ P,FSGIVE	;MAKE SURE THE PHONY HEADER GETS RETURNED
	PUSHJ P,TTYFUW
	PUSHJ P,INLMES
	ASCIZ /ILLEGAL DD CHANNEL.
/
	JRST TYPGO
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;;PGSET  SETS UP REQUESTED PIECE OF GLASS.

^PGSET:	PUSHJ P,PRGFND		;FIND USER'S DPY PGM.
	POPJ P,			;NO DISPLAY HERE
	JUMPL DDB,CPOPJ1
PGSETA:	HLRZ ITEM,PGCALL(DDB)	;PTR. TO PG HEADER.
	JUMPE ITEM,PGSET1	;IF NONE, START FROM SCRATCH.
	CAMLE UCHN,LSTPG(DDB)	;DOES THIS PG ALREADY "EXIST" ?
	JRST PGSET2		;NO. GO EXTEND THE HEADER.
	ADDI ITEM,(UCHN)	;YES. MAKE ITEM POINT AT
	JRST CPOPJ1		;THE CALLING INSTR. FOR IT.
PGSET1:	PUSHJ P,CGETFS		;GET BLOCK TO USE FOR PG HEADER.
	MOVEM AC1,ITEM
	SETOM LSTPG(DDB)	;NO PG'S EXIST YET.
	HRLI TAC1,PGCALL+1(DDB)	;INVENT RETURN JMP TO PGM HEADER.
	HRRI TAC1,DISJMP
	MOVEM TAC1,(ITEM)	;PUT IN FIRST WORD OF PG HEADER.
	HRLI ITEM,DISJMP
	MOVSM ITEM,PGCALL(DDB)	;FIX CALL ON PG HEADER.
PGSET2:	MOVEI TAC1,DISNOP	;EXTEND ACTIVE PART OF PG HEADER.
	ADD ITEM,LSTPG(DDB)	;GET LAST CURRENT PAGE.
	EXCH UCHN,LSTPG(DDB)
	SUB UCHN,LSTPG(DDB)	;NO. OF PLACES TO EXTEND.
	HRLI ITEM,(UCHN)	;MAKE AOBJN WORD.
	MOVE UCHN,1(ITEM)	;GET RETURN JMP.
PGSL1:	MOVEM UCHN,2(ITEM)	;PUT RTN JMP FARTHER UP.
	MOVEM TAC1,1(ITEM)	;PUT NOP WHERE IT USED TO BE.
	SETZM SIZE+1(ITEM)	;THIS PG IS NOW 0 SIZE.
	AOBJN ITEM,PGSL1
	JRST CPOPJ1
                                                                                                         ; THIS IS THE DPY ERROR ROUTINE. IT TYPES OUT THE PC IN TAC1 ON
; THE DISPLAY.

DPYERR:	PUSH P,TEM
	PUSH P,TAC1
	JSA ITEM,ERRP		;DO THIS SO NO TERMINATING CRLF
	POINT 7,[ASCIZ/$$ USER DPY ERROR AT /]
	HRR AC1,(P)
	MOVEI AC2,6
DPYER1:	HRRZS AC1
	LSH AC1,3		;GET ONE OCTAL DIGIT.
	TLO AC1,60
	LDB CHR,[POINT 7,AC1,17]
	PUSH P,AC1		; SAVE ALL OUR RELEVANT DATA
	PUSH P,AC2
	MOVE DAT,CURPP(DDB)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	HLL DAT,DDB		; PUT IN DD BIT
	CONO PI,SCNOFF		;TURN OFF RPH
	PUSHJ P,TYO		;PRINT  IT.
	CONO PI,SCNON		;TURN ON RPH
	POP P,AC2
	POP P,AC1
	SOJG AC2,DPYER1
	ERMS {~
	POP P,TAC1
	POP P,TEM
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^UPGMVM:PUSHJ P,UPGMV		;DO `MOVEM' INTO P OF G: TAKE CARE OF PRELIMINARIES.
	POPJ P,			;IGNORE IF NO CAN DO
	TRNN 3			;IF THING BEING STORED IS A COMPLICATED DPY INSTR.,
	PUSHJ P,SPECOP		; THEN CHECK AND RELOCATE IT.
	MOVSS DAT		;GET RELOCATED ADDRESS OF THE UPGMVM.
	MOVEM (DAT)		;DO THE STORE.
	POPJ P,

^^UPGMOV:PUSH P,UCHN		;DO A `MOVE' FROM THE CURRENT P OF G.
	PUSHJ P,UPGMV		;LET SOMEBODY ELSE DO THE REAL WORK !
	TDZA DAT,DAT		;RETURN 0 IF NO CAN DO
	JRA DAT,.+1		;HO, HO, HO.  SEE THE CLEVER PROGRAMMER.
	POP P,UCHN		; P1ULOC DOESN'T HAVE OUR UUO ANY MORE, MUST SAVE CHANNEL NUMBER OURSELVES
	XCTR	XW,[MOVEM DAT,(UCHN)]	;PUT RESULT IN USER'S AC.
	POPJ P,

UPGMV:	PUSHJ P,PRGFND		;COMMON ROUTINE FOR UPGMOV AND UPGMVM. FIND PRGM.
	POPJ P,			;NO DPY, NO MOVY
	JUMPL DDB,CPOPJ
	SKIPE ITEM,CURPG(DDB)	;GET CURRENTLY SELECTED P OF G.
	SKIPN SIZE(ITEM)	;MAKE SURE IT EXISTS.
	POPJ P,
	XCTR	XR,[MOVE DAT,(UCHN)]	;PICK UP CONTENTS OF USER'S AC.
	MOVS T2,(ITEM)		;GET PTR. TO THE P OF G.
	SUBI T2,PGNP		;MAKE IT POINT TO THE DESCRIPTOR WORDS.
	HRLZ TEM,PGSA(T2)	;STARTING ADDR. (IN USER CORE) OF P OF G.
	HRLZ UCHN,PGWC(T2)	;LENGTH OF P OF G.
	HRLZ UUO		;ADDRESS OF THE `MOVE' OR `MOVEM'.
	MOVE UUO,[XWD TAC,TBL]	;PREPARE TO GENERATE A BLOCK MAP FOR
	HRLZM T2,(UUO)		;THE P OF G. (PUT IN BOTTOM PTR.).
	SKIPE T2,LINK(T2)	;GET NEXT BLOCK, IF ANY.
	AOJA UUO,.-2		;PUT IT IN MAP.
	HRRI UUO,TBL		;MAKE UUO POINT TO MAP.
	HLRZ TAC1,0		;PRINT THIS ADDRESS IN EVENT OF ERROR!
	PUSHJ P,ADROP		;NOW RELOCATE AND CHECK ADDR. OF MOVE.
	EXCH DAT,0		;PUT OPERAND (IF `MOVEM') INTO 0.
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                                         ^^PGIOT:
	CAIL UCHN,PGMAX		;GENERAL P OF G SERVICE IOT.
	JRST UUOERR
	PUSHJ P,DDFND		; FIND A PROGRAM HEADER (UCHN =3 GAURANTEES ONE)
	POPJ P,			;IGNORE IF NO DISPLAY
	JUMPG DDB,@PGDSP(UCHN)	; IF III, DISPATCH NOW
	CAIGE UCHN,3		; ONLY ONES LEGAL FOR DD CURRENTLY
	POPJ P,			; ALL THE OTHERS DON'T MAKE SENSE.
	JRST @PGDSP(UCHN)	;INDEX REG FIELD WAS MISSING, SO
				; ONLY PGSEL WAS AVAILABLE -- DCS (6/2/70)

DEFINE UUOS{FOR X IN(PGSEL,PGACT,PGCLR,DDUPG,PGINFO)~

UUOMAC PGDSP,PGIOT
PGMAX__UUOCNT

PGSEL:	HRRZ UCHN,UUO		;SELECT THE P OF G INDICATED BY THE ADDR. FIELD.
	CAIL UCHN,20		;IS IT LEGAL ?
	JRST ADRERR
	PUSHJ P,PGSETA		;FIND THE P OF G.
	POPJ P,			;SHOULD NEVER GET HERE, BUT PGSETA SKIP RETURNS
	MOVEM ITEM,CURPG(DDB)	;MAKE IT THE CURRENTLY SELECTED ONE.
	POPJ P,

^VPGACT:MOVEI DDB,(DAT)		;HERE ON CLK RQ FROM VDSTR
	HLRZ UUO,PRGACT(DDB)	;THIS MAKES THE PROGRAM AGREE WITH THE BITS
PGACT:	HLRZ ITEM,PGCALL(DDB)
	JUMPE ITEM,CPOPJ
	HRLM UUO,PRGACT(DDB)
	MOVE TAC,LSTPG(DDB)
	MOVEI AC1,DISNOP
	MOVEI AC2,DISJSR
PGACL:	SKIPN SIZE(ITEM)
	JRST PGAC1
	HRRM AC1,(ITEM)
	TRNE UUO,400000
	HRRM AC2,(ITEM)
PGAC1:	ROT UUO,1
	SOJL TAC,CPOPJ
	AOJA ITEM,PGACL

;;PGCLR FLUSHES ANY PIECES OF GLASS A LOSER MAY HAVE.  DDB SHOULD BE SET UP POINTING TO PRGM HEADER.

^PGCLR:	SETZM CURPG(DDB)
	HLRZ ITEM,PGCALL(DDB)	;GET PTR. TO PG HEADER BLK.
	JUMPE ITEM,CPOPJ	;IF NONE, GO AWAY.
PGCLR1:	MOVEI TAC1,DISNOP	;FREE A PIECE OF GLASS.
	PUSHJ P,UPREL1		;(SEE ABOVE.)
	SOSL LSTPG(DDB)		;HAVE WE GOT ALL THE PG'S ?
	AOJA ITEM,PGCLR1	;NO. GET SOME MORE.
	MOVEI UCHN,DISNOP	;TURN OFF CALL ON THE PG HEADER.
	EXCH UCHN,PGCALL(DDB)
	HLRZ AC1,UCHN		;PTR. TO HEADER.
	JRST CGIVFS		;FREE THE PG HEADER BLOCK.
                                                                                                                                                                                 ; THIS UUO GETS INFORMATION FROM THE SYSTEM ABOUT THE USER'S PIECES
; OF GLASS. IT IS GIVEN IN A 17. WORD TABLE. THE FIRST WORD IS
; XWD <POG ACTIVE BITS>,<PP ACTIVE BITS> IN PPACT AND PGACT FORMAT.
; THE NEXT 16. WORDS, ONE WORD FOR EACH POG, IS XWD <WORD COUNT>,<STARTING ADDRESS>

PGINFO:	MOVE AC1,PRGACT(DDB)	; PICK UP THE ACTIVATION BITS
	XCTR XW,[MOVEM AC1,(UUO)]
	ADDI UUO,1
	HLRZ AC1,PGCALL(DDB)	; PICK UP ADDRESS OF UPG CONTROL BLOCK
	SETZ AC3,
PGCLP:	HLRZ CHR,(AC1)		; PICK UP ADDRESS OF FIRST BLOCK OF CODE
	JUMPE CHR,PGSZ		; IF NOTHING THERE, CLEAR WORD IN TABLE
	SUBI CHR,PGNP		; POINT US TO THE CONTROL INFORMATION
	HRRZ AC2,PGSA(CHR)	; PICK UP THE STARTING ADDRESS
	XCTR XRW,[HRRM AC2,(UUO)]
	HRRZ AC1,PGWC(CHR)	; AND THE WORD COUNT
	XCTR XRW,[HRLM AC1,(UUO)]
	JRST PGCNT

PGSZ:	XCTR XW,[SETZM (UUO)]
PGCNT:	ADDI UUO,1		; BUMP POINTER INTO USER'S TABLE
	ADDI AC1,1		; AND POINTER TO UPG CONTROL BLOCK
	ADDI AC3,1		; AND COUNT OF NUMBER OF POGS SEEN
	CAIG AC3,LSTPG(DDB)	; ARE WE PAST THE LAST?
	JRST PGCLP		; NO, LOOP BACK
PGXLP:	CAILE AC3,17		; ARE WE DONE?
	POPJ P,			; YES, LEAVE
	XCTR XW,[SETZM (UUO)]
	ADDI AC3,1		; AND COUNT
	AOJA UUO,PGXLP		; BUMP POINTER AND LOOP

BEND UPG
                                                  ;;DPYTYP IS CALLED AT CLOCK LEVEL TO TYPE SOME CHRS. FROM A 
;; TTY OUTPUT BUFFER ONTO A DISPLAY.  DAT CONTAINS LINE NUMBER.

DPYTY1:	TRNE DAT,-1PUNITS	; LEGAL LINE NUMBER?
	JRST DPYTER		; NO, GIVE ERROR MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; PICK UP DEVICE DATA BLOCK ADDRESS
	POPJ P,			; IF NONE, LEAVE NOW, NO CHARACTERS TO TYPE
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
^DPYERT:
	HRRI DAT,TTIBUF(DDB)	; PICK UP INPUT BUFFER ADDRESS
	HRLI DAT,DPYTY1		; MAKE US COME BACK TO THIS ROUTINE IF WE HAVE TO WAIT
	JRST DPYTY4

^DPYTYP: HGMAC(34)
	TRNE DAT,-1PUNITS
	JRST DPYTER		; ILLEGAL LINE NUMBER
	HRLI DAT,DPYTYP		; COME BACK TO HERE IF WE HAVE TO WAIT
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A DDB THERE?
	POPJ P,			; NO, NOT MUCH TO DO NOW!
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
DPYTY4:	MOVEI DSER,(DDB)	;PRESERVE A COPY OF DDB ADDR.
	HRRZ DDB,LETAB-DPYL0(TAC1)	;FIND DPY FOR THIS JOB.
	JUMPN DDB,DPYTY2	; IF WE HAVE A BLOCK, OK
DPYTY5:	PUSHJ P,DPYMAKE		; OTHERWISE, TRY TO MAKE ONE
	JRST DPYTLN		; NOONE HOME, LOSE LOSE
	AOS NDPMAK#		; BUMP NUMBER OF TIMES WE HAD TO DO THIS
	HRRZ DDB,LETAB-DPYL0(TAC1)
DPYTY2:	MOVNI IOS,12		;TYPE NO MORE THAN 12 CHARS/TICK.
	SKIPE UUO,CURPP(DDB)	;TYPE ON CURRENTLY SELECTED P OF P.
	JRST DPYTL1
DPYTY6:	PUSH P,DAT		; SAVE THE OUTPUT BUFFER ADDRESS
	HLRE TAC,PRGNUM(DDB)	; PICK UP DPY NUMBER
	PUSHJ P,PPINIT		; SEE IF WE CAN GET A PAGE PRINTER
	JRST DPYTY3		; NO, COME BACK NEXT TICK AND TRY AGAIN
	PUSHJ P,PPSET		; YES, INITIALIZE IT
	HRRZ UUO,CURPP(DDB)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	POP P,DAT		; GET BACK TTY OUTPUT BUFFER ADDRESS
	JRST DPYTL1

DPYTY3:	POP P,DAT
	JRST DPYTLN
                                                                                                                                                                                                               ; HERE WE ARE AT CLOCK LEVEL WITH (SUPPOSEDLY) DAT SET TO
; THE TTY BUFFER AND UUO POINTING TO THE PAGE PRINTER CONTROL BLOCK

DPYTL1:	SKIPE PPDD(UUO)		; IS THIS A DD DISPLAY?
	TLO UUO,400000		; YES, FLAG THIS TO DPYSER
	SKIPE DPHOLD(DDB)	; ARE WE IN HOLD MODE?
	JRST STAR		; YES, PRINT STARS AND GO AWAY
	SKIPE PPENQ(UUO)	; DO WE CURRENTLY HAVE ANYTHING IN THE QUEUE?
	POPJ P,			; YES, GO AWAY UNTIL IT IS DONE.
DPYTL2:	CONO PI,SCNOFF		; AVOID EMBARASSING CONFUSION OVER BUFFER EMPTY
DPTL2A:	PUSHJ P,GETCHO		; GET A CHARACTER
	JUMPE CHR,DPYTLX	; BUFFER EMPTY

	SKIPL	LSTCHR(UUO)	;REG 1/25/74 DID TYO INVENT CRLF LAST TIME?
	JRST	DPTL2B		;NO. BEHAVE NORMALLY
	CAIN	CHR,15		;YES. CR'S GET FLUSHED NOW.
	JRST	DPTL2A		;
	MOVEM	CHR,LSTCHR(UUO)	;SAVE CHR
	MOVEI	CHR,12
	EXCH	CHR,LSTCHR(UUO)	;RESTORE CHR. LSTCHR NOW LOOKS LIKE NORMAL LF.
	CAIN	CHR,12		;FIRST LF AFTER LSTCHR WAS SET TO -1 IS FLUSHED.
	JRST	DPTL2A		;ONLY IF NO PREVIOUS CHARACTER (EXCEPT CR) SEEN

DPTL2B:	PUSH P,CHR		; SAVE THE CHARACTER
	EXCH DAT,UUO		; GET PP CONTROL BLOCK ADDRESS IN DAT
	PUSHJ P,TYO		; SEND THE CHARACTER OUT
	CONO PI,SCNON
	EXCH DAT,UUO
	POP P,CHR

	SKIPGE LSTCHR(UUO)	;DID TYO INVENT CRLF AT LONG LINE?  REG 1/25/74
	MOVEI CHR,12		;YES. PRETEND WE WERE THE ONE WHO ASKED FOR LF.

	CAIN CHR,12		; IS IT END OF LINE TIME?
	SOSE LHCNT(DDB)		; YES, ARE WE SUPPOSED TO HOLD NOW?
	JRST DPYTL3		; NO, GO ON
	LDB AC1,HLINES		; YES, RESET HOLD COUNT
	MOVEM AC1,LHCNT(DDB)
	SETOM DPHOLD(DDB)
	JRST STAR

DPYTL3:	SKIPE GLTCH(UUO)	; GLITCH TIME?
	SKIPE GLHCNT(DDB)	; YES, IS IT TIME TO HOLD?
	JRST DPYTL4
	LDB AC1,HGLTCH		; YES, RESET COUNT
	MOVEM AC1,GLHCNT(DDB)
	SETOM DPHOLD(DDB)
	JRST STAR

DPYTL4:	JUMPL UUO,DPTDD		; IF DD, GO TO SPECIAL ROUTINE
;*** RPH PATCH TO SLOW DOWN OUTPUT OF BLANK LINES
	CAIE CHR,12
	CAIN CHR,15
	JRST DPYTLN
;*** END SLOW DOWN PATCH
	AOJN IOS,DPYTL2		; OTHERWISE, COUNT DOWN AND LOOP BACK
	JRST DPYTLN		; AND PUT IN ANOTHER CLOCK REQUEST IF TOO MANY CHARACTERS THIS TICK
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ; ROUTINE TO TYPE CTY ERROR MESSAGE ON ILLEGAL LINE NUMBER

DPYTER:	PUSH P,DAT
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL LINE NUMBER AT DPYTYP - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,DAT
	POPJ P,

; ROUTINE TO TYPE STAR ON LINE THREE WHEN TYPEOUT IS HELD UP

STAR:	JUMPG UUO,IISTAR	; SEPARATE ROUTINE FOR III
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; PICK UP ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; GET THE ADDRESS OF THE FIRST ONE BACK
	HRLI UUO,PPSTAR		; SET UP DISPATCH TO ROUTINE THAT DRAWS STAR ON LINE THREE
	MOVSM UUO,(AC1)		; SET IT IN FIRST TASK BLOCK
	MOVSM UUO,(AC2)		; AND IN SECOND ONE
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP ABOUT THIS
	SETZM QCOUNT(AC2)
	SETZM QFIELD(AC1)	; FIRST FIELD OF ERASURE
	SETOM QFIELD(AC2)	; SECOND FIELD
	MOVE AC3,[XWD 3,3]	; TELL QBLOCK WHERE TO QUEUE THIS REQUEST
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; NOW QUEUE UP THE REQUESTS
	POP P,AC1
	JRST QBLOCK

IISTAR:	MOVE AC1,PSELB(DDB)	; PICK UP GUY'S SELECT WORD
	AND AC1,[77B5]		; MASK OUT ALL BUT HIS SELECT BIT
	ORM AC1,DPYHLD		; SELECT HIM FOR THE MASSAGE
	LSH AC1,-=12		; MOVE OVER TO DESELECT FIELD
	ANDCAM AC1,DPYHLD
	POPJ P,
                                              ; ROUTINE, CALLED FROM CLOCK CALL WITH LINE NUMBER IN DAT, TO CONTINUE PAGE PRINTER

^UNHOLD:
	HRLI DAT,DPYTYP		; SET UP TO COME BACK TO PRINT ROUTINE IF DONE
	TRNE DAT,-1PUNITS	; IS THE LINE NUMBER LEGAL?
	JRST DPYTER		; NO, TYPE MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A TTY DDB?
	POPJ P,			; NO, FORGET IT.
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
	MOVEI DSER,(DDB)	; COPY THE DEVICE DATA BLOCK POINTER
	HRRZ DDB,LETAB-DPYL0(TAC1)
	JUMPE DDB,DPYTY4	; IF NO PROGRAM HEADER, NO STAR TO ERASE
	SKIPN UUO,CURPP(DDB)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	JRST DPYTY6		; IF NONE, GO MAKE ONE UP
	SKIPE PPDD(UUO)
	TLO DDB,400000
	HLL UUO,DDB
	JUMPG UUO,UNHIII
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE
	SETZM QFIELD(AC1)	; SEND IT OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; THE OTHER ON THE OTHER
	HRLI UUO,ERASE		; DISPATCH TO THE ERASURE ROUTINE
	MOVSM UUO,(AC1)		; SET THAT IN DISPATCH ADDRESS
	MOVSM UUO,(AC2)
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP
	SETZM QCOUNT(AC2)
	MOVE AC3,[XWD 3,3]	; ERASE LINE 3
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK
	POP P,AC1
	PUSHJ P,QBLOCK
	HRLI UUO,400000		; RESTORE DD FLAG
	JRST DPYTL1

UNHIII:	MOVE AC1,PSELB(DDB)
	AND AC1,[77B5]
	ANDCAM AC1,DPYHLD
	LSH AC1,-=12
	ORM AC1,DPYHLD
	JRST DPYTL1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                ; COME HERE FOR DATA DISK TO SEE IF IT IS END OF LINE OR GLITCH TIME.

DPTDD:	SKIPN GLTCH(UUO)	; HAS THE PAGE PRINTER GLITCHED?
	CAIN CHR,12		; OR IS THIS END OF LINE?
	JRST DPTDDK		; YES, QUEUE UP A DD REQUEST AND LEAVE
	JRST DPYTL2		; OTHERWISE, PUT IN ANOTHER CHARACTER

DPTDDK:	HRRZ AC1,TPJMP(UUO)	; FIRST, IS THE P OF P ACTIVE?
	CAIN AC1,DISNOP
	JRST DPYTL2		; NO, JUST EMPTY THE BUFFER
	JRST QDDR

DPYTLN:	HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM
^DPYTIM:CONO PI,PIOFF
	IDPB DAT,CLKQ		;PUT IN CLOCK REQUEST.
	CONO PI,PION
	POPJ P,
                                                                                  SUBTTL DATA DISK SERVICE ROUTINE - JAM, DEC. 1970

; THESE ROUTINES ARE CALLED BY THE FOLLOWING IN APRINT
;	SOSGE DDCNT
;	JRST DDCLK
;	SKIPE DDSTART
;	JRST DDSTRT
;APRADD:
; THE DATA DISK ROUTINES KNOW ALL ABOUT THE PAGE PRINTER
; AND THE PIECE OF GLASS MECHANISM. TRANSFERS ARE STARTED
; BY PLACING AN ADDRESS IN THE QUEUE WITH THE LEFT HALF GIVING
; THE TYPE OF TRANSFER.

; HERE ARE THE DD HARDWARE BITS
; CONO BITS

START__100	; STARTS TRANSFER
RESET__10	; RESETS INTERRUPT BIT
ENB__40		; INTERRUPT ENABLE
LOSENB__400	; ENABLE LATE FLAG INTERRUP
DAMMIT__20	; MAKES TRANSFER GO OUT ON SPECIFIC FIELD
EXECM__1000	; EXEC MODE, ALLOWS ONLY ONE CHANNEL SELECT
DDNXM__2000	; NON-EX MEM FLAG
USUAL__START!ENB!LOSENB!DAMMIT!APRCHN

; CONI BITS
FIELD__40	; FIELD BIT
INT__20		; INTERRUPT BIT
LOSE__200	; LATE FLAG

; $M+2/     -1775,,770707

; TASKS ARE QUEUED UP IN SMALL BLOCKS IN THE FOLLOWING FORM:

		; FIRST WORD CONTAINS XWD <RELEVANT DATA BLOCK>,<ROUTINE>
QLINE__1	; XWD <STARTING LINE #>,<ENDING LINE #>
QFIELD__2	; 0 FOR EVEN FIELD, -1 FOR ODD FIELD
QHPOS__3	; XWD <HPOS1>,<HPOS2> FOR CURSOR TRANSFERS. ZERO ERASES CURSORS.
QLINK__4	; LINKAGE WORD. XWD <BACKWARD LINK OR 0>,<FORWARD LINK OR 0>
QWAKE__5	; CONTAINS JOB NUMBER TO WAKE UP, OR CLOCK REQUEST TO PLANT
QCOUNT__6	; ADDRESS OF WORD TO DECREMENT WHEN THIS TASK DONE. WHEN ZERO, WAKE UP VIA QWAKE WHOMEVER
QTIME__7	; COUNT DOWN OF NUMBER OF FAILURES
^QLENGTH__10	; LENGTH OF A TASK BLOCK
                                                                                                                                                                                                                                                                                                                                                                                                                                          ; CLOCK LEVEL QUEING SCHEME. PLANTS TASKS IN QUEUE AND LEAVES.
; LAST TASK TO FINISH PLANTS CLOCK REQUEST TO TRANSFER MORE DATA.

QDDR:	MOVE AC3,VPOS(UUO)	; PICK UP VERTICAL POSITION
	SUBI AC3,1		; DON'T GO ALL THE WAY TO THE CURRENT LINE
	MOVEM AC3,VP(UUO)	; STORE IT
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ADDRESS OF FIRST TASK BLOCK
	PUSHJ P,GETQ		; GET ANOTHER TASK BLOCK
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST TASK BLOCK TOO
	HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM OF CLOCK REQUEST
	MOVEM DAT,QWAKE(AC1)	; PUT THE OUTPUT BUFFER ADDRESS AS WAKEUP WORD
	MOVEM DAT,QWAKE(AC2)
	AOS PPENQ(UUO)		; BUMP TASK COUNT BY TWO
	AOS PPENQ(UUO)
	MOVEI AC3,PPENQ(UUO)	; COUNT US DOWN ON THE PAGE PRINTER COUNTER
DOXFR:	SETZM PPVIRG(UUO)	; NOTE THAT SOMETHING HAS GONE OUT ON THIS PIECE OF PAPER
	MOVEM AC3,SC(UUO)	; SAVE THE COUNT ADDRESS, IF ANY, FOR FUTURE REFERENCE
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	SETZM QFIELD(AC1)	; SEND ONE OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; AND THE OTHER OUT ON THE OTHER
	HRLM UUO,(AC1)
	HRLM UUO,(AC2)		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS AS DATA BLOCK ADDRESS
	MOVEI AC3,PPXFR		; PICK UP ADDRESS OF I-LEVEL SUBROUTINE
	HRRM AC3,(AC1)		; PLACE IT IN ROUTINE ADDRESS POSITION
	HRRM AC3,(AC2)
	SKIPN GLTCH(UUO)	; IS THIS A WHOLE SCREEN TRANSFER?
	JRST DPTDL		; NO, JUST DO ONE LINE
	SETZM GLTCH(UUO)	; WE ARE DONE GLITCHING
	EXCH DAT,UUO		; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	PUSHJ P,POSLIN		; GET LINE NUMBER OF FIRST LINE OF TRANSFER
	EXCH DAT,UUO
	CAML AC3,VPOS(UUO)	; IS THERE REALLY A PAGE HERE?
	JRST NOPAGE		; NO!
	HRLM AC3,QLINE(AC1)
	HRLM AC3,QLINE(AC2)	; THAT WILL BE STARTING LINE NUMBER ON BOTH FIELDS
	MOVE AC3,VP(UUO)	; PICK UP NUMBER OF LAST LINE OF TRANSFER
	HRRM AC3,QLINE(AC1)	; THIS WILL BE ENDING LINE NUMBER
	HRRM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; QUEUE UP FIRST TASK
	POP P,AC1		; GET ADDRESS OF SECOND TASK BACK
	PUSHJ P,QBLOCK		; QUEUE IT UP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ; WE GET HERE AT CLOCK LEVEL IN THE MIDDLE OF QUEUEING UP A WHOLE SCREEN REQUEST.
; WE HAVE PUT IN THE TEXT REQUESTS AND ARE NOW GOING TO PUT IN THE ERASURE
; REQUEST.

	MOVE AC2,VP(UUO)	; FIRST, IS THERE ANYTHING TO DO?
	MOVEM AC2,LLW(UUO)	; UPDATE LAST LINE WRITTEN
	CAML AC2,GLW(UUO)
	POPJ P,			; NO, WE ARE DONE
	PUSHJ P,GETQ
	PUSH P,AC1		; GET ANOTHER TASK BLOCK AND SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ONE FOR EACH ERASURE FIELD
	MOVE AC3,(P)		; GET BACK ADDRESS OF FIRST ONE
	HRLM UUO,(AC1)		; PUT IN PAGE PRINTER CONTROL BLOCK ADDRESS
	HRLM UUO,(AC3)
	MOVEI AC2,ERASE		; WE WILL CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(AC3)
	MOVEM DAT,QWAKE(AC1)	; PUT THE CLOCK REQUEST WORD IN
	MOVEM DAT,QWAKE(AC3)
	MOVE AC2,SC(UUO)	; PICK UP COUNT ADDRESS
	MOVEM AC2,QCOUNT(AC1)	; COUNT DOWN THROUGH IT.
	MOVEM AC2,QCOUNT(AC3)
	SETZM QFIELD(AC1)	; SEND THEM OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC3)
	MOVE AC2,GLW(UUO)	; ERASE TO THE LAST LINE WRITTEN
	HRRM AC2,QLINE(AC1)
	HRRM AC2,QLINE(AC3)
	MOVE AC2,VP(UUO)	; ERASE FROM THE CURRENT POSITION
	MOVEM AC2,GLW(UUO)	; UPDATE LAST LINE WRITTEN
	HRLM AC2,QLINE(AC1)
	HRLM AC2,QLINE(AC3)
	SKIPN SC(UUO)		; IS THERE A COUNT ADDRESS?
	JRST QDD1		; NO, DON'T INCREMENT IT!
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
QDD1:	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1
	JRST QBLOCK		; AND THE SECOND ONE

; WE GET HERE IF THERE REALLY ISN'T ANYTHING ON THE PAGE

NOPAGE:	PUSHJ P,WAKEQ		; WAKE UP ANYONE WHO'S THERE
	PUSHJ P,GIVQB		; JUST RETURN EVERYTHING TO FREE STORAGE.
	POP P,AC1
	PUSHJ P,WAKEQ
	JRST GIVQB
                                                                                                                                                                                                                                                                                                               ; WE GET HERE TO QUEUE UP A ONE LINE REQUEST.

DPTDL:	MOVE AC3,LLW(UUO)	; PICK UP LINE NUMBER
	CAMLE AC3,VP(UUO)	; IS THIS PAST WHERE WE ARE SUPPOSED TO BE?
	MOVE AC3,VP(UUO)	; YES, USE OUR ARGUEMENT
	HRLM AC3,QLINE(AC1)	; STORE THIS
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VP(UUO)	; END UP ON LINE THE CALLER REQUESTED
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
	MOVEM AC3,LLW(UUO)	; AND THIS IS NOW THE LAST LINE WRITTEN
	PUSHJ P,QBLOCK		; PUT THIS BLOCK IN THE QUEUE
	POP P,AC1		; GET BACK ADDRESS OF SECOND BLOCK
	JRST QBLOCK		; QUEUE IT UP TOO

; WE GET TO THIS ROUTINE WHEN THE BUFFER IS EMPTY.

DPYTLX:	JUMPG UUO,DPYDON	; III DISPLAYS CAN GO ON TO TTYSER NOW
	SKIPN DPYCHR(UUO)	; HAS AT LEAST ONE CHARACTER BEEN TYPED?
	JRST DPYDON		; NO, EXIT
	SETZM DPYCHR(UUO)	; CLEAR TYPEOUT FLAG
	MOVN AC1,DPHPOS(UUO)	; PICK UP HORIZONTAL POSITION POINTER
	PUSH P,DAT		; SAVE TTY BUFFER ADDRESS
	HRR DAT,UUO		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS IN DAT FOR REFLINE
	MOVE AC2,LLW(UUO)	; SEE IF PAGE PRINTER IS UP TO DATE
	CAMN AC2,VPOS(UUO)	; COMPARE LAST LINE WRITTEN WITH VERTICAL POSITION
	CAME AC1,LNLNGT(UUO)	; IF NOT AT COLUMN ZERO,
	PUSHJ P,REFLINE		; PUT IN A SINGLE LINE REQUEST
	POP P,DAT
	HRRZ AC1,HEDPTR(UUO)	; PICK UP POINTER TO DPY PROGRAM HEADER
	MOVSI AC2,DPLED		; MAKE A POINTER TO THE LINE EDITOR QUEUE ROUTINE
	HRR AC2,AC1		; AND MAKE IT INTO A CLOCK REQUEST WORD
	SETO AC3,		; SEE IF LINE EDITOR CLOCK FLAG IS SET
	EXCH AC3,LECLK(AC1)	; IF NOT SET, SET IT NOW
	JUMPL AC3,DPYDON	; IF ALREADY IN, LEAVE NOW
	CONO PI,PIOFF		; NOT IN, PLANT CLOCK REQUEST
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST DPYDON
                                                                                                                                                                                                                                                                                       ; THIS ROUTINE QUEUES UP AN ERASURE REQUEST FOR THE LINE EDITOR <ESC>C COMMAND

^LEERSN:TLCA DAT,LEERSNPPNSET	;CHANGE CLK RQ TO CALL PPNSET
^RFPCS:	HRLI DAT,LERFP
	SKIPE III(DAT)
	JRST LEPGC
	MOVEI AC2,LEENQ2(DAT)	;ENTER HERE FOR SOMETHING ELSE TO BE QUEUED AFTER THE ERASE
	AOSA LEENQ2(DAT)
^LEERS:	MOVEI AC2,
	SKIPE III(DAT)
	JRST LEPGC2		;DIFFERENT "ERASE" ON III
	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVEM AC2,QCOUNT(AC1)
	MOVEM DAT,QWAKE(AC1)
	SETOM LECC(DAT)
LEERS3:	MOVE AC2,[XWD 1,=40]
	MOVEM AC2,QLINE(AC1)
	SETZM QFIELD(AC1)	; START ON FIELD ZERO
	HRLM DAT,(AC1)		; GIVE IT DPY PROGRAM HEADER ADDRESS
	MOVEI AC2,WSE		; GO TO THE ERASURE ROUTINE
	HRRM AC2,(AC1)
	SETOM LEVP(DAT)		;TELL DPLED OUR CURSORS BIT THE DUST
	SETOM LECVP(DAT)
	JRST QBLOCK		; PUT IT IN THE QUEUE

LEPGC:	HLRZ TAC,DAT
	PUSH P,DAT
	PUSHJ P,(TAC)		;DO PP STUFF FIRST
	POP P,DAT
LEPGC2:	MOVEI DDB,(DAT)
	JRST PGCLR

; THE LINE EDITOR PLANTS A CLOCK REQUEST TO HERE WHEN IT
; IS DONE TRANSFERRING A LINE INTO THE PAGE PRINTER BUFFER.
; WE SEND OUT THE LINE IT HAS JUST TRANSFERRED.

^REFLINE:
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, DON'T BOTHER
	PUSHJ P,GETQ		; GET US A TASK BLOCK
	PUSH P,AC1
	PUSHJ P,GETQ
	MOVE AC2,(P)
	MOVE AC3,VPOS(DAT)	; PICK UP VERTICAL POSITION
	MOVEM AC3,VP(DAT)	; SAVE THIS AS ARGUEMENT FOR QDD
	MOVEI AC3,PPNQT(DAT)	; COUNT DOWN THROUGH OTHER COUNT CELL
	HRRZ UUO,DAT		; IT EXPECTS THE PAGE PRINTER ADDRESS IN UUO
	AOS PPNQT(DAT)		; COUNT DOWN SO THE LINE EDITOR WILL KNOW WHEN WE ARE DONE
	AOS PPNQT(DAT)
	SETZM QWAKE(AC1)	; DON'T WAKE UP ANYBODY
	SETZB DAT,QWAKE(AC2)
	JRST DOXFR		; USE QDD TO DO ALL THIS
                                                                                                                                                                                             ; HERE LIES A ROUTINE TO QUEUE UP A WHOLE PAGE TRANSFER WHEN NOT GLITCHING

^LERFP:	MOVEI DDB,(DAT)
	SKIPE III(DAT)
	JRST PPRST		;RESTART PROG IF III
	HRRZ UUO,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE AC1,HEDPTR(UUO)
	CAIE AC1,(DAT)
	JRST PPCLB		;CURPP IS CLOBBERED OR SOMETHING
	HRRZ AC1,TPJMP(UUO)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, FORGET IT
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER'S QUEUE?
	JRST LERFP1		; YES, IT WILL GET CAUGHT LATER
	SETZM PPVIRG(UUO)	; NO LONGER A VIRGIN PIECE OF PAPER
	JSP AC3,GET2Q
	MOVEI AC3,LEENQ2(DAT)
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	MOVEI AC3,2
	ADDM AC3,LEENQ2(DAT)
	HRR AC3,DAT
	HRLI AC3,LERELE
	MOVEM AC3,QWAKE(AC1)
	MOVEM AC3,QWAKE(AC2)
	HRLM UUO,(AC1)		; PUT IN ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HRLM UUO,(AC2)
	MOVEI AC3,PPXFR		; THE I-LEVEL SUBROUTINE ADDRESS
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	EXCH DAT,UUO		; PICK UP THE NUMBER OF THE LINE AT THE TOP OF THE PAGE
	PUSHJ P,POSLIN
	EXCH DAT,UUO
	HRLM AC3,QLINE(AC1)	; PUT IN THAT AS OUR STARTING LINE NUMBER
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VPOS(UUO)	; PICK UP THE CURRENT POSITION OF THE BOTTOM OF THE PAGE
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
Q2BLCK:	PUSHJ P,QBLOCK		; QUEUE THEM UP
	POP P,AC1
	JRST QBLOCK		; QUEUE UP THE LAST TASK AND LEAVE

LERFP1:	SETOM GLTCH(UUO)	; FORCE THE PAGE PRINTER TO REFRESH NEXT TIME AROUND
	POPJ P,

GET2Q:	
	PUSHJ P,GETQ		; OTHERWISE, GET A TASK BLOCK TO DO IT OURSELVES
	PUSH P,AC1
	PUSHJ P,GETQ
	HRRZ AC2,(P)
	SETZM QFIELD(AC1)	; SEND THESE OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	JRST @AC3

LERELE:		;REFRESH LINE EDITOR
	EXCH DAT,ITEM
	PUSHJ P,QLETXT		;QLETXT IS IN LINED
	EXCH DAT,ITEM
	POPJ P,

PPCLB:	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /CURPP CLOBBERED AT LERELE
/
	DEBCHE
	POPACS
	POPJ P,
         ; HERE IS THE MIGHTY LINE EDITOR AND CURSOR GENERATOR.
; THIS ROUTINE SINGLEHANDEDLY SENDS OUT LINE EDITOR TRANSFERS, LINE EDITOR
; ERASURES, ALL CURSORS AND ALL CURSOR ERASURES.

^DPLED:	HGMAC(33)
	SKIPE LEENQ(DAT)	; DO WE HAVE SOMETHING IN THE QUEUE ALREAD
	POPJ P,			; YES, THIS ISN'T SUPPOSED TO HAPPEN!
	HRRZ UUO,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER QUEUE?
	JRST DPYTIM		; YES, COME BACK LATER
	CONO PI,SCNOFF		;FREEZE EVERYTHING
	MOVE AC1,VPOS(UUO)	; ASSUME WE ARE GOING IN THE USUAL POSITION
	MOVEM AC1,LELINE(DAT)
	MOVE AC1,DPHPOS(UUO)
	ADD AC1,LNLNGT(UUO)
	MOVEM AC1,PPHPOS(DAT)	;INITIALLY ASSUME LINE EDITOR X = PP X
	SKIPL AC3,LEPOS(DAT)
	JRST DPLEVS
	LDB AC3,[POINT 11,AC3,21]
	TRNE AC3,1=10		; EXTEND SIGN BIT
	OR AC3,[-1=10]
	PUSHJ P,POSLI2
	MOVEM AC3,LELINE(DAT)
	SETZB AC1,PPHPOS(DAT)	;NOW LINE EDITOR X IS ALWAYS ZERO
DPLEVS:	MOVEI AC3,LEENQ(DAT)	; GET ADDRESS OF COUNT WORD
	MOVEM AC3,SC(UUO)	; USE IT TO COUNT DOWN OUR TASKS
	MOVE AC3,PRGNUM(DAT)	; PICK UP DPY NUMBER
	SKIPG J,LETAB(AC3)	; IS THE LINE EDITOR CURRENTLY INITIALIZED??
	JRST DPLGCP		; YES, GET ITS POSITION FROM THE CHARACTER COUNT
                                                     ; HERE WE SET UP THE CURSOR POSITION AND START ON THE DECISION TREE

DPLGC2:	MOVEM AC1,CHP(DAT)	; SAVE THE HORIZONTAL POSITION
	MOVE AC1,LELINE(DAT)
DPLGC1:	MOVEM AC1,CVP(DAT)	; AND THE VERTICAL POSITION
	MOVE AC1,LELINE(DAT)	; GET VERTICAL POSITION
	CAMN AC1,LEVP(DAT)	; HAS THE VERTICAL POSITION OF THE LINE EDITOR CHANGED?
	JRST DPTLE1		; NO, SEE IF ANYTHING ELSE HAS CHANGED.
	PUSHJ P,DPEC		; ERASE THE LINE EDITOR CURSOR
	PUSHJ P,DPEOPC		; ERASE THE PAGE PRINTER CURSOR
	PUSHJ P,DPWT		; WRITE OUT THE TEXT AGAIN.
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR POSITION
	CAMN AC1,LELINE(DAT)	; IS IT THE SAME AS THE PAGE PRINTER POSITION?
	JRST DPTL14		; YES, WRITE OUT BOTH CURSORS ON THE SAME LINE
	PUSHJ P,DPWC		; NO, WRITE OUT THE LINE EDITOR CURSOR
	PUSHJ P,DPWPC		; THEN WRITE OUT THE PAGE PRINTER CURSOR
	JRST DPTLE5		; GO UPDATE STATE OF HISTORY TO REFLECT OUR TRANSFERS.

DPTL14:	PUSHJ P,DPWB		; SAME LINE, WRITE OUT BOTH CURSORS AT ONCE
	JRST DPTLE5

DPLGCP:	ADD AC1,LEHPOS(DAT)	; ADD IN LINE EDITOR CURSOR HORIZONTAL POSITION
	JUMPE AC1,DPLGC2	; IF NO DISTANCE INTO LINE, SET POSITIONS TO ZERO
	IDIV AC1,LNLNGT(UUO)	; CONVERT TO NUMBER OF LINES AND DISPLACEMENT INTO LAST LINE
	ADD AC1,LELINE(DAT)	; ADD IN STARTING LINE NUMBER
	MOVEM AC2,CHP(DAT)	; THE REMAINDER IS THE HORIZONTAL POSITION
	JRST DPLGC1		; AND WE NOW HAVE IT ALL!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ; WE GET HERE IF THE VERTICAL POSITION OF THE LINE EDITOR HAS NOT CHANGED.
; WE CHECK IF ANYTHING ELSE ABOUT THE LINE MIGHT HAVE CHANGED.

DPTLE1:	JUMPGE J,DPTL1A		;DON'T BOTHER CHECKING EMPTY EDITOR
	MOVE AC1,PPHPOS(DAT)
	EXCH AC1,LSTHP(DAT)
	CAMN AC1,LSTHP(DAT)	;SEE IF LE HAS MOVED HORIZONTALLY
	JRST DPTL1A		;NO
	PUSHJ P,LEFIX		;YES - RECALCULATE TABS & LONG-LINE CRLFS
	SETOM LETXC(DAT)	;TEXT NOW NEEDS WRITING
DPTL1A:	MOVE AC1,NCRS(DAT)	; WE GET HERE IF THE VERTICAL POSITION IS THE SAME
	CAMGE AC1,LENCRS(DAT)	; NOW HAS THE LINE SHRUNK ANY?
	PUSHJ P,DPEOSL		; YES, ERASE LINES PAST FIRST ONE.
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR VERTICAL POSITION
	CAME AC1,LECVP(DAT)	; HAS THE CURSOR VERTICAL POSITION CHANGED?
	JRST DPTLE2		; YES, SEE HOW MUCH AND WHERE IT IS NOW.
	MOVE AC1,CHP(DAT)	; IF THE VERTICAL POSITION IS THE SAME,
	CAME AC1,LECHP(DAT)	; THEN HOW ABOUT THE HORIZONTAL POSITION?
	JRST DPTLE3		; DIFFERENT, GO SEND OUT A NEW ONE.
	MOVE AC1,PPHPOS(DAT)	;SEE IF PP CURSOR MOVED
	CAME AC1,LEHP(DAT)
	JRST DPTLE6		; YES, GO SEND IT OUT AGAIN
	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID THE LINE EDITOR MISS A BEAT DUE TO AN INVALID BUFFER?
	JRST DPTL12		; YES, SEND OUT THE TEXT AGAIN
	SETZM LECLK(DAT)	; NO, NOTHING AT ALL TO DO!
	CONO PI,SCNON
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ; LINE EDITOR DECISION TREE. WE GET HERE IF THE LINE EDITOR CURSOR HAS NOT
; MOVED, BUT THE PAGE PRINTER CURSOR HAS(???)

DPTLE6:	MOVE AC1,CVP(DAT)	; ARE THE TWO CURSORS ON THE SAME LINE?
	CAME AC1,VPOS(UUO)
	JRST DPTLE7		; NO, THEY CAN BE SENT OUT SEPARATELY.
DPTLE9:	PUSHJ P,DPWB		; YES, SEND OUT BOTH
	JRST DPTLE4

DPTLE7:	PUSHJ P,DPWPC		; WRITE OUT THE PAGE PRINTER CURSOR ALONE
	JRST DPTLE4		; DO TEXT CHECK AND LEAVE

DPTLE2:	MOVE AC1,LELINE(DAT)	; WE COME HERE IF THE CURSOR VERTICAL POSITION HAS CHANGED
	CAME AC1,LECVP(DAT)	; IS THE OLD VERTICAL POSITION THE SAME AS THE PAGE PRINTER?
	PUSHJ P,DPEC		; NO, ERASE THE OLD CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP VERTICAL POSITION AGAIN
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION?
	JRST DPTLE9		; YES, SEND OUT BOTH CURSORS
DPTLE8:	PUSHJ P,DPWPC		; NO, SEND OUT THE PAGE PRINTER'S
DPTL11:	PUSHJ P,DPWC		; SEND OUT THE LINE EDITOR CURSOR TOO
	JRST DPTLE4

DPTLE3:	PUSHJ P,DPEC		; ERASE THE CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP THE VERTICAL POSITION
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION
	JRST DPTLE9		; YES, SEND THEM BOTH OUT
	PUSHJ P,DPWC		; WRITE OUT OUR CURSOR
	MOVE AC1,PPHPOS(DAT)	;GET PP CURSOR POS
	CAME AC1,LEHP(DAT)	; IS IT THE SAME AS THE CURRENT POSITION?
	PUSHJ P,DPWPC		; NO, WRITE OUT ANOTHER PAGE PRINTER CURSOR
	JRST DPTLE4		; YES, NO NEED TO WRITE A NEW ONE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ; EVERYBODY COMES HERE TO EXIT

DPTLE4:	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID I-LEVEL MISS DUE TO BUFFER INVALID?
DPTL12:	PUSHJ P,DPWT		; YES, QUEUE UP A TEXT REQUEST
DPTLE5:	MOVE AC1,LELINE(DAT)	; SAVE NEW STATE OF LINE EDITOR AND CURSORS
	MOVEM AC1,LEVP(DAT)
	MOVE AC1,PPHPOS(DAT)
	MOVEM AC1,LEHP(DAT)
	MOVE AC1,NCRS(DAT)	; NUMBER OF CRLFS IN LINE TOO
	MOVEM AC1,LENCRS(DAT)
	MOVE AC1,CVP(DAT)	; CURSOR VERTICAL POSITION
	MOVEM AC1,LECVP(DAT)
	SETZM LETXC(DAT)	; CLEAR THE FLAGS
	SETZM LEMISS(DAT)
	MOVE AC1,CHP(DAT)	; CURSOR HORIZONTAL POSITION
	MOVEM AC1,LECHP(DAT)
	CONO PI,SCNON
	POPJ P,			; BYE NOW. Y'ALL HAVE A GOOD TIME!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ; THIS ROUTINE QUEUES UP A LINE EDITOR TEXT REQUEST

DPWT:	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE AGAIN
	MOVEI AC3,LEXFR		; CALL THE LINE EDITOR I-LEVEL ROUTINE
	HRRM AC3,(AC1)		; PUT IT IN THE DISPATCH ADDRESS OF EACH TASK BLOCK
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION OF LINE EDITOR BUFFER
	HRLM AC3,QLINE(AC1)	; START THE TRANSFER HERE
	HRLM AC3,QLINE(AC2)
	HRLM DAT,(AC1)		; PUT IN ADDRESS OF DPY PROGRAM HEADER
	HRLM DAT,(AC2)
	ADD AC3,NCRS(DAT)	; GET NUMBER OF LAST LINE OF TRANSFER
DPWT1:	HRRM AC3,QLINE(AC1)	; SET THAT AS LAST LINE
	HRRM AC3,QLINE(AC2)
	SETZM QFIELD(AC1)	; SEND OUT TASKS OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	HRLI DAT,DPLED		; MAKE UP A CLOCK REQUEST WORD
	MOVEM DAT,QWAKE(AC1)
	MOVEM DAT,QWAKE(AC2)
	SKIPN AC3,SC(UUO)	; IS THERE A COUNT WORD?
	JRST DPWT2		; NO, DON'T BOTHER
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
DPWT2:	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1		; GET THE ADDRESS OF THE SECOND ONE
	JRST QBLOCK		; QUEUE IT UP TOO.
                                                                                     ; THIS ROUTINE ERASES THE OLD SECOND LINE OF THE LINE EDITOR

DPEOSL:	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1
	PUSHJ P,GETQ
	MOVE AC2,(P)
	MOVEI AC3,ERASE
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION
	ADD AC3,NCRS(DAT)	; ADD IN LENGTH OF TRANSFER
	ADDI AC3,1		; BUMP LINE NUMBER TO ONE PAST THE CURRENT LAST LINE
	HRLM AC3,QLINE(AC1)	; PUT THAT IN AS STARTING AND ENDING LINE
	HRLM AC3,QLINE(AC2)
	MOVE AC3,LEVP(DAT)	; PICK UP LAST VERTICAL POSITION
	ADD AC3,LENCRS(DAT)	; ADD IN LENGTH OF LAST TRANSFER
DPEOS1:	HRLM UUO,(AC1)		; PUT IN ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HRLM UUO,(AC2)
	JRST DPWT1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ; THIS ROUTINE ERASES THE OLD CURSOR

DPEC:	SKIPA AC2,LECVP(DAT)	;OLD POSITION
DPEOPC:	MOVE AC2,LEVP(DAT)	;SAME THING FOR PP CURSOR
	JUMPL AC2,CPOPJ		;WARN'T NONE
	PUSHJ P,GETQ
DPEC1:	HRLM AC2,QLINE(AC1)	; PUT THAT IN AS STARTING LINE
;	ADDI AC2,1		; BUMP IT BY ONE
	HRRM AC2,QLINE(AC1)	; FOR PESSIMISM
	SETOM QHPOS(AC1)	; CLEAR THE HORIZONTAL POSITION, INDICATING CURSOR ERASURE
DPEC2:	SETZM QFIELD(AC1)	; GOING OUT ON FIELD 1
	HRLI DAT,DPLED
	MOVEM DAT,QWAKE(AC1)	; WAKE UP THE LINE EDITOR DECISION TREE WHEN DONE
	MOVE AC3,SC(UUO)	; COUNT THROUGH OUR COUNTER TOO
	MOVEM AC3,QCOUNT(AC1)
	SKIPE SC(UUO)		; IS THERE A COUNT WORD?
	AOS @SC(UUO)		; YES, BUMP IT BY ONE
	HRLM UUO,(AC1)		; SAVE THE PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVEI AC3,CURSOR	; USE THE CURSOR SUBROUTINE
	HRRM AC3,(AC1)
	JRST QBLOCK		; QUEUE UP THE REQUEST
                                                                                                                                                                                                                                                                                                                                                                                                                                             ; THESE ROUTINES QUEUE UP THE VARIOUS COMBINATIONS OF CURSORS THAT MAY ARISE.

DPWPC:	PUSHJ P,GETQ		; GET A TASK BLOCK FOR THE PAGE PRINTER'S CURSOR
	MOVE AC2,LELINE(DAT)	; GET IT'S VERTICAL POSITION
	MOVE AC3,PPHPOS(DAT)
DPWPC1:	SETOM QHPOS(AC1)	; CLEAR OUT ONE OF THE HORIZONTAL POSITION WORDS
DPWPC2:	HRLM AC2,QLINE(AC1)	; STORE THE STARTING LINE NUMBER OF THE TRANSFER
;	ADDI AC2,1		; FOR SAFETY, MAKE IT LOOK LIKE IT IS TWO LINES LONG
	HRRM AC2,QLINE(AC1)	; AND STORE THAT AS THE DESTINATION LINE NUMBER
	HRLM AC3,QHPOS(AC1)	; STORE THE HORIZONTAL POSITION
	JRST DPEC2		; FINISH QUEUEING UP THE BLOCK

; THIS ROUTINE QUEUES UP A LINE EDITOR CURSOR ONLY.

DPWC:	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVE AC2,CVP(DAT)	; PICK UP THE CURSOR VERTICAL POSITION
	MOVE AC3,CHP(DAT)	; GET THE HORIZONTAL POSITION
	JRST DPWPC1		; LET THE ABOVE ROUTINE DO ALL THE WORK

; THIS ROUTINE QUEUES UP A TRANSFER WITH TWO CURSORS ON THE SAME LINE

DPWB:	PUSHJ P,GETQ
	MOVE AC2,LELINE(DAT)
	MOVE AC3,CHP(DAT)	; PICK UP THE LINE EDITOR CURSOR'S HORIZONTAL POSITION
	HRRM AC3,QHPOS(AC1)	; PUT IT IN AS ONE OF THE HORIZONTAL POSITIONS INVOLVED
	MOVE AC3,PPHPOS(DAT)	;GET PP CURSOR POS
	JRST DPWPC2		; USE IT TOO.
                                                           ;QBLOCK	  HERE IS THE MAGIC SCHEDULING QUEUE ROUTINE
; IT IS CALLED WITH THE ADDRESS OF A TASK BLOCK IN AC1. SAID BLOCK
; MUST HAVE QLINE AND QFIELD SET, BECAUSE THE BLOCK IS MERGED INTO
; THE QUEUE STRUCTURE IN THE RIGHT PLACE ON THE BASIS OF THOSE DATA.

;    BLOCKS CALLED "FRAMES".  EACH FRAME HAS A POINTER TO A LIST OF ONE OR
; MORE TASK BLOCKS, ALL OF WHICH HAVE THE SAME FIELD (EITHER EVEN OR ODD).
; THE TASK BLOCKS ARE LISTED IN ASCENDING ORDER OF LINE NUMBER. IN GENERAL,
; THE LIST OF FRAMES ALTERNATES BY FIELD PARITY, THE EXCEPTION BEING 
; "MISSING" FRAMES.  FRAME BLOCK FORMAT IS:
;
; 		XWD 0,<POINTER TO NEXT FRAME, OR 0>
;	QLINE:	BITS 0-19 INDICATE WHICH LINES ARE USED BY TASK BLOCKS
;		  IN THIS FRAME.  BITS 0,1,2 FOR LINES 1&2,3&4,5&6, ETC.
;	QFIELD:	SAME AS IN A TASK BLOCK, 0 OR -1 FOR EVEN OR ODD FIELD.
;	QHPOS:	NOT USED
;	QLINK:	XWD 0,<ADDRESS OF 1ST TASK BLOCK>

QBLOCK:	HGMAC(32)
	MOVEI AC2,10		; SET FOR 8 TIMES THROUGH
	MOVEM AC2,QTIME(AC1)	; BEFORE WE DECLARE IT A LOSING TRANSFER
REQBLK:	HRRZ AC2,(AC1)
	CAIL AC2,PPXFR
	CAILE AC2,PPSTAR
	JRST QBLERR
	HLRZ AC2,(AC1)
	CAML AC2,MEMSIZ
	CAMLE AC2,RMEMSIZ
	JUMPN AC2,QBLERR	; IF THERE IS SOMETHING THERE NOT IN FREE STORAGE, ERROR!
	SKIPN INTACT(PID)	; IS SOME WISEASS CALLING US AT USER INTERRUPT LEVEL?
	JRST QBLCLC		; NO, ALL IS WELL.
	HRLI AC1,QBLCLK		; YES, PUT IN A CLOCK REQUEST TO DO THIS TASK AT REAL CLOCK LEVEL
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,			; PRETEND WE DID IT.
                                                                                                                                                                                                                                                                                                                                                                                                                     ; HERE WE SEE IF THE TASK IS AN EASY OUTSIDER.
; IF IT IS NOT, WE MAKE UP A MASK FOR THE NUMBER OF
; LINES IT COVERS.

QBLCLK:	HRRZ AC1,DAT		; PICK UP THE TASK BLOCK ADDRESS
QBLCLC:	PUSH P,TAC		; SAVE THE WORLD
	PUSH P,TAC1
	PUSH P,DAT
	PUSH P,UCHN
	PUSH P,CHR
	HLRE DAT,QLINE(AC1)	; PICK UP STARTING POSITION
	HRRE UCHN,QLINE(AC1)	; AND THE ENDING LINE NUMBER
	JUMPLE UCHN,QOOB	; IF ENDING LINE IS OUT OF BOUNDS, THIS IS AN EASY OUTSIDER
	SKIPN DDOFF		; IF DD IS BEING MAINTAINED, PRETEND THE TRANSFER IS OUT OF BOUNDS
	CAILE DAT,=40		; OR IF STARTING LINE IS BELOW SCREEN . . .
	JRST QOOB		; IS AN EASY OUTSIDER
	CAIG DAT,(UCHN)		; IS THE STARTING LESS THAN THE FINISHING?
	AOJA UCHN,QBLGO		;CAN'T MAKE NEXT LINE
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ /STARTING LINE LESS THAN FINISHING LINE AT QBLOCK
/]
	-1
	POPACS
QBLGO:	SETZ TAC,		; HERE WE MAKE A 20-BIT MASK, IN BITS
	SETO TAC1,		;	0-19 OF TAC, WHERE EACH BIT
	ADDI DAT,1		;	REPRESENTS 2 LINES, AND IS ON
	ADDI UCHN,1		;	IF EITHER LINE IS TO BE WRITTEN
	LSH DAT,-1
	LSH UCHN,-1
	SUBM DAT,UCHN
IFN FTDDSTAT,<			;ONLY IF COUNTING STATISTICS
	ADDM	UCHN,NDDLCT	;COUNT  -(TOTAL NUMBER OF LINES QUEUED)
	AOS	NDDXCT		;COUNT TOTAL NUMBER OF TRANSFERS QUEUED.
	CAML	UCHN,[-2]
	AOS	NDDL1C		;COUNT 1 AND 2 LINE TRANSFERS.
>
	ROTC TAC,-1(UCHN)
	MOVN UCHN,DAT
	ROT TAC,1(UCHN)		; C(TAC) IS THE PROPER 20-BIT MASK
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ; HERE WE SCAN THE QUEUE SYSTEM LOOKING FOR A FRAME WITH SOME FREE LINES

QBL1:	MOVE DAT,QFIELD(AC1)	; WE WILL ENTER THE TASK ON ITS FIELD
	MOVE AC3,QLINE(AC1)	; MERGE BY LINE NUMBER
	MOVE AC2,1		; SET THE FIELD SAVED WORD TO DIFFERENT FROM ANY LEGAL FIELD
	MOVEM AC2,DDLFD
	SETZB AC2,DDLST		; NOTE THAT THERE IS NO LAST FRAME
	EXCH AC2,DDQUE		; PICK UP (SHUDDER!) THE ENTIRE QUEUE STRUCTURE
	JUMPE AC2,QBL3		; IF THERE ISN'T ANY, MAKE UP ONE FROM SCRATCH.
	MOVEM AC2,DDSQ		; IF THERE IS ONE, SAVE IT FIRST.
CNXTFR:	CAME DAT,QFIELD(AC2)	; IS THIS FRAME ON THE RIGHT FIELD?
	JRST QBL4		; NO, MOVE ON TO NEXT FRAME
	TDNE TAC,QLINE(AC2)	; YES, IS THERE ROOM ON THIS FRAME?
	JRST QBL8		; NO, GO ON TO NEXT FRAME
	ORM TAC,QLINE(AC2)	; YES, MARK OUR LINES AS CLAIMED
QBL6:	HRRZ CHR,QLINK(AC2)	; PICK UP ADDRESS OF TASK LIST FOR THIS FRAME
	JUMPE CHR,QBL7		; NONE THERE, ANNEX OUR TASK
	MOVE AC2,CHR		; SAVE THIS TASK BLOCK ADDRESS FOR ANNEXATION PURPOSES
	CAMLE AC3,QLINE(AC2)	; NOW, DO WE GO ABOVE THIS BLOCK?
	JRST QBL6		; NO, TRY NEXT BLOCK
	HRRM AC2,QLINK(AC1)	; YES, LINK US IN BETWEEN THESE TWO BLOCKS
	HLRZ AC3,QLINK(AC2)	; PICK UP POINTER TO PREVIOUS TASK
	HRLM AC3,QLINK(AC1)	; MAKE OUR BACKWARD LINK POINT TO THE LAST BLOCK
	HRRM AC1,QLINK(AC3)	; MAKE THE LAST BLOCK POINT TO US
	HRLM AC1,QLINK(AC2)	; MAKE THE NEXT BLOCK'S REVERSE POINTER POINT TO US
	JRST QBLXIT		; PUT THE QUEUE STRUCTURE BACK AND LEAVE

QBL7:	HRRM AC1,QLINK(AC2)	; ANNEX US BY PUTTING OUR ADDRESS IN THE LAST BLOCK'S FORWARD POINTER
	HRLZM AC2,QLINK(AC1)	; AND POINT OUR REVERSE POINTER TO HIM
	JRST QBLXIT
                                                                                                                                                                                                                                                                                                                   ; WE GET HERE IF THE TASK IS ENTIRELY OUT OF BOUNDS

QOOB:	PUSHJ P,WAKEQ		; WAKE UP ANYONE WAITING.
	POP P,CHR		; RESTORE THE WORLD.
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
GIVQB:	JRST GIVQ

; WE GET HERE IF EITHER THE DISPATCH ADDRESS OR THE DATA BLOCK ADDRESS
; IS ILLEGAL.

QBLERR:	PUSH P,(AC1)
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL TASK AT QBLOCK - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	SUB P,[XWD 1,1]
	JRST GIVQ

WAKEQ:	SKIPE QCOUNT(AC1)	; IS THERE A COUNT HERE?
	SOSLE @QCOUNT(AC1)	; PERHAPS WE HAVE TO GO THROUGH THE WAKEUP RITUAL?
	POPJ P,			; NOT YET.
	SKIPN AC2,QWAKE(AC1)	; YES WE DO. PICK UP WAKEUP WORD
	POPJ P,
	TDNE AC2,[-100]		; IS IT A JOB NUMBER?
	JRST WAKEQ1		; NO, MUST BE A CLOCK REQUEST
	SKIPL JBTSTS(AC2)	; MAKE SURE HE IS STILL RUNABLE
	POPJ P,			; NO, LEAVE NOW
	MOVNI AC3,RUNQ		; PUT THAT JOB IN THE RUN QUEUE
	MOVEM AC3,JOBQUE(AC2)
	MOVEI AC3,QJOB(AC2)
	CONO PI,PIOFF
	SKIPE (AC3)
	JRST .+3
	EXCH AC3,QJOB
	HRROM AC3,@QJOB
	CONO PI,PION
	POPJ P,

WAKEQ1:	CONO PI,PIOFF		; STOP THE WORLD!
	IDPB AC2,CLKQ		; PUT IN THE CLOCK REQUEST
	CONO PI,PION
	POPJ P,
                                                                                                                                                  ; WE GET HERE WHEN THERE IS NO QUEUE AT ALL.

QBL3:	PUSHJ P,MAKFRM		; MAKE UP A NEW FRAME HEADER
	MOVEM AC1,DDSQ		; MAKE THIS THE NEW QUEUE
	JRST QBLXIT		; RESTORE ACCUMULATORS AND LEAVE.

; HERE IS A ROUTINE TO MAKE UP A NEW FRAME HEADER AND PUT THE CURRENT
; BLOCK IN IT AS ITS ONLY TASK.

MAKFRM:	PUSH P,AC1		; SAVE THE TASK BLOCK ADDRESS
	AOS NDDFRM		; COUNT ONE MORE FRAME CREATION
	PUSHJ P,GETQ		; GET A BLOCK FOR THE FRAME HEADER
	SETZM (AC1)		; LINK IT TO NOWHERE FOR NOW.
	MOVEM TAC,QLINE(AC1)	; PUT IN OUR MASK AS THE INITIAL MASK FOR THE FRAME
	MOVEM DAT,QFIELD(AC1)	; STORE THE FIELD WORD AS THIS FRAME'S FIELD
	POP P,AC2		; GET BACK THE TASK BLOCK ADDRESS
	HRRZM AC2,QLINK(AC1)	; POINT THE FRAME HEADER TO US
	HRLZM AC1,QLINK(AC2)	; AND OUR BACKWARD POINTER TO THE FRAME HEADER
	POPJ P,

; WE GET HERE IF THIS FRAME HAS THE WRONG FIELD

QBL4:	CAME DAT,DDLFD		; DOES THE LAST FRAME ALSO HAVE THE WRONG FIELD?
	SKIPN DDLST		; YES, DO WE EVEN HAVE A LAST FRAME?
	JRST QBL5		; NO TO EITHER, MOVE ON TO NEXT FRAME
	PUSH P,AC2		; SAVE POINTER TO CURRENT FRAME
	PUSHJ P,MAKFRM		; MAKE UP A BRAND NEW AND DIFFERENT FRAME
	MOVEM AC1,@DDLST	; INSERT IT BETWEEN THESE TWO
	POP P,(AC1)		; POINT IT TO THE SUCCESSOR
	JRST QBLXIT
                    ; HERE IS A ROUTINE THAT MOVES ON TO THE NEXT FRAME, IF THERE IS NO NEXT
; FRAME, IT MAKES UP A FRAME AND ANNEXES IT ONTO THE FRAME LIST.

QBL8:	MOVEM DAT,DDLFD		; SAVE THE FIELD OF THE FRAME
	JRST QBL9

QBL5:	SETCAM DAT,DDLFD	; SAVE THE FIELD OF THE FRAME (OPPOSITE FROM US)
QBL9:	HRRZM AC2,DDLST		; SAVE THE ADDRESS OF THE LAST FRAME
	HRRZ AC2,(AC2)		; PICK UP ADDRESS OF NEXT FRAME
	JUMPN AC2,CNXTFR	; IF THERE IS ONE, GO CHECK IT OUT.
	PUSHJ P,MAKFRM		; OTHERWISE, MAKE UP A NEW FRAME HEADER
	HRRZM AC1,@DDLST		; LINK US ON TO THE FRAME LIST
QBLXIT:	PUSHJ P,DDQCHK
	MOVE AC2,DDSQ		; ALL DONE, PUT THE TASK QUEUE BACK
	MOVEM AC2,DDQUE
	AOS NDDQUE		; MARK ONE MORE IN THE QUEUE
	POP P,CHR		; RESTORE THE ACCUMULATORS
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
	CONO PI,PIOFF		; STOP THE WORLD WHILE WE START UP THE DATA DISC
	SKIPN DDRUN		; IS THE DISK RUNNING?
	SETOM DDSTART		; NO, START IT UP NEXT TICK
	CONO PI,PION
	POPJ P,

;CHECK STATE OF DD QUEUE.  CALL BEFORE SETTING UP DDQUE FROM DDSQ
DDQCHK:	MOVEI DAT,DDSQ
DDQCH1:	SKIPN AC1,(DAT)
	POPJ P,
	CAMGE AC1,MEMSIZ
	JRST DDQCE3		;ADDRESS OUT OF BOUNDS
	MOVSI CHR,-1
	TDNN CHR,(AC1)
	TDNE CHR,QLINK(AC1)
	JRST DDQCE1		;EXTRANEOUS BITS ON IN FRAME
;reg	MOVEI CHR,77777
;	TDNE CHR,QLINE(AC1)
;	JRST DDQCE1		;EXTRANEOUS BITS IN QLINE
	SKIPE CHR,QFIELD(AC1)
	AOJN CHR,DDQCE2		;QFIELD NOT 0 OR -1
	HRRZ AC2,QLINK(AC1)	;POINTER TO TASK BLOCK
	JUMPE AC2,DDQCH4
	CAMGE AC2,MEMSIZ
	JRST DDQCE3
	PUSHJ P,DDTSCH		;CHECK LIST OF TASK BLOCKS
DDQCH4:	MOVE DAT,AC1
	JRST DDQCH1

DDQCE3:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FRAME BLOCK OR TASK BLOCK ADDRESS OUT OF BOUNDS /
	JRST DDCKR1

DDQCE2:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
	JRST DDCKR1

DDQCE1:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /EXTRANEOUS BITS ON /
DDCKR1:	PUSHJ P,DISMES
	ASCIZ /IN FRAME BLOCK AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS FRAME BLOCK AT /
	MOVE TAC,-17+DAT(P)
	PUSHJ P,DISLOC
DDCKR3:	PUSHJ P,DISMES
	ASCIZ /
FIND A WIZARD OR TYPE POPJ 3,$X
/
	PUSHJ P,DISFLUSH
	POPACS			;SO WE DON'T HAVE TO LOOK HARD TO FIND THE AC'S
	PUSHJ P,DDTCALL	
	JRST DDQCH4		;MAYBE IT'S POSSIBLE TO CONTINUE

DDCHER:	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /DATA DISK QUEUE INCONSISTENT
/
	JRST @-17+CHR(P)

;CHECK TASK LIST POINTED TO BY AC2 , AC1 POINTS TO FRAME IT COMES FROM
DDTSCH:	PUSH P,AC1
DDTSC2:	HRRZ CHR,(AC2)		;ADDRESS OF TASK ROUTINE
	CAIL CHR,DWPINI
	CAIL CHR,WHOINI
	JRST DDTSE4
	SKIPE CHR,QFIELD(AC2)
	AOJN CHR,DDTSE1		;QFIELD NOT 0 OR -1
	HLRZ CHR,QLINK(AC2)	;BACKWARDS LINK
	CAIE CHR,(AC1)
	JRST DDTSE2		;BACKWARDS LINK IS WRONG
	HRRZ AC1,AC2
	HRRZ AC2,QLINK(AC2)	;GET FORWARD LINK
	JUMPE AC2,DDTSC1	;END OF LIST
	CAMGE AC2,MEMSIZ
	JRST DDTSE3		;TASK LINK OUT OF BOUNDS
	JRST DDTSC2

DDTSC1:	POP P,AC1
	POPJ P,

DDTSE4:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /TASK ROUTINE ADDRESS OUT OF RANGE /
	JRST DDCKR2

DDTSE3:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FORWARD LINK OUT OF BOUNDS /
	JRST DDCKR2

DDTSE2:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /BACKWARS LINK WRONG /
	JRST DDCKR2

DDTSE1:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
DDCKR2:	PUSHJ P,DISMES
	ASCIZ /IN TASK BLOCK AT /
	MOVE TAC,-17+AC2(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS TASK BLOCK (MAYBE FRAME BLOCK) AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	JRST DDCKR3
                                                                                                                                                                                                                                                                                                                                                                                  ; HERE LIES THE INCREDIBLE INTERRUPT-LEVEL ROUTINES!
; LET THE READER BEWARE.

^DDSTRT:
	SETZM DDSTART
	SKIPN DDQUE		; IS THERE ANYTHING FOR US?
	JRST APRADD		; NO, LEAVE NOW
	SETOM DDRUN		; WE ARE NOW OFFICIALLY RUNNING.
	MOVEM TAC,DDSTAC	; SAVE THE ACCUMULATORS
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	MOVEM AC3,DDSAC3
	MOVEM DAT,DDSDAT
	EXCH P,APRPDL(PID)	; GET US A PDL TOO
	MOVEI AC3,APRADD	; WE WILL RETURN TO APRINT WHEN WE ARE DONE
	MOVEM AC3,DDRET
	MOVE AC1,DDQUE		; REMOVE THE FIRST FRAME FROM THE QUEUE ENTIRELY
NEWFRM:	MOVE AC2,(AC1)		; PICK UP THE ADDRESS OF THE NEXT FRAME
	MOVEM AC2,DDQUE		; MAKE IT THE NEW QUEUE
	MOVEM AC1,DDCURQ	; SAVE THIS ADDRESS AS OUR CURRENT FRAME
	HRRZ TAC,QLINK(AC1)	; PICK UP THE ADDRESS OF THE FIRST TASK IN THE FRAME
SCNLOP:	HRRZ AC2,QLINK(TAC)	; PICK UP THE ADDRESS OF THE NEXT TASK
	MOVEM AC2,DDNXT		; SAVE IT FOR FUTURE REFERENCE
	HLRZ DAT,(TAC)		; PICK UP THE DATA BLOCK ADDRESS
	HRRZ AC3,(TAC)		; AND THE ROUTINE ADDRESS
	CAIL AC3,DWPINI
	CAIL AC3,WHOINI
	CAIA			;LET'S NOT JUMP TO CONTUSIONS
	JRST (AC3)		; JUMP OFF TO THE ROUTINE
	PUSH P,CHR		;IN CASE WE WANT TO LOOK AT CHR
	MOVEI DAT,DDCURQ
	PUSHJ P,DDQCH1		;SHOULDN'T EVER RETURN
	PUSHJ P,DDTCALL
	JRST AUTOLOAD
                               ; ALL THE I-LEVEL ROUTINES RETURN TO HERE WHEN THEY ARE DONE

RESCAN:	SKIPE TAC,DDNXT		; IS THERE ANOTHER TASK IN THIS FRAME?
	JRST SCNLOP		; YES, SERVE IT NOW.
	HRRZ AC1,DDCURQ		; PICK UP THE FRAME HEAD WE WERE WORKING ON.
	HRRZ AC2,QLINK(AC1)	; SEE IF THERE ARE ANY TASKS LEFT ON IT.
	JUMPE AC2,DDEXIT	; NO, THEY MUST HAVE ALL SUCCEEDED
	HRLI AC2,DDREQ		; YES, PUT IN A CLOCK REQUEST TO REQUEUE THEM
	CONO PI,PIOFF		; THIS WAY, THEY WILL GET TRIED AGAIN
	IDPB AC2,CLKQ
	CONO PI,PION
DDEXIT:	PUSHJ P,GIVQ		; RELEASE THE FRAME HEADER
	SKIPE AC1,DDQUE		; SEE IF THERE IS ANOTHER FRAME
	JRST NEWFRM		; YES, DO IT.
	SETZM DDRUN		; NO, DIE QUIETLY
	CONO DDD,RESET		; CLEAR OUT THE BEAST
	MOVE TAC,DDSTAC		; RESTORE ALL OUR ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE DAT,DDSDAT
	EXCH P,APRPDL(PID)
	JSR DDRTN		; RETURN TO LOSER
                                                                                                                                                                                                                                                                                                                                                                                                                      ; THIS ROUTINE IS CALLED AT CLOCK LEVEL WITH A LIST OF TASKS THAT
; TIMED OUT OR LOST IN SOME OBSCURE WAY. WE JUST REQUEUE THEM AND
; TRY AGAIN.

DDREQ:	HRRZ AC1,DAT		; PICK UP THE TASK LIST
DDREQ1:	HRRZ DAT,QLINK(AC1)	; GET ADDRESS OF NEXT BLOCK ON LIST
	SOSG QTIME(AC1)		; HAVE WE TRIED TOO MANY TIMES
	JRST DDREQ2		; YES, DON'T REQUE IT.
	PUSHJ P,REQBLK		; REQUE THE TASK
DDREQ3:	JUMPE DAT,CPOPJ		; IF NO MORE TASKS, LEAVE
	MOVE AC1,DAT
	JRST DDREQ1

DDREQ2:	MOVE TAC,AC1
	PUSHJ P,DEQWAK		; WAKE UP CALLER
	JRST DDREQ3
                                                                                                     ; THIS ROUTINE TAKES A TASK OUT OF THE QUEUE AND WAKES UP ANYONE IF
; IT IS SUPPOSED TO.

DEQ:	;SOSGE NDDQUE		; NOTE ONE MORE GONE FROM QUEUE
	;SETZM NDDQUE		; DON'T LET IT GET NEGATIVE
	MOVE AC2,QLINK(TAC)	; PICK UP ADDRESS OF SUCCESSOR
	TRNE AC2,-1		; IS THERE ANYONE HOME?
	HLLM AC2,QLINK(AC2)	; YES, MAKE REVERSE LINK OF SUCCESSOR POINT TO OUR PREDECESSOR
	MOVSS AC2		; SAME DEAL FOR OTHER SIDE
	TRNE AC2,-1		; ANYONE HOME?
	HLRM AC2,QLINK(AC2)	; MAKE FORWARD LINK OF PREDECESSOR POINT TO SUCCESSOR
DEQWAK:	SKIPE QCOUNT(TAC)	; IS THERE A COUNT WORD SOMEWHERE?
	SOSLE @QCOUNT(TAC)	; YES, COUNT IT DOWN.
	JRST DEQ1		; NO COUNT OR COUNT NOT EXPIRED
	SKIPN AC1,QWAKE(TAC)	; PICK UP WAKEUP WORD
	JRST DEQ1		; IF NONE THERE, DON'T BOTHER
	TDNE AC1,[-100]		; IS IT A JOB NUMBER?
	JRST DEQ2		; NO, MUST BE CLOCK REQUEST
	SKIPL JBTSTS(AC1)
	JRST DEQ1		;DON'T REQUE IF ^C
	HLRZ AC2,(TAC)
	HRRE AC2,PRGJMP(AC2)	;CHECK WAIT FLAG
	JUMPGE AC2,DEQ1		;NOT WAITING - DON'T REQUE
	MOVNI AC2,RUNQ		; IS JOB NUMBER, PUT THIS JOB IN THE RUN QUEUE
	MOVEM AC2,JOBQUE(AC1)
	MOVEI AC1,QJOB(AC1)
	CONO PI,PIOFF
	SKIPE (AC1)
	JRST .+3
	EXCH AC1,QJOB
	HRROM AC1,@QJOB
	CONO PI,PION
	JRST DEQ1

DEQ2:	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
DEQ1:	MOVE AC1,TAC		; PUT TASK BLOCK ADDRESS IN AC1 FOR THE FOLLOWING ROUTINE
GIVQ:	PUSHJ P,SFSGIV
	DDFS
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ; PAGE PRINTER TRANSFERS

PPXFR:	SKIPL AC1,HEDPTR(DAT)	;LET'S SEE IF THIS IS A LEGAL PP
	CAML AC1,RMEMSI
	JRST ILLPP		;GARBAGEY HEADER ADR
	HLRZ AC1,PRGNUM(AC1)
	LDB AC3,[241000,,DDCW(DAT)]
	CAIE AC1,(AC3)
	JRST ILLPP		;DD CHNL DOESN'T MATCH
	SETZM DDSAV(DAT)	; INITIALIZE THE SAVE WORD
	SKIPE PPINV(DAT)	; IS THE TEXT VALID?
	JRST PPXFR2		; NO, FLUSH THE TRANSFER
	PUSHJ P,POSLIN		; GET NUMBER OF FIRST LINE ON PAGE IN AC3
	HLRE AC1,QLINE(TAC)	; PICK UP FIRST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)	; IS FIRST LINE OF TRANSFER BELOW CURRENT SCREEN?
	CAMGE AC1,AC3		; OR ABOVE FIRST LINE OF SCREEN?
	JRST PPXFR2		; YES, ABORT TRANSFER
	HRRE AC1,QLINE(TAC)	; SAME FOR LAST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)
	CAMGE AC1,AC3
	JRST PPXFR2
	HLRE AC3,QLINE(TAC)	; PICK UP STARTING LINE NUMBER
	SKIPG AC3		; IF IT IS ABOVE SCREEN . . .
	MOVEI AC3,1		; USE TOP OF SCREEN AS FIRST LINE
	MOVEI AC1,-1(AC3)	; GET NORMALIZED LINE NUMBER
	PUSHJ P,GLNADR		; GET LINE ADDRESS FROM LINE NUMBER
	ADD AC2,[XWD DISJMP,1]	; BUMP PAST CRLF ON LAST LINE
	MOVSM AC2,DDCW+2(DAT)	; PLACE JUMP TO TEXT IN CODE
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; CHECK THE FIELD
	ORI AC1,1		; PUT IT OUT ON THE ODD FIELD THIS TIME
	DPB AC1,[POINT 4,DDCW+1(DAT),23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCW+1(DAT),15]
	HRRE AC3,QLINE(TAC)	; PICK UP FINISHING LINE OF TRANSFER
	CAILE AC3,=40		; IS IT OFF THE SCREEN?
	MOVEI AC3,=40		; YES, USE THE LAST LINE ON THE SCREEN
	CAMN AC3,VPOS(DAT)	; IS THIS THE SAME AS THE VERTICAL POSITION OF THE PAGE PRINTER
	JRST PPXFR4		; YES, NO NEED TO SAVE ANY WORDS.
	ADDI AC3,1		; BUMP LINE POINTER BY ONE TO GET TO THE END OF THIS LINE
	PUSHJ P,GLNADR		; PICK UP THE ADDRESS OF THE END OF THAT LINE
	MOVE AC1,(AC2)		; PICK UP THE WORD AT THE END OF THE LINE
	MOVEM AC2,DDSPT(DAT)	; SAVE THE POINTER TO THE SAVED WORD.
	MOVEM AC1,DDSAV(DAT)	; STORE IT IN THE PAGE PRINTER CONTROL BLOCK
	MOVSI AC1,DDSAV(DAT)	; PICK UP ADDRESS OF SAVED WORD
	HRRI AC1,DISJMP		; PLACE A JUMP TO IT WHERE IT WAS IN THE BUFFER
	MOVEM AC1,(AC2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      PPXFR3:	MOVEI AC1,DDCW(DAT)	; PICK UP ADDRESS OF START OF TRANSFER
	CONO DDD,USUAL		; SET UP THE DATA DISC
	DATAO DDD,AC1		; SEND OUT THE ADDRESS
	PUSHJ P,ISYNC		; WAIT FOR IT
	JFCL
	JRST PPXFR1		; LOSE BIG, LEAVE THE TRANSFER IN THE QUEUE
PPXFR2:	PUSHJ P,DEQ		; WIN, TAKE THE TASK OUT OF THE QUEUE
PPXFR1:	MOVSI AC1,040000	; CLEAR THE 'NO ERASE' BIT IF WE SET IT
	ANDCAM AC1,DDCW(DAT)
	SKIPE AC1,DDSAV(DAT)	; RESTORE THE SAVED WORD, IF THERE IS ANY
	MOVEM AC1,@DDSPT(DAT)
	JRST RESCAN

PPXFR4:	MOVSI AC1,040000	; IF WE ARE AT THE BOTTOM OF THE SCREEN,
	CAMN AC2,VPOS(DAT)	; THEN DON'T ERASE THE REST OF THE LINE
	ORM AC1,DDCW(DAT)	; BECAUSE WE MIGHT BE ERASING PART OF THE LINE EDITOR
	JRST PPXFR3		; THE LINE EDITOR WILL ERASE THE REST OF THE LINE ITSELF

ILLPP:	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /ILLEGAL PP AT PPXFR
/
	DEBCHE
	POPACS
	PUSHJ P,DEQ
	JRST RESCAN
                                                                                                                                                                                                                                                                                                                                                                                       ; HERE IS THE ERASE CODE.

ERASE:	HLRE AC2,QLINE(TAC)	; PICK UP STARTING ADDRESS
	SKIPG AC2		; IS IT ABOVE THE SCREEN?
	MOVEI AC1,1		; YES, START FROM LINE 1
	MOVEI AC1,-1(AC2)	; CONVERT IT TO HARDWARE FORM
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS GO OUT ON?
	ORI AC1,1		; ODD FIELD
	DPB AC1,[POINT 4,DDERRS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDERRS+1,15]
	MOVE AC1,DDCW(DAT)	; PICK UP FUNCTION SELECT
	MOVEM AC1,DDERRS	; USE IT FOR THE ERASURE
	HRRE AC1,QLINE(TAC)	; GET ENDING LINE NUMBER
	CAILE AC1,=40		; IF OFF THE BOTTOM OF THE SCREEN . . .
	MOVEI AC1,=40		; THEN USE THE NUMBER OF THE LAST LINE ON THE SCREEN
	SUB AC2,AC1		; GET THE NUMBER OF LINES TO BE ERASED
	ADD AC2,[XWD DISJMP,DDCRLF+=39]
	MOVSM AC2,DDERRS+2	; JUMP TO THE POSITION IN THE ERASURES THAT CORRESPONDS TO THAT MANY LINES.
	CONO DDD,USUAL
	DATAO DDD,[DDERRS]
CWAIT:	PUSHJ P,ISYNC
	JFCL
	JRST RESCAN		; LOSE BIG, JUST DO ANOTHER TASK
	PUSHJ P,DEQ		; WIN, TAKE US OUT OF THE QUEUE
	JRST RESCAN		; AND GO DO SOMETHING ELSE.
                                                                                                                                                                                                                                               ; CURSOR TRANSFERS.

CURSOR:	MOVE AC1,[POINT 36,CURZWD-1,35]
	MOVEM AC1,CZPNT		; INITIALIZE LIST OF WORDS IN CURSOR CODE WE USED
	MOVE AC1,DDCW(DAT)	; PICK UP COMMAND WORD WITH FUNCTION SELECT IN IT
	TLO AC1,002000		; MAKE IT A GRAPHICS WORD
	MOVEM AC1,DDCURS	; AND USE IT AS OUR SELECT WORD
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER OF TRANSFER
	JUMPLE AC1,CDX		; IF OUT OF BOUNDS, FORGET IT
	CAILE AC1,=40		; IS IT OFF THE BOTTOM OF THE SCREEN?
	JRST CDX		; YES, RESTORE CURSOR CODE AND LEAVE
	IMULI AC1,=12
	SUBI AC1,2		; BACK UP THE LINE TO BEFORE THE NEXT TEXT
	DPB AC1,[POINT 4,DDCURS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCURS+1,15]
	HLRE AC1,QHPOS(TAC)	; PICK UP FIRST HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, MAKE UP CODE FOR IT
	HRRE AC1,QHPOS(TAC)	; PICK UP SECOND HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, COMPILE IT.
	CONO DDD,USUAL
	DATAO DDD,[DDCURS]
	PUSHJ P,ISYNC
	JFCL
	JRST CURS2		; UNFORGIVABLE LOSSAGE, TRY AGAIN LATER
CDX:	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
CURS2:	HRRZ AC1,CZPNT		; PICK UP POINTER TO CURSOR CODE ADDRESSES
	MOVEI AC2,2		; PICK UP A BLANK GRAPHICS WORD
CURS1:	CAIGE AC1,CURZWD	; ARE WE BACK TO THE START YET?
	JRST RESCAN		; YES, GO BACK FOR ANOTHER TASK
	MOVEM AC2,@(AC1)	; NO, CLEAR OUT THIS CURSOR
	SOJA AC1,CURS1		; BACK UP FOR THE NEXT ONE, IF ANY.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ; THIS ROUTINE MAKES UP THE CODE FOR A CURSOR.

CMAKE:	IMULI AC1,6		; CONVERT TO NUMBER OF BITS FROM LEFT MARGIN
	ADDI AC1,1		; THE UNIVERSAL FUDGE FACTOR STRIKES AGAIN!
	LDB AC2,[POINT 5,AC1,35]
	LSH AC1,-5		; IT IS NOW CONVERTED TO NUMBER OF WORDS AND BITS WITHIN LAST WORD
	ADDI AC1,DDCURS+2	; MAKE UP POINTER TO THE GRAPHICS WORD IN QUESTION
	IDPB AC1,CZPNT		; SAVE THIS ADDRESS SO WE CAN ZERO IT WHEN WE LEAVE
	MOVSI AC3,360000	; SHIFT OVER A CURSOR
	MOVNS AC2
	LSH AC3,(AC2)
	ANDCMI AC3,17		; ZERO OUT POSSIBLE OVERFLOW INTO OPCODE
	ORM AC3,(AC1)		; PUT THOSE BITS INTO THE LOCATION WE CALCULATED
	CAMLE AC2,[-=28]	; IS THERE TWO WORDS WORTH?
	POPJ P,			; NO, RETURN NOW
	ADDI AC1,1		; YES, BUMP POINTER
	IDPB AC1,CZPNT		; AND SAVE IT
	MOVSI AC3,360000	; MAKE UP ANOTHER CURSOR
	LSH AC3,=32(AC2)
	ORM AC3,(AC1)		; SET IT IN PLACE
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                             ; LINE EDITOR TRANSFERS

LEXFR:	HRRZ AC1,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	SKIPE PPNQT(AC1)	; IS THERE ANYTHING NOT COUNTED IN THE QUEUE
	JRST LEXFR2
	SKIPN PPENQ(AC1)	; IF ANYONE THERE, ABORT THE TRANSFER
	SKIPE LEINV(DAT)	; IS THE BUFFER VALID?
	JRST LEXFR2		; NO, SET 'MISSED IT' FLAG AND QUIT
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER
	JUMPLE AC1,LEXFR1	; IF STARTING LINE IS ABOVE SCREEN, FORGET IT
	SUBI AC1,1		; OTHERWISE WE WILL SHOW AS MUCH AS WE CAN
	IMULI AC1,=12		; CONVERT TO DD FLAVOR LINE ADDRESS
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS TRANSFER WANT TO GO TO?
	ORI AC1,1		; ODD FIELD, MAKE LINE ADDRESS ODD
	DPB AC1,[POINT 4,LEBFR+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,LEBFR+1,15]
	MOVE AC1,FCPOS(DAT)	; PICK UP NUMBER OF CHARACTERS IN BUFFER
	MOVE AC2,PRGNUM(DAT)	; GET DPY NUMBER
	SKIPL LETAB(AC2)	; IS THE LINE EDITOR INITIALIZED?
	SETZ AC1,		; NO, NO CHARACTERS IN IT
	JUMPN AC1,LEXFR3	; IF SOME CHARACTERS THERE, WE ARE SET.
	MOVE AC1,[ASCID /  
/]
	MOVEM AC1,LEBFR+2	; IF NONE, CLEAR OUT THE LINE WITH A SPACE AND A CRLF
LEXFR4:	MOVE AC1,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE AC2,DDCW(AC1)	; GET FUNCTION SELECT WORD
	MOVEM AC2,LEBFR		; USE IT FOR US
	MOVEI AC2,2		;COLUMN OFFSET
	SKIPGE LEPOS(DAT)
	JRST .+3		;THAT'S THE POS IF LEYPOS IN EFFECT
	ADD AC2,DPHPOS(AC1)
	ADD AC2,LNLNGT(AC1)	;ELSE FOLLOW PP
	DPB AC2,[POINT 8,LEBFR+1,7]
	CONO DDD,USUAL		; START UP THE BEAST
	DATAO DDD,[LEBFR]	; AND AWAY WE GO . . .
	PUSHJ P,ISYNC
	JRST RESCAN
	JRST RESCAN
	JRST LEXFR1		; WIN, DEQUEUE US AND LEAVE
                                                                                                                                                                                                                                                                                                                      ; WE GET HERE WHEN THE TRANSFER IS DONE OR ABORTED.

LEXFR2:	SETOM LEMISS(DAT)	; NOTE THAT WE MISSED THIS TRANSFER DUE TO BUFFER INVALID
LEXFR1:	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
	HRRZ AC2,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	HRRZ AC3,LLW(AC2)	; PICK UP LAST LINE TRANSFERRED
	CAME AC3,VPOS(AC2)	; IS THE PAGE PRINTER UP TO DATE?
	SKIPE PPENQ(AC2)	; YES, IS IT BUSY NOW?
	JRST RESCAN		; UP TO DATE OR BUSY
	HRLI AC2,REFLINE	; NOT UP TO DATE AND NOT BUSY, REFRESH ITS LINE
	CONO PI,PIOFF		; PLANT A CLOCK REQUEST
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST RESCAN

LEXFR3:	MOVEI AC1,LEBUF(DAT)	; GET THE ADDRESS OF THE LINE EDITOR TEXT
	HRLI AC1,DISJMP		; MAKE A JUMP TO IT
	MOVSM AC1,LEBFR+2	; AND PUT IT IN THE STARTUP CODE
	JRST LEXFR4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ; WHOLE SCREEN ERASURE AND AVAILABLE MESSAGE

WSE:	MOVE AC1,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE AC2,DDCW(AC1)	; GET FUNCTION SELECT WORD
	MOVEI AC3,13		; MAKE IT INTO AN ERASE REQUEST
	MOVEM AC2,WSERC+1	; PUT DOWN NORMAL COPY FIRST
	TLNE AC2,(1B5)		; WHAT FLAVOR?
	ORI AC3,4
	DPB AC3,[POINT 8,AC2,7]
	MOVEM AC2,WSERC
	CONO DDD,USUAL
	DATAO DDD,[WSERC]
	JRST CWAIT		; GO WAIT FOR TRANSFER AND LEAVE


; HERE IS THE WHO LINE ROUTINE.

WHOWRT:
	MOVE	AC1,QHPOS(TAC)	; PICK UP SAVED DPY NUMBER
	CAIE	AC1,DDAVLU	;AVAILABLE CHANNEL?
	JRST WHOWR2		;NO
	MOVEI DAT,AVLWHO	;GET PTR TO DD PROG
	MOVE	AC1,AVLVP	;GET DD CW TO RANDOM POSITION ON SCREEN
	JRST WHOWR3
WHOWR2:	SKIPN	FRETAB(AC1)	; IS OUR FREE STORAGE STILL HERE?
	JRST	WHOWR1		; NO, EXIT NOW
	MOVE	AC1,[CW 3,2,4,0,5,0]
WHOWR3:	SKIPE	QFIELD(TAC)
	ORI	AC1,1B23
	MOVEM	AC1,1(DAT)	; PUT IT IN THE DD PROG
	MOVEI	AC1,3(DAT)	; PUT RETURN ADDRESS INTO SYSTEM WHO LINE DPY CODE
	HRLM	AC1,DDDRET
	CONO	DDD,USUAL
	DATAO	DDD,DAT
	PUSHJ	P,ISYNC
	JFCL
	JFCL
	MOVE	AC1,QHPOS(TAC)	; GET DPY NBR/AVL CODE BACK
	CAIE	AC1,DDAVLU	; ARE WE DOING THE AVL CHN?
	JRST	WHOWR1		; NO
	HRLZI	AC2,20000	; YES, TURN OFF ERASE BIT IN CW
	ANDCAM	AC2,(DAT)
WHOWR1:	PUSHJ	P,DEQ
	AOS	WHOPTR		;COUNT ANOTHER FIELD DONE.
	JRST	RESCAN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ; USER DATA DISC PROGRAM . . .

POG:	HLRZ AC1,QHPOS(TAC)	;ADR OF CELL TO SET FIELD
	JUMPE AC1,POG2		;NONE
	HRLI AC1,140100		;MAKE BYTE PNTR TO FIELD BIT
	MOVE AC2,QFIELD(TAC)
	DPB AC2,AC1		;STORE FIELD
POG2:	CONO DDD,USUAL!EXECM
	MOVEI AC1,PRGCW(DAT)	; PICK UP ADDRESS OF START OF PROGRAM
	DATAO DDD,AC1		; SEND IT OUT
;DONT	MOVE AC1,TIME
;SAVE	SKIPN DPGTIM(DAT)
;TIME	MOVEM AC1,DPGTIM(DAT)	; NOTE TIME PROGRAM WENT OUT
	PUSHJ P,ISYNC
	JFCL
	JFCL
	HRRZ AC1,QHPOS(TAC)	;ADR OF LOSER'S COUNT CELL
	JUMPE AC1,.+2		;NONE
	SOS (AC1)
	MOVE AC1,QWAKE(TAC)	; PICK UP JOB NUMBER
	SOS JBTGLU(AC1)		; RELEASE US FROM CORE
IFN FTSTAT,<
	PUSH P,J
	MOVE J,AC1
	PUSHJ P,GLUSTT
	POP P,J
>
	SKIPN DPRLSF(DAT)	; ARE WE A DETACHED JOB?
	JRST POG1		; NO, LEAVE
	HRRZI AC1,(DAT)		; PICK UP ADDRESS OF DPY PROGRAM HEADER TO BE RETURNED
	HRLI AC1,POGCLK		; RETURN IT AT FREE STORAGE
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
POG1:	PUSHJ P,DEQ		; REMOVE THE TASK
	JRST RESCAN

POGCLK:	HRRZ AC1,DAT		; RETURN PROGRAM HEADER ITSELF
	JRST FSGIVE

; ROUTINE TO PRINT 'PAGE PRINTER HOLDING' MESSAGE

PPSTAR:	MOVE AC1,DDCW(DAT)
	MOVEM AC1,DDSTRS
	SETZ AC1,
	SKIPE QFIELD(TAC)
	MOVEI AC1,1		; SET LINE ADDRESS ODD
	DPB AC1,[POINT 1,DDSTRS+1,23]
	CONO DDD,USUAL
	DATAO DDD,[DDSTRS]
	JRST CWAIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ; ALL TRANSFERS COME BACK TO HERE WHEN THEY ARE DONE OR TIMED OUT

ISYNC:	POP P,DDDSP		; SAVE RETURN ADDRESS
	MOVEI AC3,6		; TIMEOUT IF NO INTERRUPT IN 8 TIX
	MOVEM AC3,DDCNT		; STORE IN THE COUNT WORD
	MOVEM DAT,DDCUR		; SAVE CONTROL BLOCK ADDRESS
	MOVEM TAC,DDCURT	; SAVE TASK BLOCK ADDRESS TOO.
	MOVE DAT,DDSDAT		; RESTORE ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE TAC,DDSTAC
	EXCH P,APRPDL(PID)	; RESTORE THE PDL
	JSR DDRTN		; AND RETURN TO WHEREVER

^DDINT:	SKIPN DDRUN
	JRST DDILL
	MOVEM AC3,DDSAC3	; SAVE ONE ACCUMULATOR
	MOVEI AC3,DDIXIT	; MAKE US RETURN THROUGH CH3 NEXT TIME OUT
	MOVEM AC3,DDRET		; SO WE CAN RE-ENABLE THE CHANNEL
	MOVE AC3,DDDSP		; PICK UP RETURN ADDRESS
	EXCH PID,APRID+P1PID	; PICK UP PROCESSOR IDENTIFICATION
	CONSZ 510,DDNXM
	JRST DDNX
	CONSO 510,LOSE		; DID DD MISS A WORD FROM MEMORY?
	JRST DDINT1		; NO, GO AHEAD
DDINT2:	CONO 510,RESET		; YES, STOP IT AMID-TRANSFER
	JRST DDCMR
                                                                                                                                                                                                                                                                                                                      ; DATA DISC NON-EX MEM TYPEOUT, ACCUMULATOR SAVER, AND CLOCK TIMEOUT ROUTINES

DDNX:	EXCH P,APRPDL(PID)
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ /DATA DISC NON-EX MEM
/]
	-1
	POPACS
	EXCH P,APRPDL(PID)
	JRST DDINT2


DDINT1:	ADDI AC3,2		; ALL OK, BUMP RETURN ADDRESS TO SUCCESS RETURN
DDCMR:	MOVEM DAT,DDSDAT	; SAVE THE REST OF THE ACCUMULATORS
	MOVEM TAC,DDSTAC
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	EXCH P,APRPDL(PID)
	MOVE DAT,DDCUR		; PICK UP ADDRESS OF CONTROL BLOCK
	MOVE TAC,DDCURT		; PICK UP ADDRESS OF TASK BLOCK
	HRLOI AC2,377777	; SET COUNT TO MAXIMUM WHEN NO TRANSFER IN PROGRESS
	MOVEM AC2,DDCNT
	JRST (AC3)		; RETURN TO LOSER

^DDCLK:	MOVEM AC3,DDSAC3	; STORE THIS ACCUMULATOR
	MOVEI AC3,APRADD	; MAKE US RETURN TO APRSER
	MOVEM AC3,DDRET		; NEXT TIME OUT
	MOVE AC3,DDDSP		; PICK UP RETURN ADDRESS
	ADDI AC3,1		; BUMP BY ONE TO NOTE THAT CLOCK TIMEOUT HAS HAPPENED
	CONO 510,RESET		; TIMED OUT, MUST BE HUNG. CLEAR IT OUT.
	JRST DDCMR

DDIXIT:	EXCH PID,APRID+P1PID	; RESTORE PID
	JEN @CH3		; DISMISS CHANNES
                                                                                                                                                                                                                     ; WE GET HERE IF WE GET AN INTERRUPT FROM THE DATA DISK AND
; OUR MAGIC FLAG INDICATES THAT NO TRANSFER WAS IN PROGRESS.

DDILL:	EXCH P,APRPDL+P1PID	; GET A PUSHDOWN LIST
	PUSHACS			; SAVE OUR ACCUMULATORS
	PUSHJ P,DISMES		; GIVE HARDWARE PEOPLE NASTY MESSAGE!
	ASCIZ/
UNEXPECTED DATA DISC INTERRUPT!!!
/
	CONO 510,RESET		; CLEAR ITS MIND
	POPACS			; RESTORE OUR ACCUMULATORS
	EXCH P,APRPDL+P1PID	; RESTORE P
	JEN @CH3
                                                                                                                                                                                                               ;DEFINITIONS FOR DATA DISC ALLOCATION

DDLNK__<600,,DDTAB>	;LINK OUT
DDALST__<60600,,DDTAB>	;ALLOC LIST (PERMANENT)
^DDUSR__<221000,,DDTAB>	;USER FLD
DDELNK__40		;LIST TERMINATOR (ZERO IS LEGAL VAL)
DDCLST__<600,,JB2SWP>	;LIST OF CHANNELS OWNED BY JOB

DDGBIT__100		;"GET" BIT IN UUO
DDSBIT__200		;"STATUS" BIT IN UUO
DDGMOD__50300		;WHOLE MODE FLD
^DDANYW__200000		;LET ANYONE WRITE
DDSMSK__600000		;MASK FOR USER SETTABLE BITS
DDUSR2__222000		;TO SET USER & CLEAR EXTRA BITS

;SPECIAL USER CODES

^DDAVLU__200		;AVAILABLE CHANNEL
^DDDETU__201		;DETACHED FROM SYS

;DEFINITIONS FOR VIDEO SWITCH ROUTINES

VDOP__330300		;OPCODE FLD FOR UUO
VDPERM__400000		;"PERMANENT" BIT - MUST BE SIGN
VDXBIT__400		;"EXTRA CHANNEL" BIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;INITIALIZATION FOR DATA DISC ALLOCATION AND VIDEO SWITCH
DDINI:	SETOM DDTAB
	MOVE TAC,[DDTAB,,DDTAB+1]
	BLT TAC,DDTAB+DDELNK		;CLEAR TABLE FOR DUPLICATION TEST
	MOVE TAC,[440600,,DDLIST]
	MOVEI AC2,DDELNK
DDINI1:	ILDB AC1,TAC
	SKIPL DDTAB(AC1)
	JRST 4,.		;OOPS - WE'VE BEEN HERE BEFORE
	MOVEM AC2,DDTAB(AC1)	;INITIALIZE DDTAB WITH ALLOC LIST & FREE LIST
	DPB AC1,[DDALST(AC2)]
	MOVEI AC2,(AC1)
	CAIE AC1,DDELNK
	JRST DDINI1
	MOVEI J,JOBN-1
	MOVEI TAC,
	DPB TAC,[DDCLST(J)]	;INIT JOB CHNL LISTS
	SOJG J,.-1
	MOVEI TAC,40
	MOVEM TAC,DDFCNT	;INIT FREE CHNL COUNT
	MOVSI TAC,200
	HRR TAC,AVLCHN
	PUSHJ P,DDCGET		;GET CHN FOR AVAIL MSG
	JRST 4,.
	MOVEI AC1,(TAC)
	PUSHJ P,VDBIT
	MOVEM AC3,AVLBIT
	MOVSI AC1,-DDNUM
DDINI2:	MOVEM AC3,VDMAP(AC1)	;MAP EVERYONE TO MSG
	CONO VDS,DPYNUM(AC1)
	DATAO VDS,AC3
	AOBJN AC1,DDINI2
	DPB TAC,[POINT 8,AVLWHO,15]
	PUSHJ P,WHOSYS		;INITIALIZE SYSTEM WHOLINE
	SETOM WHOKLU		;THIS MAKES WHOSER PUT THE MSG OUT
	POPJ P,
^DDAVST:
	MOVEI AC2,1
	SKIPN DDFCNT		;ARE THERE ANY CHANNELS FREE?
	MOVE AC2,[DDUNMS,,DISJMP]	;NO MAKE UNAVAIL MESSAGE HAPPEN
	SKIPN MAINTMODE
	SKIPE TTYLOK
	MOVE AC2,[XWD DDDMES,DISJMP]
	MOVEM AC2,DDWMES

	DATAI DSK,AC1		;CHOOSE A (RANDOM) NUMBER, ANY NUMBER
	ADD AC1,TIME
	IDIVI AC1,300
	ADDI AC2,10
	MOVEI AC1,(AC2)
	DPB AC2,[150300,,AVLVP]	;STORE LOW ORDER PART
	LSH AC2,-3		;REMOVE LOW ORDER PART
	DPB AC2,[240500,,AVLVP]	;STORE HI PART
	IDIVI AC1,=12		;CONVERT RASTER LINE TO TEXT LINE
	HRLI AC1,3(AC1)		;AVL MSG USES 4 DIFFERENT TEXT LINES
	MOVSM AC1,AVLLN
	HRLZI AC2,20000
	IORM AC2,AVLWHO	;TURN ON ERASE BIT TO FORCE ERASE BEFORE FIRST FIELD
	POPJ P,

DDLIST:	BYTE (6)37,36,35,34,33,32,31,30,27,25,24,23,7,22,11,12,26,5
	BYTE (6)13,17,2,14,10,1,20,21,16,15,6,4,3,0,DDELNK

^VDSYNC:0111213141567
                                                                                                 ;ALL-PURPOSE DD CHANNEL DIDDLING UUO:
;AC31-35 = CHAN, AC30 => NO SPECIFIC CHAN (CONSOLE CHAN FOR STATUS)
;AC28-29: 0-RELEASE, 1-GET, 2-GET STATUS, 3-SET STATUS
;AC29=1 => FAILURE POSSIBLE, SKIP ON SUCCESS
;AC0 PRIVATE CHAN, SET ON GET OR SET STATUS
;REST OF LH READ-ONLY STATUS BITS, RETURNED ON SINGLE-CHAN OPS OR GETTING CHAN:
;AC10-17 USE: 0=FREE, 1-77=JOB N, 100-177=TTY N-100+DDL0, 200-377 SPECIAL

^DDCHAN:DPB J,[DDUSR2,,TAC]
	LDB AC1,[DDGMOD,,TAC]
	ANDCMI TAC,-40
	PUSHJ P,@DDCDSP(AC1)
	JRST STOTAC
	AOS (P)
	JRST STOTAC

DDCDSP:	DDCREL
	DDAREL
	DDCGET
	DDAGET
	DDSGET
	DDCSGT
	DDSSET
	DDCSST

;RELEASE ALL CHANS OWNED BY JOB (ALSO CALLED ON RESET)

^DDAREL:PUSH P,TAC
	LDB TAC,[DDCLST(J)]
	SOJL TAC,TPOPJ
	HLL TAC,(P)
	MOVEI AC1,
	DPB AC1,[DDCLST(J)]	;CLEAR THE LIST HERE IN ONE SWELL FOOP
DDARL1:	LDB AC3,[DDLNK(TAC)]
	PUSHJ P,DDREL		;SO WE DON'T HAVE TO DO IT HERE
	HRRI TAC,(AC3)
	CAIE AC3,DDELNK
	JRST DDARL1
	JRST TPOPJ
                                                                                                                                                                                                                                                                                                                  ;RELEASE CHANNEL C(TAC)

DDCREL:	LDB AC2,[DDLNK(TAC)]	;HERE CHAN BELONGS TO JOB
	LDB AC1,[DDCLST(J)]	;& MUST BE DELINKED FROM JOB'S LIST
	CAIN AC1,1(TAC)
	AOJA AC2,[CAIL AC2,41
		MOVEI AC2,
		DPB AC2,[DDCLST(J)]
		JRST DDREL]
	SOJL AC1,DDREL
DDCRL1:	LDB AC3,[DDLNK(AC1)]
	CAIN AC3,(TAC)
	JRST [DPB AC2,[DDLNK(AC1)]JRST DDREL]
	MOVEI AC1,(AC3)
	CAIE AC1,DDELNK
	JRST DDCRL1
^DDREL:	LDB AC1,[DDUSR(TAC)]	;ENTER TO JUST RELEASE CHANNEL
	TSC AC1,TAC
	TRNE AC1,377
	JRST DDREL2		;DOESN'T BELONG TO HIM
	MOVEI AC1,(TAC)
	AOS AC2,DDFCNT
	CAIN AC2,1
	SETOM WHOKLU		;CHANGE TO AVAILABLE MESSAGE
	MOVSI AC2,377
	CONO PI,SCNOFF
	LDB AC1,[DDALST(AC1)]
	TDNE AC2,DDTAB(AC1)	;SCAN UP ALLOC LIST (ORDERED)
	JRST .-2
	LDB AC2,[DDLNK(AC1)]	;SO WE CAN PUT IN RIGHT PLACE IN FREE LIST
	DPB TAC,[DDLNK(AC1)]
	DPB AC2,[DDLNK(TAC)]
	HRRZS DDTAB(TAC)
^SCNONJ:CONO PI,SCNON
	POPJ P,

DDREL2:	TLNN TAC,300
	POPJ P,			;JUST SOME LOSER
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL DD RELEASE - TAC=/]
	DISARG OCT,<TAC-20(P)>
	[ASCIZ /
/]
	-1
	POPACS
	POPJ P,
                                                                                                                                                                                                          ;GET CHAN SPECIFIED BY TAC(31-35) IF FREE

^DDCGET:HLLZ AC3,TAC
	MOVEI AC1,(TAC)
	MOVSI AC2,377
	CONO PI,SCNOFF
	TDNN AC2,DDTAB(AC1)
	JRST DDCG1
	CONO PI,SCNON
	HLL TAC,DDTAB(AC1)	;TELL HIM HOW HE LOST
	POPJ P,

DDCG1:	LDB AC1,[DDALST(AC1)]	;IT'S FREE - SCAN FOR GUY POINTING TO IT
	TDNE AC2,DDTAB(AC1)
	JRST DDCG1
	IORM AC3,DDTAB(TAC)
	LDB AC3,[DDLNK(TAC)]	;SO WE CAN LINK IT OUT
	DPB AC3,[DDLNK(AC1)]
	CONO PI,SCNON
	MOVEI AC1,(TAC)
	JRST DDGET2

;GET ANY FREE CHAN

DDAGET:	HLLZ AC3,TAC
	CONO PI,SCNOFF
	MOVE AC1,DDFLST
	CAIN AC1,DDELNK
	JRST SCNONJ
	LDB AC2,[DDLNK(AC1)]
	MOVEM AC2,DDFLST
	IORM AC3,DDTAB(AC1)
	CONO PI,SCNON
	HRRI TAC,(AC1)
;COMMON CODE FOR BOTH FLAVORS OF GET. PUTS IN LIST IF GETTING FOR JOB.
;SETS AND ENFORCES PRIVACY BIT.
DDGET2:	SOSG DDFCNT
	SETOM WHOKLU			;SET NO CHANNELS LEFT MESSAGE
	TLNN TAC,300
	AOJA AC1,[LDB AC2,[DDCLST(J)]	;JOB - ADD TO ITS LIST
		DPB AC1,[DDCLST(J)]
		SOJGE AC2,[SOJA AC1,DDGET3]
		SOJA AC1,.+1]
	MOVEI AC2,DDELNK
DDGET3:	DPB AC2,[DDLNK(AC1)]
	AOS (P)
	JUMPGE TAC,CPOPJ	;THAT'S ALL IF HE'S NOT PARANOID
	MOVEI AC1,(TAC)		;ELSE FALL THRU
                                                                                                                                            ;ROUTINE TO THROW ALL SPIES OFF PRIVATE CHANNEL.

^DDFLSH:PUSHJ P,VDBIT
	PUSH P,TAC
	PUSH P,TAC1
	LDB TAC1,[DDUSR(AC1)]
	MOVSI TAC,-DDNUM+DPYNUM	;INCLUDE "SHADOW" CHANNELS HERE
DDFLS0:	TDNN AC3,VDMAP(TAC)	;HERE WE SCAN THE PERM MAPS
DDFLS3:	AOBJN TAC,DDFLS0
	JUMPGE TAC,DDFLS1
	CAIN TAC1,100(TAC)
	JRST DDFLS3
	PUSHJ P,VDSTR1
	ANDCAM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT1
	AOBJN TAC,DDFLS0
DDFLS1:	MOVSI TAC,-DDNUM
DDFLS2:	SKIPE AC2,LETAB+DPYNUM(TAC)	;HERE WE SCAN THE TEMP MAPS
	TDNN AC3,VDTMP(AC2)
DDFLS4:	AOBJN TAC,DDFLS2
	JUMPGE TAC,DDFLSX
	CAIN TAC1,100(TAC)
	JRST DDFLS4
	ANDCAM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT1
	AOBJN TAC,DDFLS2
DDFLSX:	POP P,TAC1
	JRST TPOPJ

;SEE IF THIS GUY CAN HACK THIS DD CHAN (AC1)
;0 SKIPS FREE. 1 SKIP LOSE. 2 SKIPS HE'S GOT IT.
DDCHEK:	LDB AC2,[DDUSR(AC1)]
	JUMPE AC2,CPOPJ
	AOS (P)
	HRRE AC3,JBTLIN(J)
	JRST VDCCK0

;GET STATUS & # OF CONSOLE CHAN, AC UNCHANGED IF NONE (NOT DD)
DDCSGT:	PUSHJ P,DDCFND
	POPJ P,
			;FALL THRU

;GET STATUS OF CHAN TAC(31-35)
DDSGET:	HLL TAC,DDTAB(TAC)
	POPJ P,

;FIND CONSOLE CHAN FOR JOB

DDCFND:	MOVE AC1,JBTLIN(J)
	TLNN AC1,DDDLIN
	POPJ P,
	JUMPL AC1,CPOPJ	;DETACHED
	HRRZ AC1,LETAB-DPYL0(AC1)
	HLR TAC,PRGNUM(AC1)	;PRETEND HE USED HIS CHAN AS ARG (PRESERVE LH)
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;SET STATUS OF CONSOLE CHANNEL

DDCSST:	PUSHJ P,DDCFND
	POPJ P,
			;FALL THRU

;HERE HE CAN SET THE STATUS OF A CHANNEL IF IT'S HIS

DDSSET:	MOVEI AC1,(TAC)
	PUSHJ P,DDCHEK
	POPJ P,
	POPJ P,
	MOVE AC2,DDTAB(AC1)
	MOVSI AC3,DDSMSK
	CONO PI,SCNOFF
	ANDCAM AC3,DDTAB(AC1)
	AND AC3,TAC
	IORB AC3,DDTAB(AC1)
	HLL TAC,AC3
	CONO PI,SCNON
	JUMPGE TAC,CPOPJ1
	JUMPL AC2,CPOPJ1
	AOS (P)
	JRST DDFLSH		;TURNING PRIVATE - FLUSH LOSERS

;MAKES UP BIT (AC3) FROM DD CHAN (AC1)
^VDBIT:	MOVNI AC2,(AC1)
	MOVSI AC3,400000
	LSH AC3,(AC2)
	POPJ P,

;THIS ROUTINE UPDATES BOTH PERMANENT & TEMPORARY (IF EXISTENT) MAPS
;WITH INTS OFF TO AVOID INCONSISTENT STATES
;TAC=CONSOLE #, @(P) IS DIDDLE INSTRUCTION
^VDSTRB:PUSHJ P,VDBIT
^VDSTR:	JUMPL TAC,VDSTRI
VDSTR1:	MOVEI AC2,VDMAP-VDTMP(TAC)
	CONO PI,SCNOFF
	XCT @(P)
	SKIPE AC2,LETAB+DPYNUM(TAC)
	XCT @(P)
	CONO PI,SCNON
	JRST CPOPJ1

VDSTRI:	TLNE AC1,-1
	HLLZ AC3,AC1	;PICK UP BITS PASSED, IF ANY
	SKIPN AC2,LETAB+DPYNUM(TAC)
	JRST CPOPJ1
	HRLI AC2,VPGACT
	CONO PI,PIOFF
	IDPB AC2,CLKQ		;SET TO DO PGACT AT CLK LEVEL
	CONO PI,PION
	SETOM LEACT(AC2)	;SO HEADER STAYS AROUND
	MOVEI AC2,PRGACT-VDTMP(AC2)	;MAKE PNTR TO PGACT BITS
	SKIPL @(P)	;SEE IF DIDDLING INSTR IS BOOLEAN
	HRR AC3,VDTMP(AC2)	;NOT BOOLEAN, COPY RH SO IT WON'T GET CLOBBERED
	XCT @(P)
	JRST CPOPJ1

;SET EITHER TEMPORARY OR PERMANENT MAPPING, DETERMINED BY
;SIGN BIT OF DSER (CALLED FROM VDSMAP ROUTINES)
VDSTRU:	JUMPL DSER,VDSTR
	SKIPE AC2,LETAB+DPYNUM(TAC)
	XCT @(P)
	JRST CPOPJ1

;OUTPUTS CURRENT MAPPING (TEMPORARY, IF EXISTENT, ELSE PERMANENT)
;FOR CONSOLE C(TAC)
^VDOUT:	JUMPL TAC,CPOPJ		;NO III'S HERE
VDOUT1:	SKIPN AC2,LETAB+DPYNUM(TAC)
	MOVEI AC2,VDMAP-VDTMP(TAC)
	CONO PI,SCNOFF
	CONO VDS,DPYNUM(TAC)	;THIS WRAPS AROUND TO "SHADOW" WITH TAC>DDNUM
	DATAO VDS,VDTMP(AC2)
	CONO PI,SCNON
	POPJ P,
                                               ;ALL-PURPOSE VDS DIDDLING UUO:
;RH(AC)=ADR
;AC11-17 = TTY#, 0 => OWN CONSOLE; AC9=1 => USE "SHADOW" CHAN INDICATED BY AC11-17
;AC0=1 => PERMANENT CHANGE, 0 => TEMP CHANGE (GOES AWAY ON RESET)
;FINAL STATUS (TEMP/PERM PER AC0) STORED IN AC, -1 IF TTY NOT DD.
;AC6-8 = OPCODE:
;	0 - NOP, NEVER SKIPS, USEFUL FOR GETTING STATUS ALONE
;	1 - SET MAP FROM C(ADR), SKIPS IF ENTIRELY SUCCESSFUL (NO PRIVACY PROBLEM)
;	2 - IOR MAP FROM C(ADR), SET ANALOG IF 0. SKIPS ON COMPLETE SUCCESS.
;	3 - ANDCAM MAP FROM C(ADR), CLEAR ANALOG IF 0. FAILS ONLY ON BAD TTY #.
;	4 - RESET MAP. IN TEMP MODE THIS RESETS TEMP_PERM. IN PERM MODE PERM MAP
;			IS SET TO MAIN CHANNEL ALONE. FAILS ONLY ON BAD TTY #.
;	5-7 ILLEGAL. CURRENTLY NO-OPS.

^VDSMAP:XCTR	XR,[MOVE DAT,(TAC)]
	LDB AC1,[VDOP,,TAC]
	CAIL AC1,NVDOPS
	POPJ P,
	MOVE DSER,TAC
	LDB TAC,[220700,,TAC]
	TLNE DSER,VDXBIT
	JRST VDMAP5
	JUMPN TAC,.+2
	HRRE TAC,JBTLIN(J)
	SUBI TAC,DDL0
	CAIGE TAC,DDNUM
	JUMPGE TAC,.+2
	JRST VDMAP4
	SKIPL VDDSP(AC1)
	JRST VDMAP2
	SKIPA AC2,JBTLIN(J)
VDMAP1:	MOVE AC2,JBTLIN(AC2)
	CAMN AC2,[-1]		;DETACHED?
	JRST VDMP1A
	CAIN TAC,-DDL0(AC2)
	JRST VDMAP2		;LET HIM BY IF IT'S HIS CHAN
	TLNE AC2,PTYLIN
	SKIPN AC2,PTYJOB-PTYL0(AC2)	;OR IF IT'S HIS VIA SOME PTY CHAIN
VDMP1A:	SKIPA AC2,JBTPRV(J)
	JRST VDMAP1
	TLNE AC2,UPGPRV		;OR IF HE HAS THE MAGIC PRIVILEGE
	JRST VDMAP2
	MOVE AC2,[TTYATC,,ASSCON+ASSPRG]
	SKIPE DDB,TTYTAB+DDL0(TAC)
	TDNN AC2,DEVMOD(DDB)
	JRST VDMAP2		;OR IF IT'S FREE
	LDB AC2,PJOBN
	CAIE AC2,(J)
	JRST VDMAP3
				;FALL THRU TO VDMAP2 IF HE OWNS THE CONSOLE
                                                                                                                                                                                                                                                                                                                                    VDMAP2:	HLL TAC,VDDSP(AC1)
	TLZ TAC,400000		;DON'T CONFUSE VDOUT, after all we're not a III
	PUSHJ P,@VDDSP(AC1)
	PUSHJ P,VDOUT
	TLNE TAC,200000		;DON'T SKIP IF NOT REQUESTED
	AOS (P)			;NOTE THIS BIT WAS CLEARED BY ANY FAILURE
VDMAP3:	TLNN DSER,VDPERM	;GIVE HIM APPROPRIATE FLAVOR OF STATUS
	SKIPN DAT,LETAB+DPYNUM(TAC)
	SKIPA TAC,VDMAP(TAC)
	MOVE TAC,VDTMP(DAT)
	JRST STOTAC

VDMAP5:	ADDI TAC,DDNUM		;HERE TO MAP "SHADOW" CHANNELS
	CAIGE TAC,DPYNUM+DDNUM
	JRST VDMAP2
VDMAP4:	XCTR	XW,[SETOM (UUO)]	;NOT DD - USE POSSIBLE BUT UNLIKELY VALUE TO FLAG THIS.
	POPJ P,

VDDSP:	CPOPJ1		;DON'T EVEN BOTHER WITH VDOUT
	600000,,VDSET
	600000,,VDIOR
	600000,,VDACM
	600000,,VDRST
NVDOPS__.-VDDSP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        VDSET:	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	MOVEM DAT,VDTMP(AC2)
	POPJ P,

VDIOR:	TRNN DAT,17
	JRST VDIOR1
	MOVEI AC3,17
	PUSHJ P,VDSTRU	;CLEAR ANALOG HERE SO THESE DON'T GET OR'ED
	ANDCAM AC3,VDTMP(AC2)
VDIOR1:	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	IORM DAT,VDTMP(AC2)
	POPJ P,

VDACM:	TRNE DAT,17
	TRO DAT,17	;ANYTHING IN ANALOG FIELD CLEARS IT ALL
	PUSHJ P,VDSTRU
	ANDCAM DAT,VDTMP(AC2)
	POPJ P,

VDRST:	JUMPL DSER,VDNORM
VDRST1:	SKIPN AC2,LETAB+DPYNUM(TAC)
	POPJ P,
	CONO PI,SCNOFF
	MOVE AC3,VDMAP(TAC)
	MOVEM AC3,VDTMP(AC2)	;SET TEMP MAP FROM PERM
	CONO PI,SCNON
	POPJ P,

^VDNORM:SKIPN AC2,LETAB+DPYNUM(TAC)
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)
	PUSHJ P,VDSTRB		;SET BOTH MAPS TO HIS CHAN OR AVAILABLE
	MOVEM AC3,VDTMP(AC2)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;ROUTINE TO BLESS BITS ABOUT TO BE TURNED ON FOR PRIVACY VIOLATION
;LOSING BITS ARE FLUSHED, AND SKIP FLAG IS CLEARED
VDWCHK:	MOVSI AC1,-40
VDWCHL:	JUMPGE DAT,VDWOK
	SKIPL DDTAB(AC1)
	JRST VDWOK
	HRRE AC3,JBTLIN(J)
	PUSHJ P,VDCCHK		;TRYING TO LOOK AT PRIVATE CHAN, SEE IF IT'S OK
	JRST VDWLUZ
VDWOK:	ROT DAT,1
	AOBJN AC1,VDWCHL
	ROT DAT,4
	TRNN DAT,17
	POPJ P,
	LDB AC1,[300,,DAT]
	IOR DAT,VDSYNC(AC1)
	POPJ P,

VDWLUZ:	TLZ DAT,400000
	TLZ TAC,200000
	JRST VDWOK

;ROUTINE TO SEE IF LOOKING AT PRIVATE CHAN IS LEGAL
;AC1=CHAN, TAC=MAPPED CONSOLE, AC3=MAPPING CONSOLE, J=MAPPING JOB.
^VDCCHK:LDB AC2,[DDUSR(AC1)]
	CAIN AC2,100(TAC)
	JRST CPOPJ1		;CAN ALWAYS MAP CONSOLE TO ITSELF
VDCCK0:	TRNE AC2,300
	JRST VDCCK2		;CONSOLE CHAN
VDCCK1:	CAIN J,(AC2)
	JRST CPOPJ1		;JOB OWNS IT
	MOVE AC2,JBTLIN(AC2)
	AOJE AC2,CPOPJ		;DETACHED
	TLNN AC2,PTYLIN
	JRST VDCCK3
	MOVE AC2,PTYJOB-PTYL0-1(AC2)	;SEE IF IT CAN GET TO IT VIA PTY
	JRST VDCCK1

VDCCK2:	ADD AC2,[DDDLIN-1,,DDL0-100+1]
VDCCK3:	TLNE AC2,DDDLIN
	CAIE AC3,-1(AC2)		;JOB'S OWN CONSOLE WINS
	POPJ P,
	JRST CPOPJ1

BEND DPYSER
                                                                                                                                                                 SUBTTL WHO LINE GENERATOR--R. HELLIWELL--6/APR/70
COMMENT 
	THIS ROUTINE ALLOWS EACH LUCKY OWNER OF A DISPLAY
TO HAVE ONE LINE OF "WHO" INFORMATION ON HIS SCREEN AT ANY TIME
IT USES THE LINE EDITOR FOR ACTIVATION IN THE FOLLOWING MANNER.

	<ESC>W
	TO DISPLAY THE WHO LINE FOR THE JOB ATTACHED TO THIS DPY.

	<ESC><N>W
	TO DISPLAY THE WHO LINE FOR JOB N ON THIS DPY.

	<BREAK>W
	STOP THE WHO LINE.

LOOK FOR CODE IN THE LINE EDITOR AROUND THE LABEL "ESCW".
ALSO IN DPYSER.
WHOSER IS CALLED FROM CLKINT.



BEGIN WHOSER

GLOBAL DDUSR

DISJSR__24		;STORES RETURN
DISJMP__20		;JUMP
DISNOP__12		;GOOD NO-OP WITH NO BITS.
DEFINE CW (C1,B1,C2,B2,C3,B3) {<BYTE (8)<B1>,<B2>,<B3>(3)<C1>,<C2>,<C3>>!4~

;AC'S USED
;WHO IS FOR DPY # AND JOB STATUS WORD.
;TAC AND TAC1 AND AC2 ARE SORT OF TEMPORARY
;AC1 LOCATION OF FREE STORAGE BUFFER.
;AC3 BYTE POINTER TO FREE STORAGE, INDEXED BY AC1
;J CONTAINS JOB NUMBER OF WHO LINE.

;WHOPTR 0 = LINE IS FREE.
;      >0 = LINE IS WAITING TO BE QUEUED
;      -2 OR -1 = LINE HAS BEEN QUEUED.

WHO_TEM			;DPY INDEX AT TOP LEVEL.

^WHOINI:
REPEAT 0,<	; THESE CELLS ARE ALL BETWEEN SYSBEG AND SYSEND AND THUS GET ZEROED AT SYSINI
	SETZM	WHONXT			;NUMBER OF III DONE LAST
	SETZM	WHDDNXT			;NUMBER OF THE DD DONE LAST
	SETZM	JBSRUN			;BITS FOR JOBS THAT
	SETZM	JBSRUN+1		;  HAVE RUN LATELY
	SETZM	FREWAT
	SETZM	FRETAB			;FREE STORAGE POINTER FOR EACH WHO LINE
	SETZM	WHOPTR			;POINTER TO THE DD THAT WAS DONE LAST.
					;SEE WHOQUE IN DPYSER
	MOVE	TAC,[XWD FRETAB,FRETAB+1]
	BLT	TAC,FRETAB+DDNUM+DPYNUM-1
>;END REPEAT 0
	POPJ	P,
                                                                                                                                                                                                                                                                                                                     ^WHOSER:MOVE	DAT,TIME
	TRNE	DAT,1				;EVEN TIC?
	POPJ	P,				;NO, SKIP IT.
	MOVE	AC1,FREWAT
	JUMPE	AC1,.+2				;WAITING TO GIVE BACK FREE STORAGE?
	PUSHJ	P,FSGIVE			;YES. DO IT.
	SETZM	FREWAT
;WE DO WHO LINES FOR 5 III DISPLAYS IN 10. TICKS, THEN
;ON THE 12.TH  TICK WE DO ONE DD LINE AND THE OTHER III.
WHOIII:	SOSL	WHO,WHONXT			;NEXT GUY TO DO.
	JRST	WHODO1				;JUMP IF THERE'S ANOTHER III TO DO
WHODO:	MOVE	TAC,DDOFF			;DATA DISK IS OFF?
	JUMPN	TAC,WHODO9			;JUMP IF DD IS OFF.
	MOVE	TAC,WHOPTR			;DD WHO LINE STILL BUSY?
	JUMPN	TAC,WHODO2			;IF SO, LEAVE EARLY.
WHODO9:	SOSLE	AC1,WHOKLU			;COUNT DOWN TO AVL MSG SHIFT
	JRST	WHODO4
	PUSHJ	P,DDAVST			;THIS MOVES IT
	MOVEI	AC1,=300
	MOVEM	AC1,WHOKLU	;300 WHODO'S IS A MINUTE (BEFORE NEXT SHIFT OF MSG)
	MOVEI	WHO,DDAVLU			;WHOKLU SET, SERVICE AVLCHN NOW
	JRST	WHODO3
WHODO4:	SOSGE	WHO,WHDDNXT			;WHO'S NEXT FOR WHO
	PUSHJ	P,WHOSYS			;END OF DD.  RECALCULATE SYSTEM LINE
	LDB	WHO,[DDUSR(WHO)]		;MAP FROM DD CHANNEL TO TTY NUMBER
	CAIN	WHO,DDAVLU			;AVAILABLE CHANNEL?
	JRST	WHODO3				;YES, SKIP WHODO1
	CAIL	WHO,100
	CAILE	WHO,177
	JRST	WHODO2				;NOT USER'S CONSOLE
	SUBI	WHO,100-DPYNUM			;MAKE DPY (TTY) NUMBER
	PUSHJ	P,WHODO1			;GO REFRESH ONE MORE DD WHO LINE
WHODO3:	MOVEM	WHO,WHOPTR			;SET TO FLAG WHOQUE.
WHODO2:	MOVEI	WHO,DPYNUM-1			;START ON III DISPLAYS AGAIN
	MOVEM	WHO,WHONXT			;SAVE INDEX OF WHO WAS DONE LAST

WHODO1:	MOVE	AC1,FRETAB(WHO)			;GET THE FREE STORAGE BLOCK
	MOVE	DDB,LETAB(WHO)			;GET PTR TO DPY HEADER
	JUMPE	DDB,WHOCLR			;JUMP IF NO DPY HEADER
	HRRZ	J,WHOTAB(DDB)			;GET JOB NUMBER FOR THIS LINE.
	MOVE	DAT,JBTSTS(J)			;GET JOB'S STATUS WORD
	TLNN	DAT,JNA				;IS IT STILL THERE?
	SETZB	J,WHOTAB(DDB)			;NO, FLUSH!
	JUMPE	J,WHOCLR			;JUMP IF NO WHO REQUEST
						;CHECK FOR RELEASE OF FREE STORAGE
	JUMPE	AC1,WHOSET			;JUMP IF WE NEED TO MAKE FS BLOCK.
	MOVE	DAT,WHDDNXT
	CAIGE	WHO,DPYNUM			;ALWAYS UPDATE SLOW PART FOR DD
	TRNN	DAT,3				;UPDATE WHOLE III AFTER 4 DATA DISKS
	JRST	WHOLIN				;COMPUTE ENTIRE LINE.
	JRST	ALWAYS				;JUST DO THE FAST PART THIS TIME

WHOCLR:	JUMPE	AC1,CPOPJ			;DO WE HAVE FREE STORAGE BLOCK
	SETZM	FRETAB(WHO)			;YES. CLEAR FRETAB
	HRRZM	AC1,FREWAT			;YES, QUEUE IT FOR NEXT TIC.
	CAIL	WHO,DPYNUM			;IS THIS A DATA DISC DISPLAY?
	POPJ	P,				;YES, LEAVE EARLY
	HRRZ	DDB,LETAB(WHO)
	JUMPE	DDB,CPOPJ			;IF SLIPPED OUT FROM UNDER US, FORGET IT
	MOVEI	TAC,DISNOP			;RESET WHOCALL.
	MOVEM	TAC,WHOCALL(DDB)
	MOVSI	TAC,400000			;DONT SELECT III FOR SYS WHO LINE
	MOVNI	AC2,(WHO)
	LSH	TAC,(AC2)
	ANDCAM	TAC,WHOSEL			;TURN OFF SET BIT
	LSH	TAC,-=12			;DESELECT THIS III FOR SYS WHO LINE
	ORM	TAC,WHOSEL			;TURN ON RESET BIT
	JRST	WHORST				;RESTART POOLE AND RETURN TO CLKSER
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            WHOSIX:	MOVEI	AC2,6			;CHARACTER COUNT
WHOSXX:	MOVEI	TAC,0			;DATA IN TAC1
	LSHC	TAC,6
	ADDI	TAC," "
	IDPB	TAC,AC3
	SOJG	AC2,WHOSXX
	POPJ	P,

;WSDPAD - CALL WITH
;	AC3 = BYTE POINTER
;	AC2 = CHARACTER COUNT
;	TAC = DATA
;	TAC1, UCHN, DAT ARE CLOBBERED.
;	PRINTS NUMBER WITH LEADING SPACES.
;CALL WSDPD2 WITH UCHN = RADIX; DAT = PADDING CHARACTER. AC3,AC2,TAC AS ABOVE.
;CALL WSDPD3 WITH UCHN = RADIX.  USES BLANK PADDING.
WSDPAD:	MOVEI	UCHN,=10
WSDPD3:	MOVEI	DAT," "			;PADDING CHARACTER
WSDPD2:	IDIVI	TAC,(UCHN)
	HRLM	TAC1,(P)
	SUBI	AC2,1			;COUNT A CHARACTER GENERATED.
	JUMPE	TAC,WSDPD1
	PUSHJ	P,WSDPD2
WSDPD0:	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,AC3
	POPJ	P,

WSDPD1:	SOJL	AC2,WSDPD0
	IDPB	DAT,AC3
	JRST	WSDPD1

WPER2D:	IMULI	TAC,=100	;PRINT TAC/TAC1 AS A PERCENTAGE IN 2 DIGITS
	IDIV	TAC,TAC1
	CAIL	TAC,=100
	MOVEI	TAC,=99		;PRINT 99 FOR 100
				;FALL INTO W0PD2

;PRINT A 2 DIGIT DECIMAL NUMBER PADDED WITH A LEADING ZERO IF NECESSARY
;CALL WITH NUMBER IN TAC, BYTE POINTER IN AC3.  CLOBBERS TAC1
W0PD2:	IDIVI	TAC,=10
	ADDI	TAC,"0"
	IDPB	TAC,AC3
	ADDI	TAC1,"0"
	IDPB	TAC1,AC3
	POPJ	P,

;PRINT A DECIMAL NUMBER PADDING WITH FOLLOWING BLANKS
;	TAC = DATA
;	AC2 = CHARACTER COUNT
;	AC3 = BYTE POINTER
;TAC, AC2, TAC1 AND DAT ARE CLOBBERED
DECPDF:	MOVEI	DAT," "			;THIS IS THE CHARACTER TO PAD WITH
	PUSHJ	P,WHPRNT		;CONVERT TAC TO ASCII AND SAVE CHARACTERS
	SOJL	AC2,CPOPJ		;ANY PADDING NEEDED?
	IDPB	DAT,AC3			;YES.  PAD WITH A BLANK
	SOJGE	AC2,.-1			;MORE PADDING NEEDED?
	POPJ	P,			;NOPE

WHPRNT:	IDIVI	TAC,=10			;ROUTINE TO DO THE WORK FOR DECPDF
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,WHPRNT
	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,AC3			;DEPOSIT ONE DECIMAL DIGIT
	SUBI	AC2,1			;NOTE THAT WE HAVE PUT OUT A CHARACTER
	POPJ	P,
                                                                                                                     ;THIS IS THE PART WE ALWAYS UPDATE.
ALWAYS:	ANDI	J,-1
	MOVE	DAT,JBTSTS(J)
;	TLNN	DAT,JNA
;	JRST	[SETZM WHOTAB(DDB)	;JOB HAS GONE AWAY.
;		POPJ P,]
	MOVE	AC3,[POINT 7,WTEND+4(AC1),34]
	MOVM	TAC,JOBQUE(J)		;GET QUEUE NUMBER.
	MOVE	TAC,QNAMS(TAC)		;GET PRINT NAME.
	TRO	TAC,1
	MOVEM	TAC,@AC3
	MOVEI	TAC," "
	CAMN	J,JOB			;CURRENTLY RUNNING JOB?
	MOVEI	TAC,"-"			;YES
	TLNE	DAT,SWP			;SWAPPED OUT?
	MOVEI	TAC,"*"			;YES
	TRNE	DAT,JLOCK		;LOCKED IN CORE?
	MOVEI	TAC,""			;YES
	DPB	TAC,AC3

	MOVEI	TAC," "
	MOVE	TAC1,SPWGO(J)		;SPACEWAR ON THE 10?
	JUMPE	TAC1,ALWAY1		;NO
	MOVEI	TAC,"\"			;YES
	MOVE	TAC1,SP2GO(J)		;SPACEWAR ON 6 ALSO?
	JUMPE	TAC1,ALWAY2		;NO
	MOVEI	TAC,"X"			;YES
	JRST	ALWAY2

ALWAY1:	MOVE	TAC1,SP2GO(J)		;SPACEWAR ON THE 6?
	JUMPE	TAC1,ALWAY2		;NO
	MOVEI	TAC,"/"			;YES
ALWAY2:	LDB	TAC1,PSEGN		;IS THERE A SEGMENT?
	JUMPE	TAC1,ALWAY3		;NO
	MOVE	TAC1,JBTSTS(TAC1)	;YES
	TLNE	TAC1,SWP		;IS IT SWAPPED OUT?
	MOVEI	TAC,"*"			;YES
ALWAY3:	IDPB	TAC,AC3

;PRINT XTIME INCREMENT
	MOVE	TAC,XTIME(J)		;GET RUN TIME AT LAST INTERACTION
	MOVEI	TAC1,"'"		;PUNCTUATE TICKS WITH RIGHT QUOTE
	TLZE	TAC,400000		; UNLESS NO-UPDATE FLAG SET
	MOVEI	TAC1,42			;IN WHICH CASE USE double QUOTE
	DPB	TAC1,[POINT 7,WTEND+13(AC1),27] ;DEPOSIT PUNCTUATOR
	MOVN	TAC,TAC
	ADD	TAC,TTIME(J)		;CALCULATE INCREMENT IN RUN TIME
	JUMPE	DDB,XTALL		;ALWAYS IF TTY (DDB=0)
	HLRZ	TAC1,WHOTAB(DDB)	;GET INCREMENT FROM LAST TIME
	CAIN	TAC1,(TAC)		;SAME?
	JRST	NOXTIM			;YES.  DON'T UPDATE INCREMENT
	HRLM	TAC,WHOTAB(DDB)		;NO.  SAVE INCREMENT THIS TIME FOR NEXT TIME
XTALL:	IDIVI	TAC,=60			;CONVERT TO SECONDS
	PUSH	P,TAC1			;SAVE TICKS
	MOVE	AC3,[POINT 7,WTEND+12(AC1),13]
	PUSHJ	P,WHOTIM		;PRINT X INCREMENT
	IBP	AC3			;SKIP OVER PUNCTUATOR (ALREADY DEPOSITED)
	POP	P,TAC			;RETRIEVE TICKS
	PUSHJ	P,W0PD2			;PRINT TICKS

NOXTIM:	MOVE	TAC,TTIME(J)		;GET RUN TIME
	JUMPE	DDB,DOTIME		;ALWAYS DO FOR TTY WHO (DDB=0)
	CAML	TAC,WHORUN(DDB)		;TIME TO UPDATE RUN TIME YET?
	JRST	DOTIME			;YES
	ADDI	TAC,=60			;MAYBE NOT.  IS WHORUN REASONABLE?
	CAML	TAC,WHORUN(DDB)
	POPJ	P,			;YES
	SUBI	TAC,=60			;NO, READJUST RUN TIME AND THEN UPDATE
DOTIME:	MOVE	DAT,TAC			;COPY RUN TIME
	IDIVI	TAC,=60			;LEAVE SECONDS IN TAC.
	SUBI	DAT,(TAC1)		;ADJUST DAT TO LAST WHOLE SECOND OF RUN TIME
	ADDI	DAT,=60			; AND THEN ADD ONE SECOND
	SKIPE	DDB			;NOT FOR TTY WHO
	MOVEM	DAT,WHORUN(DDB)		; AND SAVE THAT AS TIME FOR NEXT UPDATE
	MOVE	AC3,[POINT 7,WTEND+10(AC1),6]	;FALL INTO WHOTIM

WHOTIM:	IDIVI	TAC,=60*=60		;HOURS IN TAC, MINUTES, SECONDS IN TAC1
	JUMPE	TAC,[MOVEI DAT," "	;FILL HOURS FIELD WITH ONE SPACE
		DPB DAT,AC3
		MOVEI DAT,0		; AND ONE NULL.  THEN FILL MINUTES WITH NULLS
		IDPB DAT,AC3
		JRST WMIN]
	MOVEI	DAT,"0"			;FLAG TO FILL MINUTES FIELD WITH 0'S
	ADDI	TAC,"0"
	DPB	TAC,AC3
	MOVEI	TAC,":"
	IDPB	TAC,AC3
WMIN:	MOVE	TAC,TAC1
	IDIVI	TAC,=60
	PUSH	P,TAC1			;SAVE SECONDS
	MOVEI	UCHN,=10		;SET RADIX. DAT SET WITH FILL CHARACTER
	MOVEI	AC2,2			;NUMBER OF CHARACTERS TO FILL.
	PUSHJ	P,WSDPD2		;WRITE DECIMAL WITH FILL.
	MOVEI	TAC,":"
	IDPB	TAC,AC3
	POP	P,TAC
	JRST	W0PD2			;WRITE SECONDS AS TWO CHARACTERS.  RETURN.
                   ; THIS ROUTINE SETS UP A NEW WHO TABLE FROM A PIECE OF FREE STORAGE

WHOSET:	MOVEI	AC3,WLINK+1		;GET SIZE.
	PUSHJ	P,FSGET			;GET FREE STORAGE.
	POPJ	P,			;NONE, RETURN.
	MOVEM	AC1,FRETAB(WHO)		;SAVE FREE STORAGE POINTER.
	MOVE	TAC,AC1
	HRLI	TAC,TITLE
	BLT	TAC,WLINK(AC1)		;PUT LINE MODEL INTO FREE STORAGE.
	SETZM	WHORUN(DDB)		;ZERO THE TIME TO UPDATE RUN TIME NEXT
	CAIL	WHO,DPYNUM		;IS THIS A DD DISPLAY?
	JRST	WHOLIN			;YES, NOTHING SPECIAL TO DO
	MOVEI	TAC,DISNOP		;IIIs DONT DO THEIR OWN SYSTEM WHO LINE
	MOVEM	TAC,2(AC1)		; SO A NO-OP REPLACES THE JMP TO SYS LINE
	HRLI	AC1,DISJMP
	MOVSM	AC1,WLINK(AC1)		;STORE JUMP BACK TO FRONT OF BLOCK.
	HRLI	AC1,DISJSR
	MOVE	AC3,LETAB(WHO)
	JUMPE	AC3,WHOCLR		;JUMP IF DPY HEADER DISAPPEARED
	MOVSM	AC1,WHOCALL(AC3)	;STORE JSR TO FS BLOCK WHERE III WILL HIT IT
	ANDI	AC1,-1			;CLEAR LEFT SIDE.
	MOVSI	TAC,400000		;SELECT THIS III FOR SYS WHO LINE
	MOVNI	AC2,(WHO)
	LSH	TAC,(AC2)
	ORM	TAC,WHOSEL		;TURN ON SET BIT
	LSH	TAC,-=12		;DONT DESELECT THIS III FOR SYS WHO LINE
	ANDCAM	TAC,WHOSEL		;TURN OFF RESET BIT
^WHOLIN:PUSHJ	P,ALWAYS
;	HRRZ	TAC,WHOTAB(DDB)		;HAS JOB GONE AWAY?
;	JUMPE	TAC,CPOPJ		;YES. DON'T WORK AT IT.
	HRRZ	TAC,J
	MOVE	AC3,[POINT 7,WTEND(AC1)]
	MOVEI	AC2,2			;2 CHARACTERS
	PUSHJ	P,WSDPAD		;WRITE DECIMAL JOB NUMBER
	MOVE	AC3,[POINT 7,WTEND(AC1),27]
	MOVE	TAC1,PRJPRG(J)		;PROJECT-PROGRAMMER INITIALS.
	PUSHJ	P,WHOSIX		;DO SIXBIT OUTPUT
	HRRE	TAC,JBTLIN(J)		;GET LINE NUMBER AND SEE IF DETACHED
	JUMPL	TAC,[MOVE TAC1,[ASCID /  DET/]
		MOVEM TAC1,WTEND+2(AC1)
		JRST WLRET]
	MOVEI	AC2,5			;NOT DETACHED.  PRINT LINE NO IN 5 SPACES
	MOVEI	UCHN,10			;OCTAL RADIX
	PUSHJ	P,WSDPD3		;WRITE IT WITH BLANK PADDING
                                                                                                                                                                                                                WLRET:	MOVE 	AC3,[POINT 7,WTEND+5(AC1),20]
	MOVE	TAC1,JOBNAM(J)			;JOB NAME
	PUSHJ	P,WHOSIX
	MOVE	TAC,JBTADR(J)			;CORE SIZE.
	JUMPE	TAC,[LDB TAC,IMGIN		;IF SWAPPED OUT, GET SWAPPED SIZE
		JRST WSIZE]
	HLRZ	TAC,TAC
	AOJ	TAC,
	LSH	TAC,-12
WSIZE:	MOVEI	AC2,4			;4 CHARACTERS OUT, PAD WITH BLANKS
	PUSHJ	P,WSDPAD		;WHOSER DECIMAL PAD OUTPUT

	MOVE	AC3,[POINT 7,WTEND+11(AC1),20]	;OVERALL RUN/WAIT PERCENTAGE
	MOVE	TAC,TTIME(J)			;RUN TIME
	MOVE	TAC1,JBTWAT(J)			;WAIT TIME
	JUMPGE	TAC1,.+2			;IS WAIT TIME HONEST?
	ADD	TAC1,UPTIME			;NO.  ADJUST IT
	PUSH	P,TAC1				;SAVE TOTAL WAIT TIME
	PUSHJ	P,WPER2D			;PRINT PERCENTAGE IN 2 COLS WITH LEADING ZERO

	MOVE	AC3,[POINT 7,WTEND+14(AC1),13]	;INCREMENTAL RUN/WAIT PERCENTAGE
	MOVE	TAC,TTIME(J)			;RUN TIME
	MOVE	TAC1,XTIME(J)			;RUN TIME LAST SAVED
	TLZ	TAC1,400000			;CLEAR NO-UPDATE BIT
	SUB	TAC,TAC1			;CALCULATE INCREMENTAL RUN TIME
	POP	P,TAC1				;RETRIEVE CURRENT WAIT TIME
	SUB	TAC1,JB2WAT(J)			;CALCULATE INCREMENTAL WAIT TIME
	PUSHJ	P,WPER2D			;PRINT PERCENTAGE IN 2 COLS WITH LEADING ZERO

	MOVS	TAC1,DSKOPS(J)			;GET NUMBER OF DSK OPS
	HLRZ	TAC,TAC1			;TOTAL NO OF DSK OPS
	SUBI	TAC,(TAC1)			;LESS PREVIOUS TOTAL
	MOVEI	AC2,6				;6 COLS
	PUSHJ	P,WSDPAD			;LEADING BLANKS, DECIMAL NUMBER

	LDB	TAC,PSEGN			;DOES HE HAVE A SECOND SEGMENT?
	JUMPE	TAC,[MOVEI TAC,DISNOP		;NO
		MOVEM TAC,WTEND+16(AC1)
		MOVEM TAC,WTEND+17(AC1)
		JRST WALIAS]
	MOVE	AC3,[POINT 7,WTEND+16(AC1),6]	;YES
	MOVEI	TAC1,1
	MOVEM	TAC1,WTEND+16(AC1)
	MOVEM	TAC1,WTEND+17(AC1)
	MOVEI	TAC1," "
	DPB	TAC1,AC3			;PRECEDE SEGMENT NAME WITH 1 SPACE
	MOVE	TAC1,JOBNAM(TAC)
	MOVEI	AC2,7				;WRITE SIXBIT + 1 SPACE
	PUSHJ	P,WHOSXX

WALIAS:	MOVE	TAC1,DSKPPN(J)			;DOES HE HAVE AN ALIAS?
	JUMPE	TAC1,[MOVEI TAC,DISNOP		;NOPE
		MOVEM TAC,WTEND+20(AC1)
		MOVEM TAC,WTEND+21(AC1)
		POPJ P,]
	MOVEI	TAC,1				;YES
	MOVEM	TAC,WTEND+20(AC1)
	MOVEM	TAC,WTEND+21(AC1)
	MOVE	AC3,[POINT 7,WTEND+20(AC1),6]
	MOVEI	TAC," "
	DPB	TAC,AC3
	MOVEI	TAC,"("
	IDPB	TAC,AC3
	PUSHJ	P,WHOSIX			;PUT IN 6 SIXBIT CHARS FROM DSKPPN
	MOVEI	TAC,")"				; SURROUNDED BY PARENTHESES
	IDPB	TAC,AC3
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^WHOSYS:
	MOVN	TAC,TTIME		;GET CURRENT NULL TIME
	EXCH	TAC,LASTNL		;SAVE IT AND GET PREVIOUS NULL TIME
	ADD	TAC,TTIME		;FIND INCREMENT IN NULL TIME
	MOVN	TAC1,UPTIME		;GET CURRENT UPTIME
	EXCH	TAC1,LASTUP		;SAVE IT AND GET PREVIOUS UP TIME
	ADD	TAC1,UPTIME		;FIND INCREMENT IN UP TIME
	JUMPE	TAC1,NONULL
	IMULI	TAC,=100		;CALCULATE NULL TIME IN PERCENT
	IDIV	TAC,TAC1
	MOVE	AC3,[POINT 7,COMWHO+7,13]
	MOVEI	AC2,3			;PRINT NULL PERCENTAGE IN 3 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH SPACES
NONULL:	MOVE	AC3,[POINT 7,COMWHO+15,13]
	HRRZ	TAC,TIMDAT		;GET TIME OF DAY IN SECS
	IDIVI	TAC,=60			;MINS INTO TAC, SECS INTO TAC1
	IDIVI	TAC,=60			;HOURS INTO TAC, MINS INTO TAC1
	PUSH	P,TAC1			;SAVE MINS
	PUSHJ	P,W0PD2		;WRITE HOURS AS 2 DECIMAL DIGITS, PADDING WITH 0'S
	IBP	AC3			;SKIP OVER COLON AFTER HOURS
	POP	P,TAC			;RETRIEVE MINS
	PUSHJ	P,W0PD2			; AND WRITE 2 DIGIT NUMBER

	MOVE	AC1,THSDAT		;GET TODAY'S DATE
	CAMN	AC1,WHODAT		;NEW DAY ARRIVED YET?
	JRST	WHOSY1			;NO. DONT RECOMPUTE DAY AND DATE
	MOVEM	AC1,WHODAT		;YES

	MOVE	AC3,[ASCID /     /]
	MOVEM	AC3,COMWHO+11		;PUT SPACES INTO WHOLINE
	MOVEM	AC3,COMWHO+12
	
	IDIVI	AC1,=31			;DAY INTO AC2
	PUSH	P,AC2			;SAVE DAY
	IDIVI	AC1,=12			;MONTH INTO AC2
	MOVE	AC1,MONTAB(AC2)		;GET TEXT OF MONTH
	DPB	AC1,[POINT 21,COMWHO+11,34]
	POP	P,TAC			;GET DAY BACK
	ADDI	TAC,1			; AND CORRECT IT
	MOVE	AC3,[POINT 7,COMWHO+12,6]
	MOVEI	AC2,2			;WRITE IT IN 2 COLS
	MOVEI	UCHN,=10		; IN DECIMAL
	MOVEI	DAT,0			; WITH LEADING NULLS
	PUSHJ	P,WSDPD2
	MOVE	TAC,WHODAT		;GET DATE AGAIN
	PUSHJ	P,DAYCNT		;CONVERT TO NUMBER OF DAYS SINCE 1-1-64
	IDIVI	TAC,7			;GET DAY OF WEEK (REMAINDER)
	LSH	TAC1,1			;(TABLE ENTRIES ARE 2 WORDS EACH)
	MOVE	TAC,DAYTAB(TAC1)
	ORI	TAC,1
	MOVEM	TAC,COMWHO+13		;STORE FIRST PART OF DAY
	MOVE	TAC,DAYTAB+1(TAC1)
	ORI	TAC,1
	MOVEM	TAC,COMWHO+14		;STORE SECOND HALF OF DAY

WHOSY1:	MOVE	TAC,DQCNT		;GET NBR OF JOBS IN DISK QUEUE
	MOVE	AC3,[POINT 7,COMWHO+10,13]
	MOVEI	AC2,2			; AND WRITE IT IN 2 COLS
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS

	MOVE	AC3,[POINT 7,COMWHO+2,20]
	MOVN	TAC,DDFCNT		;GET NUMBER OF FREE DD CHANS
	ADDI	TAC,=31			; AND SUBTRACT FROM TOTAL NUMBER
	MOVEI	AC2,2			;PRINT NUMBER OF DD CHANS IN USE
	PUSHJ	P,WSDPAD		; IN 2 SPACES PADDING WITH BLANKS

	MOVE	AC1,JBSRUN		;GET BITS FOR JOBS RUN LATELY
	MOVE	AC2,JBSRUN+1
	LSHC	AC1,2*=36-JOBN		;ADJUST HIGHEST JOB'S BIT TO SIGN BIT OF AC1
	SETZB	TAC,JBSRUN		;TAC = # OF JOBS LOGGED IN.  CLEAR RUN BITS.
	SETZB	TAC1,JBSRUN+1		;TAC1= # OF JOBS RUN LATELY.
	SETZB	DDB,DAT			;DDB = CORE OF JOBS RUN LATELY.
					;DAT = CORE OF ALL JOBS
	MOVSI	WHO,JNA
	MOVEI	J,JOBN-1
WRUN1:	TDNN	WHO,JBTSTS(J)		;IS THIS JOB LOGGED IN?
	JRST	WRUN2			;NOPE
	ADDI	TAC,1			;YES.  COUNT HIM
	HLRZ	UCHN,JBTADR(J)		;GET HIS CORE SIZE
	JUMPN	UCHN,.+3		;IS HE SWAPPED OUT?
	LDB	UCHN,IMGIN		;YES.  GET SIZE
	LSH	UCHN,12			; AND ADJUST TO ACTUAL SIZE (NOT 1K BLOCKS)
	ADD	DAT,UCHN		;ADD CORE SIZE TO TOTAL FOR ALL JOBS
	TLNN	AC1,400000		;HAS THIS JOB RUN LATELY?
	JRST	WRUN2			;NOPE.  FORGET HIM
	ADDI	TAC1,1			;YES.  COUNT HIM
	ADD	DDB,UCHN		; AND ADD IN HIS CORE
WRUN2:	LSHC	AC1,1			;PUT NEXT JOB'S BIT IN SIGN OF AC1
	SOJG	J,WRUN1			;MOVE ON TO NEXT JOB, IF ANY

	PUSH	P,TAC1			;SAVE # OF JOBS RUN LATELY
	PUSH	P,DAT			;SAVE TOTAL CORE SIZE
	MOVEI	AC2,4			;WRITE # OF JOBS IN 4 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS,
	IBP	AC3			; AND SKIP OVER THE COMMA (EG: 12,888)
	POP	P,TAC			;GET BACK TOTAL CORE SIZE,
	ADDI	TAC,1777		; ROUND IT UP,
	LSH	TAC,-12			; CONVERT TO 1K BLOCKS,
	MOVEI	AC2,4			; AND PRINT IN 4 SPACES
	PUSHJ	P,DECPDF		; WITH FOLLOWING BLANKS
	POP	P,TAC			;GET BACK # OF JOBS RUN LATELY
	MOVEI	AC2,3			; AND WRITE IT IN 3 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS,
	IBP	AC3			; AND SKIP OVER THE COMMA AGAIN
	MOVE	TAC,DDB			;GET CORE OF JOBS RUN LATELY,
	ADDI	TAC,1777		; ROUND IT UP,
	LSH	TAC,-12			; AND CONVERT TO 1K BLOCKS.
	MOVEI	AC2,3			;WRITE IT IN 4 SPACES,
	PUSHJ	P,DECPDF		; PADDING WITH FOLLOWING BLANKS

	MOVE	TAC,CORMAX		;GET AMOUNT OF AVAILABLE CORE,
	LSH	TAC,-12			; CONVERT IT TO 1K BLOCKS,
	MOVEI	AC2,4			; AND PRINT IT IN 4 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS

	MOVEI	WHO,37			;START OVER WITH FIRST DD CHAN
	MOVEM	WHO,WHDDNXT
	POPJ	P,

BEND WHOSER
                                                                                                                                                       